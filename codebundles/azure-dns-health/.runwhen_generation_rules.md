# RunWhen Generation Rules for Azure DNS Health

This document describes the generation rules and patterns used by the RunWhen platform to automatically create SLX (Service Level eXpectation) objects for the `azure-dns-health` codebundle.

## Overview

The Azure DNS Health codebundle provides comprehensive monitoring and troubleshooting capabilities for Azure DNS infrastructure. The generation rules help automatically identify when to create runbooks and SLIs based on DNS-related issues and patterns.

## File Structure

### Pattern Files

- **`runbook_patterns.json`**: Comprehensive patterns for runbook generation, including various severity levels
- **`sli_critical_patterns.json`**: Critical patterns only for SLI generation, focused on service availability

## Pattern Categories

### 1. DNSResolutionFailure (Severity 1)
**Critical DNS resolution failures indicating service unavailability**

Patterns:
- `NXDOMAIN` - Domain does not exist
- `dns.*resolution.*failed` - General DNS resolution failures
- `name.*resolution.*failed` - Name resolution specific failures
- `can't find.*No answer` - DNS server cannot resolve the query
- `server can't find` - Authoritative server cannot find the record
- `connection timed out.*no servers could be reached` - DNS server connectivity issues
- `Query refused` - DNS server refusing queries

**When to use**: When DNS resolution is completely failing, indicating service unavailability.

### 2. AzureDNSCritical (Severity 1)
**Critical Azure-specific DNS service failures**

Patterns:
- `Microsoft\.Network.*error` - Azure Network service errors
- `Azure.*DNS.*error` - General Azure DNS service errors
- `privatelink.*resolution.*failed` - Private DNS zone resolution failures
- `azure.*dns.*zone.*error` - Azure DNS zone specific errors
- `resource.*health.*unavailable` - Azure resource health check failures
- `dns.*resolver.*unreachable` - Azure DNS resolver connectivity issues

**When to use**: When Azure DNS services are experiencing critical failures.

### 3. DNSZoneIssues (Severity 1-2)
**DNS zone configuration and health problems**

Patterns:
- `zone.*not.*found` - DNS zone missing or misconfigured
- `zone.*transfer.*failed` - Zone transfer operations failing
- `zone.*expired` - DNS zone has expired
- `SOA.*record.*missing` - Start of Authority record missing
- `NS.*record.*missing` - Name Server record missing
- `zone.*delegation.*failed` - DNS delegation not working
- `authoritative.*server.*unreachable` - Cannot reach authoritative DNS server

**When to use**: When DNS zones have configuration or operational issues.

### 4. NetworkConnectivity (Severity 2)
**Network connectivity issues affecting DNS**

Patterns:
- `connection.*refused` - Network connection refused
- `network.*unreachable` - Network routing issues
- `host.*unreachable` - Specific host unreachable
- `timeout.*error` - Network timeout errors
- `no.*route.*to.*host` - Routing table issues

**When to use**: When network connectivity is impacting DNS operations.

### 5. PerformanceIssues (Severity 3)
**DNS performance and latency problems**

Patterns:
- `dns.*query.*slow` - Slow DNS query responses
- `high.*latency` - High DNS resolution latency
- `response.*time.*exceeded` - DNS response time SLA violations
- `query.*rate.*limit.*exceeded` - DNS query rate limiting

**When to use**: When DNS is working but performance is degraded.

## Generation Logic

### Runbook Generation
Runbooks are generated when:
1. **Critical patterns** (severity 1) are detected
2. **Multiple related patterns** are found within a time window
3. **Performance degradation** patterns persist over time
4. **Configuration errors** are detected

### SLI Generation
SLIs are generated when:
1. **Only critical patterns** (severity 1) are detected
2. **Service availability** is impacted
3. **Core DNS functionality** is failing

## Configuration Parameters

### Runbook Patterns Config
```json
{
  "max_matches_per_pattern": 15,
  "case_sensitive": false,
  "timeout_seconds": 45
}
```

### SLI Patterns Config
```json
{
  "max_matches_per_pattern": 10,
  "case_sensitive": false,
  "timeout_seconds": 30
}
```

## Exclude Patterns

Both runbook and SLI generation exclude:
- **Log level indicators**: `INFO`, `DEBUG`, `TRACE`
- **Routine operations**: `health.*check.*passed`, `monitoring.*query`
- **Maintenance activities**: `routine.*maintenance`, `scheduled.*update`
- **Successful operations**: `dns.*resolution.*successful`, `service.*started`

## Auto-Discovery Integration

The generation rules work seamlessly with the auto-discovery functionality:

1. **Auto-discovery** identifies Azure DNS resources automatically
2. **Generation rules** apply to discovered resources
3. **SLX objects** are created with proper resource context
4. **Variables** are pre-populated from discovery results

## Usage Examples

### Example 1: DNS Resolution Failure
```
Log: "NXDOMAIN: can't find api.myapp.com: No answer"
Result: Triggers DNSResolutionFailure pattern (severity 1)
Action: Creates both runbook and SLI
```

### Example 2: Azure Private DNS Issue
```
Log: "privatelink.database.windows.net resolution failed"
Result: Triggers AzureDNSCritical pattern (severity 1)
Action: Creates both runbook and SLI with Azure-specific context
```

### Example 3: Performance Degradation
```
Log: "dns query slow: response time 2.5s exceeded threshold"
Result: Triggers PerformanceIssues pattern (severity 3)
Action: Creates runbook only (not critical enough for SLI)
```

## Best Practices

1. **Pattern Specificity**: Use specific patterns for Azure DNS scenarios
2. **Severity Mapping**: Map severity levels to appropriate response actions
3. **Context Preservation**: Include Azure resource context in generated objects
4. **Auto-Discovery**: Leverage auto-discovery for resource identification
5. **Performance Tuning**: Adjust timeout and match limits based on environment

## Customization

To customize generation rules:

1. **Modify patterns**: Update `runbook_patterns.json` or `sli_critical_patterns.json`
2. **Adjust severity**: Change severity levels to match your requirements
3. **Add exclusions**: Include additional exclude patterns for your environment
4. **Tune configuration**: Modify timeout and match limits as needed

## Integration with RunWhen Platform

These generation rules integrate with:
- **RunWhen Discovery Engine**: For automatic resource identification
- **SLX Generation Service**: For creating service level expectations
- **Alert Correlation**: For linking alerts to appropriate runbooks/SLIs
- **Auto-Remediation**: For triggering automated response actions

## Monitoring and Maintenance

Regular maintenance tasks:
1. **Review pattern effectiveness**: Analyze generation accuracy
2. **Update patterns**: Add new patterns based on observed issues
3. **Tune thresholds**: Adjust severity and timing parameters
4. **Validate exclusions**: Ensure exclude patterns remain relevant
