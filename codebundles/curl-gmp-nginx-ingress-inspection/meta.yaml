commands:
- command: 'gcloud auth activate-service-account --key-file=$GOOGLE_APPLICATION_CREDENTIALS
    && curl -d "query=rate(nginx_ingress_controller_requests{host=''${INGRESS_HOST}'',
    service=''${INGRESS_SERVICE}'', status=~''${ERROR_CODES}''}[${TIME_SLICE}]) >
    0" -H "Authorization: Bearer $(gcloud auth print-access-token)" ''https://monitoring.googleapis.com/v1/projects/${GCP_PROJECT_ID}/location/global/prometheus/api/v1/query''
    | jq -r ''if .data.result[0] then "Host:" + .data.result[0].metric.host + " Ingress:"
    + .data.result[0].metric.ingress + " Namespace:" + .data.result[0].metric.exported_namespace
    + " Service:" + .data.result[0].metric.service else "" end'''
  doc_links: '

    - [gcloud auth activate-service-account](https://cloud.google.com/sdk/gcloud/reference/auth/activate-service-account){:target="_blank"}

    - [curl](https://curl.se/docs/manpage.html){:target="_blank"}

    - [Prometheus Querying and API Usage](https://prometheus.io/docs/prometheus/latest/querying/api/){:target="_blank"}

    - [jq Manual](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: "This command is used to query Prometheus metrics for the nginx_ingress_controller_requests\
    \ in a Kubernetes cluster. It first authenticates the service account using gcloud\
    \ and then sends a request to the Google Cloud Monitoring API to retrieve the\
    \ desired metrics.\n\nHere's a breakdown of the command:\n- `gcloud auth activate-service-account\
    \ --key-file=$GOOGLE_APPLICATION_CREDENTIALS`: This part of the command uses the\
    \ `gcloud` tool to activate the service account by providing the key file which\
    \ contains the necessary credentials for authentication.\n\n- `curl -d \"query=rate(nginx_ingress_controller_requests{host='${INGRESS_HOST}',\
    \ service='${INGRESS_SERVICE}', status=~'${ERROR_CODES}'}[${TIME_SLICE}]) > 0\"\
    \ -H \"Authorization: Bearer $(gcloud auth print-access-token)\" 'https://monitoring.googleapis.com/v1/projects/${GCP_PROJECT_ID}/location/global/prometheus/api/v1/query'`:\
    \ \n  - This part is a `curl` command that makes an HTTP POST request to the Google\
    \ Cloud Monitoring API endpoint for querying Prometheus metrics.\n  - It specifies\
    \ the query as a rate of nginx_ingress_controller_requests with specific host,\
    \ service, and status codes over a defined time slice.\n  - It includes the Authorization\
    \ header with a Bearer token obtained from `gcloud auth print-access-token`.\n\
    \n- `| jq -r 'if .data.result[0] then \"Host:\" + .data.result[0].metric.host\
    \ + \" Ingress:\" + .data.result[0].metric.ingress + \" Namespace:\" + .data.result[0].metric.exported_namespace\
    \ + \" Service:\" + .data.result[0].metric.service else \"\" end'`:\n  - This\
    \ part pipes the output of the previous command into `jq`, a command-line JSON\
    \ processor, to parse and format the response.\n  - It extracts specific information\
    \ from the JSON response related to the queried metrics, such as host, ingress,\
    \ namespace, and service.\n\nIn summary, this command handles authentication,\
    \ sends a request to the monitoring API to query Prometheus metrics, and then\
    \ processes the response to extract and display relevant information about the\
    \ nginx Ingress controller requests in the Kubernetes cluster."
  multi_line_details: "```bash\n# Activate the service account using gcloud auth command\
    \ with the key file specified by the environment variable GOOGLE_APPLICATION_CREDENTIALS\n\
    gcloud auth activate-service-account --key-file=$GOOGLE_APPLICATION_CREDENTIALS\
    \ \n\n# Use the curl command to send a POST request with the specified query parameters\
    \ to the Google Cloud Monitoring API\ncurl -d \"query=rate(nginx_ingress_controller_requests{host='${INGRESS_HOST}',\
    \ service='${INGRESS_SERVICE}', status=~'${ERROR_CODES}'}[${TIME_SLICE}]) > 0\"\
    \ -H \"Authorization: Bearer $(gcloud auth print-access-token)\" 'https://monitoring.googleapis.com/v1/projects/${GCP_PROJECT_ID}/location/global/prometheus/api/v1/query'\
    \ \n\n# Use jq to parse the JSON response and extract specific data from it\n\
    | jq -r 'if .data.result[0] then \"Host:\" + .data.result[0].metric.host + \"\
    \ Ingress:\" + .data.result[0].metric.ingress + \" Namespace:\" + .data.result[0].metric.exported_namespace\
    \ + \" Service:\" + .data.result[0].metric.service else \"\" end'\n```"
  name: fetch_nginx_http_errors_from_gmp_for_ingress_ingress_object_name
- command: 'namespace="${NAMESPACE}"; context="${CONTEXT}"; ingress="${INGRESS_OBJECT_NAME}";
    echo "Ingress: $ingress"; health_status="NA"; services=(); backend_services=$(kubectl
    get ingress "$ingress" -n "$namespace" --context "$context" -ojsonpath=''{range
    .spec.rules[*].http.paths[*]}{.backend.service.name}{" "}{.backend.service.port.number}{"\n"}{end}'');
    IFS=$''\n''; for line in $backend_services; do service=$(echo "$line" | cut -d
    " " -f 1); port=$(echo "$line" | cut -d " " -f 2); if [ -n "$service" ] && [ -n
    "$port" ]; then echo "Backend Service: $service, Port: $port"; service_exists=$(kubectl
    get service "$service" -n "$namespace" --context "$context" -ojsonpath=''{.metadata.name}'');
    if [ -z "$service_exists" ]; then health_status="Unhealthy"; echo "Validation:
    Service $service does not exist"; else endpoint_pods=$(kubectl get endpoints "$service"
    -n "$namespace" --context "$context" -ojsonpath=''{range .subsets[*].addresses[*]}-
    Pod Name: {.targetRef.name}, Pod IP: {.ip}\n{end}''); if [ -z "$endpoint_pods"
    ]; then health_status="Unhealthy"; echo "Validation: Endpoint for service $service
    does not have any pods"; else echo "Endpoint Pod:"; echo -e "$endpoint_pods";
    for pod in $endpoint_pods; do if [[ $pod == *"- Pod Name: "* ]]; then pod_name="\${pod#*-
    Pod Name: }"; pod_name="\${pod_name%%,*}"; if [ -n "$pod_name" ]; then owner_kind=$(kubectl
    get pod "$pod_name" -n "$namespace" --context "$context" -o=jsonpath=''{.metadata.ownerReferences[0].kind}'');
    if [ -n "$owner_kind" ]; then if [ "$owner_kind" = "StatefulSet" ] || [ "$owner_kind"
    = "DaemonSet" ]; then owner_info="$(kubectl get pod "$pod_name" -n "$namespace"
    --context "$context" -o=jsonpath=''{.metadata.ownerReferences[0].name}'') $owner_kind";
    else replicaset=$(kubectl get pod "$pod_name" -n "$namespace" --context "$context"
    -o=jsonpath=''{.metadata.ownerReferences[0].name}''); if [ -n "$replicaset" ];
    then owner_kind=$(kubectl get replicaset "$replicaset" -n "$namespace" --context
    "$context" -o=jsonpath=''{.metadata.ownerReferences[0].kind}''); owner_name=$(kubectl
    get replicaset "$replicaset" -n "$namespace" --context "$context" -o=jsonpath=''{.metadata.ownerReferences[0].name}'');
    owner_info="$owner_name $owner_kind"; fi; fi; fi; if [ -n "$owner_info" ]; then
    echo "Owner: $owner_info"; fi; fi; fi; done; health_status="Healthy"; fi; fi;
    services+=("$service"); fi; done; for service in "\${services[@]}"; do service_exists=$(kubectl
    get service "$service" -n "$namespace" --context "$context" -ojsonpath=''{.metadata.name}'');
    if [ -z "$service_exists" ]; then health_status="Unhealthy"; echo "Validation:
    Service $service does not exist"; else endpoint_exists=$(kubectl get endpoints
    "$service" -n "$namespace" --context "$context" -ojsonpath=''{.metadata.name}'');
    if [ -z "$endpoint_exists" ]; then health_status="Unhealthy"; echo "Validation:
    Endpoint for service $service does not exist"; fi; fi; done; if [ "$health_status"
    = "Unhealthy" ]; then echo "Health Status: $health_status"; echo "=====================";
    elif [ "$health_status" = "Healthy" ]; then echo "Health Status: $health_status";
    fi; echo "------------"'
  doc_links: '

    - [Kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Understanding Kubernetes Network Policies](https://www.stackrox.com/post/2019/01/understanding-kubernetes-network-policies/){:target="_blank"}'
  explanation: 'This is a complex command that is used to check the health status
    of a Kubernetes Ingress and its associated services. Let''s break it down step
    by step.


    1. First, three variables are being defined: `namespace`, `context`, and `ingress`.
    These variables will be used throughout the command to specify the Kubernetes
    namespace, context, and name of the Ingress object.


    2. The command then prints the name of the Ingress using `echo`.


    3. A variable called `health_status` is initialized with the value "NA". This
    will be used to track the health status of the services associated with the Ingress.


    4. An empty array called `services` is created, where we will store the names
    of the backend services associated with the Ingress.


    5. The command then retrieves information about the backend services associated
    with the Ingress using `kubectl get ingress ... -ojsonpath=...`. This information
    includes the name and port number of each backend service.


    6. It then loops through each line of the backend services information and checks
    for the existence of each service. If the service exists, it retrieves additional
    information including the associated endpoint pods, owner details, and sets the
    health status accordingly.


    7. After processing all backend services, it iterates through the list of services
    again to perform additional validation checks on each service and its endpoint
    existence.


    8. Finally, based on the `health_status` value, it prints out the overall health
    status of the Ingress and its associated services.


    This command is quite complex and does a lot of work in a single line. As you
    continue learning and working with Kubernetes, you''ll become more comfortable
    understanding and writing similar commands.'
  multi_line_details: "```bash\n# Set the namespace, context, and ingress object name\
    \ from environment variables\nnamespace=\"${NAMESPACE}\"\ncontext=\"${CONTEXT}\"\
    \ningress=\"${INGRESS_OBJECT_NAME}\"\n\n# Output the name of the Ingress object\n\
    echo \"Ingress: $ingress\"\n\n# Initialize health status and services array\n\
    health_status=\"NA\"\nservices=()\n\n# Get backend services from the specified\
    \ Ingress object\nbackend_services=$(kubectl get ingress \"$ingress\" -n \"$namespace\"\
    \ --context \"$context\" -ojsonpath='{range .spec.rules[*].http.paths[*]}{.backend.service.name}{\"\
    \ \"}{.backend.service.port.number}{\"\\n\"}{end}')\n\n# Set delimeter to newline\n\
    IFS=$'\\n'\nfor line in $backend_services; do\n  # Parse backend service and port\
    \ from the output\n  service=$(echo \"$line\" | cut -d \" \" -f 1)\n  port=$(echo\
    \ \"$line\" | cut -d \" \" -f 2)\n\n  # Check if service and port are not empty\n\
    \  if [ -n \"$service\" ] && [ -n \"$port\" ]; then\n    # Output backend service\
    \ and port\n    echo \"Backend Service: $service, Port: $port\"\n\n    # Check\
    \ if the service exists\n    service_exists=$(kubectl get service \"$service\"\
    \ -n \"$namespace\" --context \"$context\" -ojsonpath='{.metadata.name}')\n  \
    \  if [ -z \"$service_exists\" ]; then\n      # Update health status and output\
    \ validation message\n      health_status=\"Unhealthy\"\n      echo \"Validation:\
    \ Service $service does not exist\"\n    else\n      # Get endpoint pods for the\
    \ service\n      endpoint_pods=$(kubectl get endpoints \"$service\" -n \"$namespace\"\
    \ --context \"$context\" -ojsonpath='{range .subsets[*].addresses[*]}- Pod Name:\
    \ {.targetRef.name}, Pod IP: {.ip}\\n{end}')\n\n      # Check if there are no\
    \ endpoint pods\n      if [ -z \"$endpoint_pods\" ]; then\n        # Update health\
    \ status and output validation message\n        health_status=\"Unhealthy\"\n\
    \        echo \"Validation: Endpoint for service $service does not have any pods\"\
    \n      else\n        # Output endpoint pods\n        echo \"Endpoint Pod:\"\n\
    \        echo -e \"$endpoint_pods\"\n\n        # Iterate through endpoint pods\n\
    \        for pod in $endpoint_pods; do\n          if [[ $pod == *\"- Pod Name:\
    \ \"* ]]; then\n            pod_name=\"${pod#*- Pod Name: }\"\n            pod_name=\"\
    ${pod_name%%,*}\"\n\n            # Get owner kind for the pod\n            owner_kind=$(kubectl\
    \ get pod \"$pod_name\" -n \"$namespace\" --context \"$context\" -o=jsonpath='{.metadata.ownerReferences[0].kind}')\n\
    \            if [ -n \"$owner_kind\" ]; then\n              if [ \"$owner_kind\"\
    \ = \"StatefulSet\" ] || [ \"$owner_kind\" = \"DaemonSet\" ]; then\n         \
    \       owner_info=\"$(kubectl get pod \"$pod_name\" -n \"$namespace\" --context\
    \ \"$context\" -o=jsonpath='{.metadata.ownerReferences[0].name}') $owner_kind\"\
    \n              else\n                replicaset=$(kubectl get pod \"$pod_name\"\
    \ -n \"$namespace\" --context \"$context\" -o=jsonpath='{.metadata.ownerReferences[0].name}')\n\
    \                if [ -n \"$replicaset\" ]; then\n                  owner_kind=$(kubectl\
    \ get replicaset \"$replicaset\" -n \"$namespace\" --context \"$context\" -o=jsonpath='{.metadata.ownerReferences[0].kind}')\n\
    \                  owner_name=$(kubectl get replicaset \"$replicaset\" -n \"$namespace\"\
    \ --context \"$context\" -o=jsonpath='{.metadata.ownerReferences[0].name}')\n\
    \                  owner_info=\"$owner_name $owner_kind\"\n                fi\n\
    \              fi\n            fi\n            if [ -n \"$owner_info\" ]; then\n\
    \              echo \"Owner: $owner_info\"\n            fi\n          fi\n   \
    \     done\n\n        # Update health status\n        health_status=\"Healthy\"\
    \n      fi\n    fi\n\n    # Add the service to the services array\n    services+=(\"\
    $service\")\n  fi\ndone\n\n# Iterate through services and perform additional validations\n\
    for service in \"${services[@]}\"; do\n  service_exists=$(kubectl get service\
    \ \"$service\" -n \"$namespace\" --context \"$context\" -ojsonpath='{.metadata.name}')\n\
    \  if [ -z \"$service_exists\" ]; then\n    health_status=\"Unhealthy\"\n    echo\
    \ \"Validation: Service $service does not exist\"\n  else\n    endpoint_exists=$(kubectl\
    \ get endpoints \"$service\" -n \"$namespace\" --context \"$context\" -ojsonpath='{.metadata.name}')\n\
    \    if [ -z \"$endpoint_exists\" ]; then\n      health_status=\"Unhealthy\"\n\
    \      echo \"Validation: Endpoint for service $service does not exist\"\n   \
    \ fi\n  fi\ndone\n\n# Output the health status\nif [ \"$health_status\" = \"Unhealthy\"\
    \ ]; then\n  echo \"Health Status: $health_status\"\n  echo \"=====================\"\
    \nelif [ \"$health_status\" = \"Healthy\" ]; then\n  echo \"Health Status: $health_status\"\
    \nfi\n\n# Output separator\necho \"------------\"\n```"
  name: find_owner_and_service_health_for_ingress_ingress_object_name
