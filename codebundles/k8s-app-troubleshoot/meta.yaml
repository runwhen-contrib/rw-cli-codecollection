commands:
- command: kubectl --context=${CONTEXT} -n ${NAMESPACE} logs $(kubectl --context=${CONTEXT}
    -n ${NAMESPACE} get deployment,statefulset -l ${LABELS} -oname | head -n 1) --tail=${MAX_LOG_LINES}
    --limit-bytes=256000 --since=${LOGS_SINCE} --container=${CONTAINER_NAME}
  doc_links: '

    - [Kubernetes - kubectl Overview](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands){:target="_blank"}

    - [Kubernetes container log documentation](https://kubernetes.io/docs/tasks/debug-application-cluster/get-shell-running-container/){:target="_blank"}

    - [Using the Newman log command](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#logs){:target="_blank"}'
  explanation: "\n\nThis command provides a way to get the logs from a specific container\
    \ within a deployment or statefulset in Kubernetes. The parameters at the end\
    \ such as --tail, --limit-bytes, --since and --container are used for filtering\
    \ the logs. \n\n--context defines which cluster you want to use so this command\
    \ can be used across different clusters.\n\n--n specifies the namespace of the\
    \ cluster.\n\n-l is used to specify labels associated with the deployment/statefulset\
    \ which will be used to filter further.\n\n-oname outputs only the names of the\
    \ resources in question (deployment/statefulset). In this case, the name of the\
    \ deployment/statefulset is taken using the head -n 1 command and and then used\
    \ in combination with the logs command to produce the log output.\n\n--tail is\
    \ to print the last few lines of logs. Number of lines are given by ${MAX_LOG_LINES}.\n\
    \n--limit-bytes limits the amount of bytes of log output produced. This is given\
    \ by ${256000} bytes.\n\n--since is used to return logs newer than a given time\
    \ duration from now. This is given by ${LOGS_SINCE}.\n\n--container is used to\
    \ limit log output to a particular container in the pod. This given by ${CONTAINER_NAME}."
  multi_line_details: "\n\n# First, we need to get the name of a Kubernetes resource\
    \ that matches our labels.\n# This command uses the '-l ${LABELS}' flag, combined\
    \ with the 'get' subcommand to \n# query Kubernetes for matching resources. Then,\
    \ 'oname' tells Kubernetes to just\n# return the name of the resource (instead\
    \ of all the resource's attributes). Lastly,\n# 'head -n 1' is used to select\
    \ the first matching resource returned.\nNAME=$(kubectl --context=${CONTEXT} \\\
    \n    -n ${NAMESPACE} \\\n    get deployment,statefulset \\ \n    -l ${LABELS}\
    \ \\\n    -oname \\\n    | head -n 1)\n\n# Now that we have the name of the related\
    \ Kubernetes resource, we can use the name \n# in the logs subcommand, which will\
    \ return the logs from the resource.\n#\n# The other flags are used to specify\
    \ when the logs should start from (--since), what container\n# the logs should\
    \ be from (--container), how many lines should be returned (--tail) and,\n# optionally,\
    \ how much data should be returned (--limit-bytes).\nkubectl --context=${CONTEXT}\
    \ \\\n    -n ${NAMESPACE} \\\n    logs ${NAME} \\\n    --tail=${MAX_LOG_LINES}\
    \ \\\n    --limit-bytes=256000 \\\n    --since=${LOGS_SINCE} \\\n    --container=${CONTAINER_NAME}"
  name: get_workload_logs
- command: ${cmd}
  doc_links: '

    - [UNIX.com''s tutorial on crontab](https://www.unix.com/man-page/osx/1/crontab/){:target="_blank"}

    - [Wikipedia article on Cron job scheduling](https://en.wikipedia.org/wiki/Cron){:target="_blank"}'
  explanation: '


    ${cmd} is a Kubernetes command that you can use to create a new deployment. A
    deployment describes how to deploy your application in the cluster, and it consists
    of several resources such as pods, services, and deployments. This command allows
    you to define what images should be used for the pod, which containers should
    be started up, and other settings needed to run your application in the Kubernetes
    cluster. It also allows you to manage the entire deployment process from creation
    to running the application. This ensures that you have a consistent way of deploying
    applications across different environments and can keep track of changes made
    to the system.'
  multi_line_details: "\n\n# Convert this one-line command into a multi-line command,\
    \ adding verbose comments to educate new users of Kubernetes and related cli commands\n\
    kubectl create --save-config secret my-secret \\  # Create a secret called \"\
    my-secret\"\n  generic \\                                        # Using type\
    \ \"generic\"\n  --from-literal=key1=value1 \\                     # Setting key\
    \ 'key1' to value 'value1'\n  --from-literal=key2=value2                     \
    \  # Setting key 'key2' to value 'value2'"
  name: troubleshoot_application_logs
- command: kubectl --context=${CONTEXT} -n ${NAMESPACE} exec $(kubectl --context=${CONTEXT}
    -n ${NAMESPACE} get all -l ${LABELS} -oname | grep -iE "deploy|stateful" | head
    -n 1) --container=${CONTAINER_NAME} -- printenv
  doc_links: '

    - [Kubectl Overview](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands){:target="_blank"}

    - [Contexts (kubectl) for multiple cluster and user management](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-current-context){:target="_blank"}

    - [Get Resources by Label Selector (kubectl)](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/){:target="_blank"}

    - [Exec Command (kubectl)](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#exec){:target="_blank"}

    - [Kubernetes Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/){:target="_blank"}

    - [Kubernetes StatefulSets](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/){:target="_blank"}'
  explanation: "\n\nThis command allows you to run a command inside an existing Kubernetes\
    \ container. It is using the kubectl command, which is a tool that helps manage\
    \ multiple aspects of your Kubernetes cluster (on the context specified). \n\n\
    The --context option is for identifying which namespace and cluster your command\
    \ will apply to. The -n flag also indicates a specific namespace you'd like to\
    \ target. Essentially these two flags let you configure what Kubernetes environment\
    \ this command will be running in. \n\nThe $(kubectl --context=${CONTEXT} -n ${NAMESPACE}\
    \ get all -l ${LABELS} -oname | grep -iE \"deploy|stateful\" ) part finds the\
    \ name of the resource that matches the specific labels provided in the command.\
    \ \n\nLastly, the command ends with --container=${CONTAINER_NAME} -- printenv.\
    \ This means that the previous command has determined which container you'd like\
    \ to run the command in (specified by CONTAINER_NAME) and will execute the command:\
    \ printenv. Printenv will display all of the environmental variables available\
    \ for the container."
  multi_line_details: '


    # This command uses kubectl to get environment variables for a particular container


    # Get the context and namespace from external sources:

    CONTEXT=${CONTEXT}

    NAMESPACE=${NAMESPACE}


    # Get the name of the deploy/stateful set by executing another kubectl command,
    which gets all resources with the label specified in the variable:

    LABELS=${LABELS}


    # Execute the previous command and store the result in a variable

    CONTAINER_NAME=$(kubectl --context=${CONTEXT} -n ${NAMESPACE} get all -l ${LABELS}
    -oname | grep -iE "deploy|stateful" | head -n 1)


    # Finally execute the requested command to get environment variables

    kubectl --context=${CONTEXT} -n ${NAMESPACE} exec ${CONTAINER_NAME} --container=${CONTAINER_NAME}
    -- printenv'
  name: troubleshoot_application_logs
- command: kubectl --context=${CONTEXT} -n ${NAMESPACE} exec $(kubectl --context=${CONTEXT}
    -n ${NAMESPACE} get all -l ${LABELS} -oname | grep -iE "deploy|stateful" | head
    -n 1) --container=${CONTAINER_NAME} -- ps -eo command --no-header | grep -v "ps
    -eo"
  doc_links: '

    - [Kubernetes context](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}

    - [Namespace in Kubernetes](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Labels in Kubernetes](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/){:target="_blank"}

    - [kubectl exec command](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#exec){:target="_blank"}

    - [ps command](https://linuxize.com/post/linux-ps-command/){:target="_blank"}'
  explanation: '


    This command enables you to view information about a particular Kubernetes deployment
    by using the Kubernetes Command Line Interface (kubectl). It allows you to execute
    a command inside of a running container in a Kubernetes cluster, providing context
    with the variables CONTEXT, NAMESPACE, LABELS, and CONTAINER_NAME. The command
    then performs a ps (process status) command to get detailed information on the
    particular deployment. It filters out the header row from the output for tidiness
    and/or filtering purposes.'
  multi_line_details: "\n\n# This command will fetch the Pod's name which matches\
    \ the labels value, and execute the container to run the ps (process status) command.\
    \ \n# The output from the process status command will be used to determine the\
    \ running processes in the container.\nCONTEXT=<context name> #Sets the Kubernetes\
    \ context\nNAMESPACE=<namespace name> #Name of the namespace to target\nLABELS=<label\
    \ name> #Name of label used for searching\nCONTAINER_NAME=<container name> #Name\
    \ of container \n\n# Gets all resources with the given label name\nRESOURCES=$(kubectl\
    \ --context=${CONTEXT} -n ${NAMESPACE} get all -l ${LABELS} -oname) \n\n# Filters\
    \ the result list to return only deployments and stateful sets\nDEPLOYMENTS_STATEFULSET=$(echo\
    \ ${RESOURCES} | grep -iE \"deploy|stateful\") \n\n# Retrieves the first Pod in\
    \ the result list\nFIRST_POD_NAME=$(echo ${DEPLOYMENTS_STATEFULSET} | head -n\
    \ 1) \n\n# Executes the container to retrieve the process status command output\n\
    kubectl --context=${CONTEXT} -n ${NAMESPACE} exec ${FIRST_POD_NAME} --container=${CONTAINER_NAME}\
    \ -- ps -eo command --no-header | grep -v \"ps -eo\""
  name: troubleshoot_application_logs
