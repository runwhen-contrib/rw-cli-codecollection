commands:
- command: kubectl --context=${CONTEXT} -n ${NAMESPACE} logs -l ${LABELS} --tail=${MAX_LOG_LINES}
    --limit-bytes=256000 --since=${LOGS_SINCE} --container=${CONTAINER_NAME}
  doc_links: '

    - [Kubernetes Documentation: Kubernetes Logs](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#logs){:target="_blank"}

    - [Kubernetes Documentation: Labels and Selectors](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/){:target="_blank"}

    - [Kubernetes Documentation: Contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#context){:target="_blank"}

    - [Kubernetes Documentation: Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubernetes Documentation: Logging and Monitoring](https://kubernetes.io/docs/concepts/cluster-administration/logging/){:target="_blank"}'
  explanation: This command retrieves the logs of a specific container within a Kubernetes
    pod, using the specified context, namespace, and labels, and limiting the output
    to a certain number of lines and bytes, as well as filtering based on a specified
    timestamp.
  multi_line_details: "# Set the Kubernetes context to the value of the CONTEXT variable\n\
    # and specify the namespace using the NAMESPACE variable\n# Then fetch logs for\
    \ pods with specified labels\n# Limit the number of log lines to MAX_LOG_LINES\n\
    # Limit the total size of logs to 256000 bytes\n# Filter logs since LOGS_SINCE\
    \ timestamp\n# Finally, specify the container name to fetch logs from\nkubectl\
    \ --context=${CONTEXT} \\\n    -n ${NAMESPACE} \\\n    logs -l ${LABELS} \\\n\
    \    --tail=${MAX_LOG_LINES} \\\n    --limit-bytes=256000 \\\n    --since=${LOGS_SINCE}\
    \ \\\n    --container=${CONTAINER_NAME}"
  name: get_workload_name_application_logs
- command: ${cmd}
  doc_links: '

    - [Linux command line documentation](https://linuxcommand.org/){:target="_blank"}

    - [Bash scripting tutorial](https://ryanstutorials.net/bash-scripting-tutorial/){:target="_blank"}'
  explanation: This command is a placeholder for a specific command that needs to
    be executed, but the actual command will depend on the context in which it's being
    used.
  multi_line_details: '# First, let''s store the current date and time in a variable

    current_date=$(date +"%Y-%m-%d %H:%M:%S")


    # Now, let''s echo the current date and time to the terminal

    echo "The current date and time is: $current_date"


    # Finally, let''s write the current date and time to a file called datetime.txt

    echo "$current_date" > datetime.txt'
  name: troubleshoot_workload_name_application_logs
- command: kubectl --context=${CONTEXT} -n ${NAMESPACE} exec $(kubectl --context=${CONTEXT}
    -n ${NAMESPACE} get all -l ${LABELS} -oname | grep -iE "deploy|stateful" | head
    -n 1) --container=${CONTAINER_NAME} -- printenv
  doc_links: '

    - [Kubernetes Contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}

    - [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubernetes Labels and Selectors](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/){:target="_blank"}'
  explanation: This command allows you to execute a shell command in a specific container
    within a Kubernetes cluster, using the specified context and namespace, and targeting
    a resource based on certain labels.
  multi_line_details: '# Set the context and namespace for kubectl

    CONTEXT=my-context

    NAMESPACE=my-namespace


    # Get the name of the first deployment or statefulset with the specified labels

    POD_NAME=$(kubectl --context=${CONTEXT} -n ${NAMESPACE} get all -l ${LABELS} -oname
    | grep -iE "deploy|stateful" | head -n 1)


    # Execute the command inside the specified container in the selected pod

    CONTAINER_NAME=my-container

    kubectl --context=${CONTEXT} -n ${NAMESPACE} exec ${POD_NAME} --container=${CONTAINER_NAME}
    -- printenv'
  name: troubleshoot_workload_name_application_logs
- command: kubectl --context=${CONTEXT} -n ${NAMESPACE} exec $(kubectl --context=${CONTEXT}
    -n ${NAMESPACE} get all -l ${LABELS} -oname | grep -iE "deploy|stateful" | head
    -n 1) --container=${CONTAINER_NAME} -- ps -eo command --no-header | grep -v "ps
    -eo"
  doc_links: '

    - [Kubectl Command Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Kubectl Overview](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [Kubectl Selectors](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/){:target="_blank"}

    - [Kubectl Advanced Pod Usage](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#run){:target="_blank"}'
  explanation: This command uses kubectl to execute a command in a specific deployment
    or stateful set within a given namespace and context. It retrieves the pods based
    on specified labels, selects the first result, and runs a specific container's
    process command while filtering out any non-relevant results.
  multi_line_details: '# Set the kubectl context to the specified context

    kubectl --context=${CONTEXT} \


    # Set the namespace to the specified namespace

    -n ${NAMESPACE} exec \


    # Get the resource name of the first deployment or stateful set with the specified
    labels

    $(kubectl --context=${CONTEXT} -n ${NAMESPACE} get all -l ${LABELS} -oname | grep
    -iE "deploy|stateful" | head -n 1) \


    # Specify the container name for the execution

    --container=${CONTAINER_NAME} -- \


    # Execute the command to retrieve the list of running processes in the specified
    container and filter out the ps command itself

    ps -eo command --no-header | grep -v "ps -eo"'
  name: troubleshoot_workload_name_application_logs
