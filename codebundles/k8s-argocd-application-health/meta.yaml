commands:
- command: 'kubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT} -o jsonpath=''Application Name: {.metadata.name}, Sync Status:
    {.status.sync.status}, Health Status: {.status.health.status}, Message: {.status.conditions[].message}'''
  doc_links: '

    - [ArgoCD Documentation](https://argoproj.github.io/argo-cd/){:target="_blank"}

    - [JSONPath Syntax](https://goessner.net/articles/JsonPath/){:target="_blank"}

    - [Kubernetes Contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}

    - [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}'
  explanation: This command retrieves information about a specific application managed
    by ArgoCD, including its name, synchronization status, health status, and any
    associated messages, using the specified context and namespace. The output will
    be formatted in JSONPath format.
  multi_line_details: '# Set the variables for the application, app namespace, and
    context

    APPLICATION="your-application-name"

    APPLICATION_APP_NAMESPACE="your-app-namespace"

    CONTEXT="your-cluster-context"


    # Use kubectl to get the application information using ArgoCD

    # We use the -o jsonpath flag to output specific fields in a custom format

    kubectl get applications.argoproj.io $APPLICATION -n $APPLICATION_APP_NAMESPACE
    --context $CONTEXT -o jsonpath=''Application Name: {.metadata.name}, Sync Status:
    {.status.sync.status}, Health Status: {.status.health.status}, Message: {.status.conditions[].message}'''
  name: fetch_argocd_application_sync_status_health
- command: 'kubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT} -o json | jq -r ''"Application Name: " + .metadata.name +
    "\nApplication Namespace: "+ .metadata.namespace + "\nLast Sync Start Time: "
    + .status.operationState.finishedAt + "\nLast Sync Finish Time: " + .status.operationState.startedAt
    + "\nLast Sync Status: " + .status.operationState.phase + "\nLast Sync Message:
    " + .status.operationState.message'''
  doc_links: '

    - [Kubernetes Documentation - kubectl get](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [Kubernetes Documentation - Pods](https://kubernetes.io/docs/concepts/workloads/pods/){:target="_blank"}

    - [Kubernetes Documentation - Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubernetes Documentation - Application Controllers](https://kubernetes.io/docs/concepts/architecture/controller/){:target="_blank"}'
  explanation: This command retrieves information about a specific application in
    a Kubernetes cluster, like its name, namespace, and the last time it was synchronized,
    along with its status and any associated messages.
  multi_line_details: "```\n# The following command retrieves information about a\
    \ specific application using the kubectl command and jq for JSON parsing.\n\n\
    kubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}\
    \ --context ${CONTEXT} -o json \\\n  | jq -r '\"Application Name: \" + .metadata.name\
    \ + \"\\nApplication Namespace: \"+ .metadata.namespace + \\\n  \"\\nLast Sync\
    \ Start Time: \" + .status.operationState.finishedAt + \\\n  \"\\nLast Sync Finish\
    \ Time: \" + .status.operationState.startedAt + \\\n  \"\\nLast Sync Status: \"\
    \ + .status.operationState.phase + \\\n  \"\\nLast Sync Message: \" + .status.operationState.message'\n\
    ```"
  name: fetch_argocd_application_last_sync_operation_details
- command: kubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT} -o json | jq -r '[.status.resources[] | select(.health.status
    != null) | select(.health.status != "Healthy") | {name,kind,namespace,health}]'
  doc_links: '

    '
  explanation: This command retrieves the status of a specific application using Argo
    Project, filters for resources with non-healthy status, and outputs the results
    in JSON format.
  multi_line_details: "# Here we are using kubectl to get the applications from the\
    \ ArgoCD API server\n# We are passing the name of the application and its namespace\
    \ as input variables\n# The context is also specified for the Kubernetes cluster\n\
    kubectl get applications.argoproj.io ${APPLICATION} \\\n    -n ${APPLICATION_APP_NAMESPACE}\
    \ \\\n    --context ${CONTEXT} \\\n    -o json | \\\n    # After getting the applications\
    \ in JSON format, we are using jq to filter out the resources which do not have\
    \ a healthy status \n    jq -r '[.status.resources[] | select(.health.status !=\
    \ null) | select(.health.status != \"Healthy\") | {name,kind,namespace,health}]'"
  name: fetch_unhealthy_argocd_application_resources
- command: 'for deployment_name in $(kubectl get deployments -l argocd.argoproj.io/instance=${APPLICATION_TARGET_NAMESPACE}_${APPLICATION}
    -o=custom-columns=NAME:.metadata.name --no-headers -n ${APPLICATION_TARGET_NAMESPACE});
    do echo "\nDEPLOYMENT NAME: $deployment_name \n" && kubectl logs deployment/$deployment_name
    --tail=50 -n ${APPLICATION_TARGET_NAMESPACE} | grep -E ''${ERROR_PATTERN}''; done'
  doc_links: '

    - [Kubectl Command Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Understanding Kubernetes Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/){:target="_blank"}'
  explanation: This command retrieves the names of deployments associated with a specific
    instance and application, then prints out the deployment name and 50 lines of
    logs for each deployment that contain a specified error pattern.
  multi_line_details: "# Get the deployment names matching a specific label selector\
    \ using kubectl command\n# and iterating through each deployment name\n\nfor deployment_name\
    \ in $(kubectl get deployments -l argocd.argoproj.io/instance=${APPLICATION_TARGET_NAMESPACE}_${APPLICATION}\
    \ -o=custom-columns=NAME:.metadata.name --no-headers -n ${APPLICATION_TARGET_NAMESPACE});\
    \ do \n    # Print the deployment name for visibility\n    echo \"\\nDEPLOYMENT\
    \ NAME: $deployment_name \\n\" \n    # Use kubectl logs to fetch the logs of the\
    \ current deployment and filter only the last 50 lines\n    # Then grep for the\
    \ specified error pattern\n    kubectl logs deployment/$deployment_name --tail=50\
    \ -n ${APPLICATION_TARGET_NAMESPACE} | grep -E '${ERROR_PATTERN}';\ndone"
  name: scan_for_errors_in_pod_logs_related_to_argocd_application_deployments
- command: kubectl describe applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT}
  doc_links: '

    - [Kubernetes Namespace Documentation](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubectl Contexts Documentation](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}'
  explanation: This command is used to provide detailed information about an Argo
    project application, including its configuration and status, within a specific
    namespace and context. It's a way to inspect the details of an Argo project application
    from the command line.
  multi_line_details: "# Store the application name in a variable for readability\
    \ \nAPPLICATION_NAME=${APPLICATION}\n\n# Store the namespace of the application\
    \ in a variable for readability \nAPP_NAMESPACE=${APPLICATION_APP_NAMESPACE}\n\
    \n# Store the kubernetes context in a variable for readability \nKUBE_CONTEXT=${CONTEXT}\n\
    \n# Use kubectl to describe the Argo CD application with the specified name, namespace,\
    \ and context\nkubectl describe applications.argoproj.io ${APPLICATION_NAME} -n\
    \ ${APP_NAMESPACE} --context ${KUBE_CONTEXT}"
  name: fully_describe_argocd_application
