commands:
- command: 'kubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT} -o jsonpath=''Application Name: {.metadata.name}, Sync Status:
    {.status.sync.status}, Health Status: {.status.health.status}, Message: {.status.conditions[].message}'''
  doc_links: '

    - [ArgoCD Documentation](https://argoproj.github.io/argo-cd/){:target="_blank"}

    - [JSONPath Syntax](https://goessner.net/articles/JsonPath/){:target="_blank"}

    - [Kubernetes Contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}

    - [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}'
  explanation: This command retrieves information about a specific application managed
    by ArgoCD, including its name, synchronization status, health status, and any
    associated messages, using the specified context and namespace. The output will
    be formatted in JSONPath format.
  multi_line_details: "# First, we use the kubectl command to retrieve information\
    \ about an Argo CD application\nkubectl get applications.argoproj.io ${APPLICATION}\
    \ \n# We specify the namespace in which the application resides using the -n flag\n\
    -n ${APPLICATION_APP_NAMESPACE} \n# Next, we specify the context under which the\
    \ operation should be performed using the --context flag\n--context ${CONTEXT}\
    \ \n# Finally, we use the -o jsonpath flag to format the output with specific\
    \ fields such as Application Name, Sync Status, Health Status, and Message\n-o\
    \ jsonpath='Application Name: {.metadata.name}, Sync Status: {.status.sync.status},\
    \ Health Status: {.status.health.status}, Message: {.status.conditions[].message}'"
  name: fetch_argocd_application_sync_status_health
- command: 'kubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT} -o json | jq -r ''"Application Name: " + .metadata.name +
    "\nApplication Namespace: "+ .metadata.namespace + "\nLast Sync Start Time: "
    + .status.operationState.finishedAt + "\nLast Sync Finish Time: " + .status.operationState.startedAt
    + "\nLast Sync Status: " + .status.operationState.phase + "\nLast Sync Message:
    " + .status.operationState.message'''
  doc_links: '

    - [Kubernetes Documentation - kubectl get](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [Kubernetes Documentation - Pods](https://kubernetes.io/docs/concepts/workloads/pods/){:target="_blank"}

    - [Kubernetes Documentation - Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubernetes Documentation - Application Controllers](https://kubernetes.io/docs/concepts/architecture/controller/){:target="_blank"}'
  explanation: This command retrieves information about a specific application in
    a Kubernetes cluster, like its name, namespace, and the last time it was synchronized,
    along with its status and any associated messages.
  multi_line_details: "```bash\n# Set the variable for the application name\nAPPLICATION=example-app\n\
    \n# Set the variable for the application's namespace\nAPPLICATION_APP_NAMESPACE=example-namespace\n\
    \n# Set the variable for the context in which the application resides\nCONTEXT=my-kube-context\n\
    \n# Use kubectl to get the application details from ArgoCD in JSON format\nkubectl\
    \ get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}\
    \ --context ${CONTEXT} -o json \n\n# Pipe the output of the previous command to\
    \ jq to format the output\n| jq -r '\"Application Name: \" + .metadata.name +\
    \ \"\\nApplication Namespace: \"+ .metadata.namespace + \"\\nLast Sync Start Time:\
    \ \" + .status.operationState.finishedAt + \"\\nLast Sync Finish Time: \" + .status.operationState.startedAt\
    \ + \"\\nLast Sync Status: \" + .status.operationState.phase + \"\\nLast Sync\
    \ Message: \" + .status.operationState.message'\n```"
  name: fetch_argocd_application_last_sync_operation_details
- command: kubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT} -o json | jq -r '[.status.resources[] | select(.health.status
    != null) | select(.health.status != "Healthy") | {name,kind,namespace,health}]'
  doc_links: '

    '
  explanation: This command retrieves the status of a specific application using Argo
    Project, filters for resources with non-healthy status, and outputs the results
    in JSON format.
  multi_line_details: "```\n# First, retrieve the application details using kubectl\
    \ and jq commands\nkubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}\
    \ --context ${CONTEXT} -o json | \\\n  # Then, use jq to filter out only the resources\
    \ that have a non-healthy status\n  jq -r '[.status.resources[] | select(.health.status\
    \ != null) | select(.health.status != \"Healthy\") | {name,kind,namespace,health}]'\n\
    ```"
  name: fetch_unhealthy_argocd_application_resources
- command: 'for deployment_name in $(kubectl get deployments -l argocd.argoproj.io/instance=${APPLICATION_TARGET_NAMESPACE}_${APPLICATION}
    -o=custom-columns=NAME:.metadata.name --no-headers -n ${APPLICATION_TARGET_NAMESPACE});
    do echo "\nDEPLOYMENT NAME: $deployment_name \n" && kubectl logs deployment/$deployment_name
    --tail=50 -n ${APPLICATION_TARGET_NAMESPACE} | grep -E ''${ERROR_PATTERN}''; done'
  doc_links: '

    - [Kubectl Command Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Understanding Kubernetes Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/){:target="_blank"}'
  explanation: This command retrieves the names of deployments associated with a specific
    instance and application, then prints out the deployment name and 50 lines of
    logs for each deployment that contain a specified error pattern.
  multi_line_details: "```bash\n# Get the list of deployment names for a specific\
    \ application target namespace and application using the kubectl command\nfor\
    \ deployment_name in $(kubectl get deployments -l argocd.argoproj.io/instance=${APPLICATION_TARGET_NAMESPACE}_${APPLICATION}\
    \ -o=custom-columns=NAME:.metadata.name --no-headers -n ${APPLICATION_TARGET_NAMESPACE});\
    \ do\n    # Print the name of the deployment\n    echo \"\\nDEPLOYMENT NAME: $deployment_name\
    \ \\n\" \n    # Retrieve the logs for the specified deployment and filter them\
    \ for any errors using the kubectl command\n    kubectl logs deployment/$deployment_name\
    \ --tail=50 -n ${APPLICATION_TARGET_NAMESPACE} | grep -E '${ERROR_PATTERN}'\n\
    done\n```"
  name: scan_for_errors_in_pod_logs_related_to_argocd_application_deployments
- command: kubectl describe applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT}
  doc_links: '

    - [Kubernetes Namespace Documentation](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubectl Contexts Documentation](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}'
  explanation: This command is used to provide detailed information about an Argo
    project application, including its configuration and status, within a specific
    namespace and context. It's a way to inspect the details of an Argo project application
    from the command line.
  multi_line_details: '```bash

    # Set the context to the desired Kubernetes cluster

    kubectl config use-context ${CONTEXT}


    # Describe the Argo CD application using the specified name and namespace

    kubectl describe applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}

    ```'
  name: fully_describe_argocd_application
