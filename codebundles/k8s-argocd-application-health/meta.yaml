commands:
- command: 'kubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT} -o jsonpath=''Application Name: {.metadata.name}, Sync Status:
    {.status.sync.status}, Health Status: {.status.health.status}, Message: {.status.conditions[].message}'''
  doc_links: '

    - [ArgoCD Documentation](https://argoproj.github.io/argo-cd/){:target="_blank"}

    - [JSONPath Syntax](https://goessner.net/articles/JsonPath/){:target="_blank"}

    - [Kubernetes Contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}

    - [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}'
  explanation: This command retrieves information about a specific application managed
    by ArgoCD, including its name, synchronization status, health status, and any
    associated messages, using the specified context and namespace. The output will
    be formatted in JSONPath format.
  multi_line_details: '#!/bin/bash

    # This script gets information about a specific Argo CD application using kubectl


    # Set the application name

    APPLICATION="example-application"


    # Set the application namespace

    APPLICATION_APP_NAMESPACE="example-namespace"


    # Set the context for the Kubernetes cluster

    CONTEXT="example-context"


    # Use kubectl to get information about the specified Argo CD application

    kubectl get applications.argoproj.io ${APPLICATION} \

    -n ${APPLICATION_APP_NAMESPACE} \

    --context ${CONTEXT} \

    -o jsonpath=''Application Name: {.metadata.name}, Sync Status: {.status.sync.status},
    Health Status: {.status.health.status}, Message: {.status.conditions[].message}'''
  name: fetch_argocd_application_sync_status_health
- command: 'kubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT} -o json | jq -r ''"Application Name: " + .metadata.name +
    "\nApplication Namespace: "+ .metadata.namespace + "\nLast Sync Start Time: "
    + .status.operationState.finishedAt + "\nLast Sync Finish Time: " + .status.operationState.startedAt
    + "\nLast Sync Status: " + .status.operationState.phase + "\nLast Sync Message:
    " + .status.operationState.message'''
  doc_links: '

    - [Kubernetes Documentation - kubectl get](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [Kubernetes Documentation - Pods](https://kubernetes.io/docs/concepts/workloads/pods/){:target="_blank"}

    - [Kubernetes Documentation - Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubernetes Documentation - Application Controllers](https://kubernetes.io/docs/concepts/architecture/controller/){:target="_blank"}'
  explanation: This command retrieves information about a specific application in
    a Kubernetes cluster, like its name, namespace, and the last time it was synchronized,
    along with its status and any associated messages.
  multi_line_details: '#!/bin/bash

    # Get application details using kubectl command and jq for json parsing

    # Uses the input variables APPLICATION, APPLICATION_APP_NAMESPACE, CONTEXT


    kubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT} -o json | \

    jq -r ''"Application Name: " + .metadata.name + "\nApplication Namespace: "+ .metadata.namespace
    + \

    "\nLast Sync Start Time: " + .status.operationState.finishedAt + "\nLast Sync
    Finish Time: " + .status.operationState.startedAt + \

    "\nLast Sync Status: " + .status.operationState.phase + "\nLast Sync Message:
    " + .status.operationState.message'''
  name: fetch_argocd_application_last_sync_operation_details
- command: kubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT} -o json | jq -r '[.status.resources[] | select(.health.status
    != null) | select(.health.status != "Healthy") | {name,kind,namespace,health}]'
  doc_links: '

    '
  explanation: This command retrieves the status of a specific application using Argo
    Project, filters for resources with non-healthy status, and outputs the results
    in JSON format.
  multi_line_details: "#!/bin/bash\n\n# This command retrieves the specified application\
    \ in a specific namespace from the provided context and outputs the result in\
    \ JSON format. \n# It then filters the output using jq to only include resources\
    \ with non-healthy health status, and selects specific fields for the output.\n\
    \nkubectl get applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}\
    \ --context ${CONTEXT} -o json | \n  jq -r '[.status.resources[] | \n    select(.health.status\
    \ != null) | \n    select(.health.status != \"Healthy\") | \n    {name,kind,namespace,health}]'"
  name: fetch_unhealthy_argocd_application_resources
- command: 'for deployment_name in $(kubectl get deployments -l argocd.argoproj.io/instance=${APPLICATION_TARGET_NAMESPACE}_${APPLICATION}
    -o=custom-columns=NAME:.metadata.name --no-headers -n ${APPLICATION_TARGET_NAMESPACE});
    do echo "\nDEPLOYMENT NAME: $deployment_name \n" && kubectl logs deployment/$deployment_name
    --tail=50 -n ${APPLICATION_TARGET_NAMESPACE} | grep -E ''${ERROR_PATTERN}''; done'
  doc_links: '

    - [Kubectl Command Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Understanding Kubernetes Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/){:target="_blank"}'
  explanation: This command retrieves the names of deployments associated with a specific
    instance and application, then prints out the deployment name and 50 lines of
    logs for each deployment that contain a specified error pattern.
  multi_line_details: "#!/bin/bash\n# Loop through deployments using 'kubectl get'\
    \ command\n# Search for specific deployment name using labels\n# Retrieve deployment\
    \ name and store it in 'deployment_name'\nfor deployment_name in $(kubectl get\
    \ deployments -l argocd.argoproj.io/instance=${APPLICATION_TARGET_NAMESPACE}_${APPLICATION}\
    \ -o=custom-columns=NAME:.metadata.name --no-headers -n ${APPLICATION_TARGET_NAMESPACE});\
    \ \ndo \n  # Print deployment name\n  echo \"\\nDEPLOYMENT NAME: $deployment_name\
    \ \\n\" \n  # Print logs for the deployment with tail 50\n  # Use grep to filter\
    \ logs containing the ERROR_PATTERN\n  kubectl logs deployment/$deployment_name\
    \ --tail=50 -n ${APPLICATION_TARGET_NAMESPACE} | grep -E '${ERROR_PATTERN}'\n\
    done"
  name: scan_for_errors_in_pod_logs_related_to_argocd_application_deployments
- command: kubectl describe applications.argoproj.io ${APPLICATION} -n ${APPLICATION_APP_NAMESPACE}
    --context ${CONTEXT}
  doc_links: '

    - [Kubernetes Namespace Documentation](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubectl Contexts Documentation](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}'
  explanation: This command is used to provide detailed information about an Argo
    project application, including its configuration and status, within a specific
    namespace and context. It's a way to inspect the details of an Argo project application
    from the command line.
  multi_line_details: "#!/bin/bash\n\n# This script describes the details of an application\
    \ using kubectl\n# The details include application metadata, status, and other\
    \ information\n# Set the variables for the application name, namespace, and context\n\
    APPLICATION=\"example-app\"\nAPPLICATION_APP_NAMESPACE=\"example-namespace\"\n\
    CONTEXT=\"example-context\"\n\n# Use kubectl to describe the application in a\
    \ specific namespace and context\nkubectl describe applications.argoproj.io ${APPLICATION}\
    \ \\\n  -n ${APPLICATION_APP_NAMESPACE} --context ${CONTEXT}"
  name: fully_describe_argocd_application
