commands:
- command: 'kubectl get events --context ${CONTEXT} -n ${NAMESPACE} -o json | jq ''(now
    - (60*60)) as $time_limit | [ .items[] | select(.type == "Warning" and (.involvedObject.kind
    == "Deployment" or .involvedObject.kind == "ReplicaSet" or .involvedObject.kind
    == "Pod") and (.involvedObject.name | tostring | contains("${DEPLOYMENT_NAME}"))
    and (.lastTimestamp | fromdateiso8601) >= $time_limit) | {kind: .involvedObject.kind,
    name: .involvedObject.name, reason: .reason, message: .message, firstTimestamp:
    .firstTimestamp, lastTimestamp: .lastTimestamp} ] | group_by([.kind, .name]) |
    map({kind: .[0].kind, name: .[0].name, count: length, reasons: map(.reason) |
    unique, messages: map(.message) | unique, firstTimestamp: map(.firstTimestamp
    | fromdateiso8601) | sort | .[0] | todateiso8601, lastTimestamp: map(.lastTimestamp
    | fromdateiso8601) | sort | reverse | .[0] | todateiso8601})'''
  doc_links: '

    - [Kubectl get events command - official docs](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get-events){:target="_blank"}

    - [Kubectl context command - official docs](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#context){:target="_blank"}

    - [Kubernetes namespaces - official docs](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Using jq command utility to parse JSON - official docs](https://stedolan.github.io/jq/tutorial/){:target="_blank"}'
  explanation: '


    This command will list all the events within a Kubernetes cluster in json format.
    It filters for only warnings, deployments, replicasets, and pods with the specified
    deployment name that have occurred within the last hour. The output includes the
    kind of event, the name of the object that was affected by the event, the reason
    for the event, any messages associated with the event, and the first and last
    time stamp of the event.'
  multi_line_details: "\n\n# This command gets events from a Kubernetes cluster, filtered\
    \ to get only Warnings from Deployment, ReplicaSet or Pod which contain the specified\
    \ DEPLOYMENT_NAME. It is then grouped by kind and name and mapped in to shorten\
    \ form with additional fields\n\nkubectl get events \\  # Get events from the\
    \ Kubernetes cluster \n    --context ${CONTEXT} \\  # Specify the context of the\
    \ kubernetes cluster\n    -n ${NAMESPACE} \\  # The namespace from which to get\
    \ events from\n    -o json | \\  # Output the result in json format\n    jq '(now\
    \ - (60*60)) as $time_limit | \\  # Define time limit for the events i.e. last\
    \ one hour\n        [ .items[] | \\  # Get all items from the response\n     \
    \       select(.type == \"Warning\" and \\  # Filter for Warning type of events\n\
    \            (.involvedObject.kind == \"Deployment\" \\  # Filter for Events related\
    \ to Deployment objects\n            or .involvedObject.kind == \"ReplicaSet\"\
    \ \\  # Filter for Events related to ReplicaSet objects\n            or .involvedObject.kind\
    \ == \"Pod\") \\  # Filter for Events related to Pod objects\n            and\
    \ (.involvedObject.name | tostring | contains(\"${DEPLOYMENT_NAME}\")) \\  # Filter\
    \ on name of the deployment\n            and (.lastTimestamp | fromdateiso8601)\
    \ >= $time_limit) \\  # Filter on timestamp of the events\n        | {kind: .involvedObject.kind,\
    \ name: .involvedObject.name, reason: .reason, message: .message,  # Map events\
    \ into simplified form with additional fields\n            firstTimestamp: .firstTimestamp,\
    \ lastTimestamp: .lastTimestamp} ] \\\n        | group_by([.kind, .name]) \\ \
    \ # Group the events based on kind and name\n        | map({kind: .[0].kind, name:\
    \ .[0].name, count: length, \\  # Further map the data to list counts, reasons\
    \ and messages\n            reasons: map(.reason) | unique, messages: map(.message)\
    \ | unique, \n            firstTimestamp: map(.firstTimestamp | fromdateiso8601)\
    \ | sort | .[0] | todateiso8601, \\\n            lastTimestamp: map(.lastTimestamp\
    \ | fromdateiso8601) | sort | reverse | .[0] | todateiso8601})'"
  name: troubleshoot_deployment_warning_events_for_deployment_name_
- command: kubectl get deployment/${DEPLOYMENT_NAME} --context ${CONTEXT} -n ${NAMESPACE}
    -o yaml
  doc_links: '

    - [Kubernetes documentation on kubectl](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands){:target="_blank"}

    - [Official Kubernetes kubectl get deployment documentation](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get-deployment){:target="_blank"}

    - [Kubernetes documentation on namespace](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubernetes documentation on output format](https://kubernetes.io/docs/reference/using-api/api-overview/#application-programming-interface-command-line-interface){:target="_blank"}'
  explanation: '


    This command tells Kubernetes to get information about a particular deployment
    that has been specified by the name (${DEPLOYMENT_NAME}). The context (${CONTEXT})
    and namespace (${NAMESPACE}) provide Kubernetes with more information as to where
    exactly this deployment lives. Finally, you are asking Kubernetes to output the
    results in the yaml format.'
  multi_line_details: "\n\n#This line of code will retrieve the deployment configuration\
    \ info from Kubernetes corresponding to a given deployment name, context, and\
    \ namespace in a yaml format\n\nkubectl \\\n    #This is the kubernetes command\
    \ line interface command\n    get \\\n    #Use the 'get' subcommand to retrieve\
    \ information/objects\n    deployment/${DEPLOYMENT_NAME} \\\n    #In this case,\
    \ we're specifically looking for Deployments with the given deployment name\n\
    \    --context ${CONTEXT} \\\n    #Optionally specify a 'context' - an isolated\
    \ cluster role for the operation. We set this variable separately, as it's value\
    \ may differ between users/environments.\n    -n ${NAMESPACE} \\\n    #Specify\
    \ a 'namespace' - the environment where all objects of type K8s live. This variable\
    \ should be set separately, as it's value can change between users/environments.\n\
    \    -o yaml\\\n    #The output format will be in yaml, as specified by the '-o\
    \ yaml' option."
  name: get_deployment_workload_details_for_deployment_name_and_add_to_report
- command: 'kubectl get deployment/${DEPLOYMENT_NAME} --context ${CONTEXT} -n ${NAMESPACE}
    -o json | jq ''.status | {desired_replicas: .replicas, ready_replicas: (.readyReplicas
    // 0), missing_replicas: ((.replicas // 0) - (.readyReplicas // 0)), unavailable_replicas:
    (.unavailableReplicas // 0), available_condition: (if any(.conditions[]; .type
    == "Available") then (.conditions[] | select(.type == "Available")) else "Condition
    not available" end), progressing_condition: (if any(.conditions[]; .type == "Progressing")
    then (.conditions[] | select(.type == "Progressing")) else "Condition not available"
    end)}'''
  doc_links: '

    - [Kubectl Commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands){:target="_blank"}

    - [Kubectl Contexts](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-current-context){:target="_blank"}

    - [Using JSON Path in JQ](https://stedolan.github.io/jq/manual/#Basicfilters%20and%20paths){:target="_blank"}

    - [JQ Functions](https://stedolan.github.io/jq/manual/#Basicoperatorsandcomparisons){:target="_blank"}'
  explanation: '


    This command is retrieving the status of a Kubernetes deployment. A deployment
    defines how a particular pod or set of pods should be deployed and managed by
    Kubernetes. It will retrieve the desired number of replicas (defined replicas)
    for that deployment, the ready replicas (number of replicas already created and
    working), the missing replicas (replicas defined but not yet created) and the
    unavailable replicas (number of replicas that vice versa are working but not defined).
    In addition, it will provide two conditions, available and progressing, to check
    their related statuses. This command will allow you to see if the deployment is
    up and running with all the given data.'
  multi_line_details: "\n\n# Get deployment specified by the ${DEPLOYMENT_NAME} variable\
    \ and associated context, namespace. Output in json format\nkubectl get deployment/${DEPLOYMENT_NAME}\
    \ \\ \n    --context ${CONTEXT} \\\n    -n ${NAMESPACE} \\\n    -o json \n\n#\
    \ Run jq command to specify desired replicas, ready replicas, missing replicas,\
    \ unavailable replicas, available condition, and progressing condition\n| jq '.status\
    \ | {desired_replicas: .replicas, ready_replicas: (.readyReplicas // 0), missing_replicas:\
    \ ((.replicas // 0) - (.readyReplicas // 0)), unavailable_replicas: (.unavailableReplicas\
    \ // 0), available_condition: (if any(.conditions[]; .type == \"Available\") then\
    \ (.conditions[] | select(.type == \"Available\")) else \"Condition not available\"\
    \ end), progressing_condition: (if any(.conditions[]; .type == \"Progressing\"\
    ) then (.conditions[] | select(.type == \"Progressing\")) else \"Condition not\
    \ available\" end)}'"
  name: troubleshoot_deployment_replicas_for_deployment_name_
- command: 'kubectl get events --context ${CONTEXT} -n ${NAMESPACE} -o json | jq ''(now
    - (60*60)) as $time_limit | [ .items[] | select(.type != "Warning" and (.involvedObject.kind
    == "Deployment" or .involvedObject.kind == "ReplicaSet" or .involvedObject.kind
    == "Pod") and (.involvedObject.name | tostring | contains("${DEPLOYMENT_NAME}")))
    | {kind: .involvedObject.kind, count: .count, name: .involvedObject.name, reason:
    .reason, message: .message, firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp,
    duration: (if (((.lastTimestamp | fromdateiso8601) - (.firstTimestamp | fromdateiso8601))
    == 0) then 1 else (((.lastTimestamp | fromdateiso8601) - (.firstTimestamp | fromdateiso8601))/60)
    end) } ] | group_by([.kind, .name]) | map({kind: .[0].kind, name: .[0].name, count:
    (map(.count) | add), reasons: map(.reason) | unique, messages: map(.message) |
    unique, average_events_per_minute: (if .[0].duration == 1 then 1 else ((map(.count)
    | add)/.[0].duration ) end),firstTimestamp: map(.firstTimestamp | fromdateiso8601)
    | sort | .[0] | todateiso8601, lastTimestamp: map(.lastTimestamp | fromdateiso8601)
    | sort | reverse | .[0] | todateiso8601})'''
  doc_links: '

    - [Kubernetes Documentation - kubectl](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands){:target="_blank"}

    - [jq Manual](https://stedolan.github.io/jq/){:target="_blank"}'
  explanation: '


    This command allows the user to get events from Kubernetes based on a specified
    context, namespace, and deployment name. It takes the output from kubectl and
    adds additional contextual information like the count, messages, first and last
    timestamp of the event, and the average number of events per minute. This makes
    it easier to see what type of events happened related to the given context, namespace,
    and deployment name, and how long each of those events took to complete.'
  multi_line_details: "\n\n# This is a Kubernetes command to get events from the context\
    \ of the given namespace filtered by specific deployment name and convert it into\
    \ a JSON fromat.\n# This command can be broken down into multiple lines for better\
    \ readability.\n\n# Set the CONTEXT, NAMESPACE, DEPLOYMENT_NAME environment variables\
    \ in the current shell\nCONTEXT=\"<insert context>\"\nNAMESPACE=\"<insert namespace>\"\
    \nDEPLOYMENT_NAME=\"<insert deployment>\"\n\n# Get events using the kubectl command\
    \ with json formatting\nkubectl get events \\\n    --context ${CONTEXT} \\\n \
    \   -n ${NAMESPACE} \\ \n    -o json \\\n\n# Pipe the output to jq for additional\
    \ filtering.\n| jq '(now - (60*60)) as $time_limit | [ .items[] | select(.type\
    \ != \"Warning\" and (.involvedObject.kind == \"Deployment\" or .involvedObject.kind\
    \ == \"ReplicaSet\" or .involvedObject.kind == \"Pod\") and (.involvedObject.name\
    \ | tostring | contains(\"${DEPLOYMENT_NAME}\"))) | {kind: .involvedObject.kind,\
    \ count: .count, name: .involvedObject.name, reason: .reason, message: .message,\
    \ firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp, duration: (if\
    \ (((.lastTimestamp | fromdateiso8601) - (.firstTimestamp | fromdateiso8601))\
    \ == 0) then 1 else (((.lastTimestamp | fromdateiso8601) - (.firstTimestamp |\
    \ fromdateiso8601))/60) end) } ] | group_by([.kind, .name]) | map({kind: .[0].kind,\
    \ name: .[0].name, count: (map(.count) | add), reasons: map(.reason) | unique,\
    \ messages: map(.message) | unique, average_events_per_minute: (if .[0].duration\
    \ == 1 then 1 else ((map(.count) | add)/.[0].duration ) end),firstTimestamp: map(.firstTimestamp\
    \ | fromdateiso8601) | sort | .[0] | todateiso8601, lastTimestamp: map(.lastTimestamp\
    \ | fromdateiso8601) | sort | reverse | .[0] | todateiso8601})'"
  name: check_deployment_event_anomalies_for_deployment_name_
