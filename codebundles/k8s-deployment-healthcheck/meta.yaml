commands:
- command: bash 'validate_probes.sh' livenessProbe
  doc_links: '

    - [Kubernetes Documentation Homepage](https://kubernetes.io/docs/){:target="_blank"}

    - [Overview of Containers, Pods, and Services](https://kubernetes.io/docs/concepts/workloads/pods/pod/){:target="_blank"}

    - [Using Liveness and Readiness Probes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/){:target="_blank"}'
  explanation: '


    This script checks each container in a given Kubernetes deployment for its liveness
    or readinessProbe configuration. The probe is responsible for checking whether
    the pod/container is healthy or not, and typically defines a command to perform
    a health check. The script checks to make sure that, if a port is declared in
    the probe''s command, it is also exposed by the container as a valid port. The
    script also performs some simple tests against the configured probe command to
    validate that it works correctly. If any of the checks fail, the script displays
    recommended "Next Steps" for how to reconfigure the probe to be valid.'
  multi_line_details: "\n\n# Read and add docstrings to the following script content,\
    \ returned in shell script format.\n#!/bin/bash\n\n# Set deployment name and namespace\n\
    # Sets the type of probe to run (defaults to readinessProbe if nothing is passed\
    \ as an argument)\nPROBE_TYPE=\"${1:-readinessProbe}\" \n\n# Function to extract\
    \ data using jq\n# Extracts the data at a specific path from the given JSON data\n\
    extract_data() {\n    echo \"$1\" | jq -r \"$2\" 2>/dev/null\n}\n\n# Function\
    \ to extract port from command\n# Extracts the number after the ':' to get the\
    \ port associated with a command\nextract_port_from_command() {\n    echo \"$1\"\
    \ | grep -oP '(?<=:)\\d+' | head -n 1\n}\n\n# Get deployment manifest in JSON\
    \ format\n# Retrieves the JSON manifest for the specified deployment in the given\
    \ namespace on the given context\nMANIFEST=$(${KUBERNETES_DISTRIBUTION_BINARY}\
    \ get deployment \"$DEPLOYMENT_NAME\" -n \"$NAMESPACE\" --context \"$CONTEXT\"\
    \ -o json)\nif [ $? -ne 0 ]; then\n    echo \"Error fetching deployment details:\
    \ $MANIFEST\"\n    exit 1\nfi\n\n# Get number of containers\n# Gets the number\
    \ of containers in the given deployment\nNUM_CONTAINERS=$(extract_data \"$MANIFEST\"\
    \ '.spec.template.spec.containers | length')\nif [ -z \"$NUM_CONTAINERS\" ]; then\n\
    \    echo \"No containers found in deployment.\"\n    exit 1\nfi\n\n\n# Loop through\
    \ containers and validate probes\n# Loops through each container and runs a check\
    \ to make sure the probe type specified follows the correct parameters\nfor ((i=0;\
    \ i<NUM_CONTAINERS; i++)); do\n    PROBE=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].${PROBE_TYPE}\"\
    )\n    CONTAINER_NAME=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].name\"\
    )\n    printf \"## $CONTAINER_NAME $PROBE_TYPE START\\n\"\n    echo \"Container:\
    \ \\`$CONTAINER_NAME\\`\"\n    echo \"$PROBE_TYPE: $PROBE\"\n\n    # List container\
    \ ports\n    # Lists the exposed ports for the given container\n    CONTAINER_PORTS=$(extract_data\
    \ \"$MANIFEST\" \".spec.template.spec.containers[$i].ports[].containerPort\")\n\
    \    if [ -n \"$CONTAINER_PORTS\" ]; then\n        echo \"Exposed Ports: $CONTAINER_PORTS\"\
    \n    else\n        echo \"No ports exposed.\"\n    fi\n\n    if [ -z \"$PROBE\"\
    \ ]; then\n        echo \"Container \\`$CONTAINER_NAME\\`: ${PROBE_TYPE} not found.\"\
    \n        continue\n    fi\n\n    # Validate that the port in the probe is defined\
    \ in the container's ports\n    # Checks that the port used in the probe type\
    \ is actually exposed by the container\n    if echo \"$PROBE\" | jq -e '.httpGet,\
    \ .tcpSocket' >/dev/null; then\n        PROBE_PORT=$(extract_data \"$PROBE\" '.httpGet.port\
    \ // .tcpSocket.port')\n        CONTAINER_PORTS=$(extract_data \"$MANIFEST\" \"\
    .spec.template.spec.containers[$i].ports[].containerPort\")\n\n        if [[ !\
    \ \" $CONTAINER_PORTS \" == *\"$PROBE_PORT\"* ]]; then\n            echo \"Container\
    \ \\`$CONTAINER_NAME\\`: Port $PROBE_PORT used in $PROBE_TYPE is not exposed by\
    \ the container.\"\n            next_steps+=(\"Update $PROBE_TYPE For \\`${DEPLOYMENT_NAME}\\\
    ` to use one of the following ports: $CONTAINER_PORTS\")\n        else\n     \
    \       echo \"Container \\`$CONTAINER_NAME\\`: ${PROBE_TYPE} port $PROBE_PORT\
    \ is valid.\"\n        fi\n    fi\n\n    # Check if exec permissions are available\
    \ (for exec type probes)\n    # Ensures that the user has permission to execute\
    \ commands within pods on the given deployment\n    if echo \"$PROBE\" | jq -e\
    \ '.exec' >/dev/null; then\n        IFS=$'\\n' read -r -d '' -a EXEC_COMMAND_ARRAY\
    \ < <(echo \"$PROBE\" | jq -r '.exec.command[]' && printf '\\0')\n        PORT_IN_COMMAND=$(extract_port_from_command\
    \ \"${EXEC_COMMAND_ARRAY[*]}\")\n\n        # Check if we see the port in the exec\
    \ command, and if so, if it's defined in the manifest\n        # Runs checks to\
    \ make sure that the port found in the targetted command is also beingexposed\
    \ by the container\n        if [ -n \"$PORT_IN_COMMAND\" ]; then\n           \
    \ CONTAINER_PORTS=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].ports[].containerPort\"\
    )\n            if [[ ! \" $CONTAINER_PORTS \" == *\"$PORT_IN_COMMAND\"* ]]; then\n\
    \                echo \"Container \\`$CONTAINER_NAME\\`: Port $PORT_IN_COMMAND\
    \ used in ${PROBE_TYPE} exec command is not exposed by the container. The following\
    \ ports are exposed: $CONTAINER_PORTS\"\n                next_steps+=(\"Get Deployment\
    \ Workload Details For \\`${DEPLOYMENT_NAME}\\`\")\n                next_steps+=(\"\
    Verify and Reconfigure Manifest $PROBE_TYPE with Valid Ports For \\`${DEPLOYMENT_NAME}\\\
    `\")\n            else\n                echo \"Container \\`$CONTAINER_NAME\\\
    `: Port $PORT_IN_COMMAND in ${PROBE_TYPE} exec command is valid.\"\n         \
    \   fi\n        fi\n\n        # Check exec permission and execute command\n  \
    \      # Executes a given command to test while falling back to replacement ports\
    \ if the original command failed\n        if ${KUBERNETES_DISTRIBUTION_BINARY}\
    \ auth can-i create pods/exec -n \"$NAMESPACE\" >/dev/null 2"
  name: check_liveness_probe_configuration_for_deployment_deployment_name
- command: bash 'validate_probes.sh' readinessProbe
  doc_links: '

    - [Kubernetes Documentation Homepage](https://kubernetes.io/docs/){:target="_blank"}

    - [Overview of Containers, Pods, and Services](https://kubernetes.io/docs/concepts/workloads/pods/pod/){:target="_blank"}

    - [Using Liveness and Readiness Probes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/){:target="_blank"}'
  explanation: '


    This script checks each container in a given Kubernetes deployment for its liveness
    or readinessProbe configuration. The probe is responsible for checking whether
    the pod/container is healthy or not, and typically defines a command to perform
    a health check. The script checks to make sure that, if a port is declared in
    the probe''s command, it is also exposed by the container as a valid port. The
    script also performs some simple tests against the configured probe command to
    validate that it works correctly. If any of the checks fail, the script displays
    recommended "Next Steps" for how to reconfigure the probe to be valid.'
  multi_line_details: "\n\n# Read and add docstrings to the following script content,\
    \ returned in shell script format.\n#!/bin/bash\n\n# Set deployment name and namespace\n\
    # Sets the type of probe to run (defaults to readinessProbe if nothing is passed\
    \ as an argument)\nPROBE_TYPE=\"${1:-readinessProbe}\" \n\n# Function to extract\
    \ data using jq\n# Extracts the data at a specific path from the given JSON data\n\
    extract_data() {\n    echo \"$1\" | jq -r \"$2\" 2>/dev/null\n}\n\n# Function\
    \ to extract port from command\n# Extracts the number after the ':' to get the\
    \ port associated with a command\nextract_port_from_command() {\n    echo \"$1\"\
    \ | grep -oP '(?<=:)\\d+' | head -n 1\n}\n\n# Get deployment manifest in JSON\
    \ format\n# Retrieves the JSON manifest for the specified deployment in the given\
    \ namespace on the given context\nMANIFEST=$(${KUBERNETES_DISTRIBUTION_BINARY}\
    \ get deployment \"$DEPLOYMENT_NAME\" -n \"$NAMESPACE\" --context \"$CONTEXT\"\
    \ -o json)\nif [ $? -ne 0 ]; then\n    echo \"Error fetching deployment details:\
    \ $MANIFEST\"\n    exit 1\nfi\n\n# Get number of containers\n# Gets the number\
    \ of containers in the given deployment\nNUM_CONTAINERS=$(extract_data \"$MANIFEST\"\
    \ '.spec.template.spec.containers | length')\nif [ -z \"$NUM_CONTAINERS\" ]; then\n\
    \    echo \"No containers found in deployment.\"\n    exit 1\nfi\n\n\n# Loop through\
    \ containers and validate probes\n# Loops through each container and runs a check\
    \ to make sure the probe type specified follows the correct parameters\nfor ((i=0;\
    \ i<NUM_CONTAINERS; i++)); do\n    PROBE=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].${PROBE_TYPE}\"\
    )\n    CONTAINER_NAME=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].name\"\
    )\n    printf \"## $CONTAINER_NAME $PROBE_TYPE START\\n\"\n    echo \"Container:\
    \ \\`$CONTAINER_NAME\\`\"\n    echo \"$PROBE_TYPE: $PROBE\"\n\n    # List container\
    \ ports\n    # Lists the exposed ports for the given container\n    CONTAINER_PORTS=$(extract_data\
    \ \"$MANIFEST\" \".spec.template.spec.containers[$i].ports[].containerPort\")\n\
    \    if [ -n \"$CONTAINER_PORTS\" ]; then\n        echo \"Exposed Ports: $CONTAINER_PORTS\"\
    \n    else\n        echo \"No ports exposed.\"\n    fi\n\n    if [ -z \"$PROBE\"\
    \ ]; then\n        echo \"Container \\`$CONTAINER_NAME\\`: ${PROBE_TYPE} not found.\"\
    \n        continue\n    fi\n\n    # Validate that the port in the probe is defined\
    \ in the container's ports\n    # Checks that the port used in the probe type\
    \ is actually exposed by the container\n    if echo \"$PROBE\" | jq -e '.httpGet,\
    \ .tcpSocket' >/dev/null; then\n        PROBE_PORT=$(extract_data \"$PROBE\" '.httpGet.port\
    \ // .tcpSocket.port')\n        CONTAINER_PORTS=$(extract_data \"$MANIFEST\" \"\
    .spec.template.spec.containers[$i].ports[].containerPort\")\n\n        if [[ !\
    \ \" $CONTAINER_PORTS \" == *\"$PROBE_PORT\"* ]]; then\n            echo \"Container\
    \ \\`$CONTAINER_NAME\\`: Port $PROBE_PORT used in $PROBE_TYPE is not exposed by\
    \ the container.\"\n            next_steps+=(\"Update $PROBE_TYPE For \\`${DEPLOYMENT_NAME}\\\
    ` to use one of the following ports: $CONTAINER_PORTS\")\n        else\n     \
    \       echo \"Container \\`$CONTAINER_NAME\\`: ${PROBE_TYPE} port $PROBE_PORT\
    \ is valid.\"\n        fi\n    fi\n\n    # Check if exec permissions are available\
    \ (for exec type probes)\n    # Ensures that the user has permission to execute\
    \ commands within pods on the given deployment\n    if echo \"$PROBE\" | jq -e\
    \ '.exec' >/dev/null; then\n        IFS=$'\\n' read -r -d '' -a EXEC_COMMAND_ARRAY\
    \ < <(echo \"$PROBE\" | jq -r '.exec.command[]' && printf '\\0')\n        PORT_IN_COMMAND=$(extract_port_from_command\
    \ \"${EXEC_COMMAND_ARRAY[*]}\")\n\n        # Check if we see the port in the exec\
    \ command, and if so, if it's defined in the manifest\n        # Runs checks to\
    \ make sure that the port found in the targetted command is also beingexposed\
    \ by the container\n        if [ -n \"$PORT_IN_COMMAND\" ]; then\n           \
    \ CONTAINER_PORTS=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].ports[].containerPort\"\
    )\n            if [[ ! \" $CONTAINER_PORTS \" == *\"$PORT_IN_COMMAND\"* ]]; then\n\
    \                echo \"Container \\`$CONTAINER_NAME\\`: Port $PORT_IN_COMMAND\
    \ used in ${PROBE_TYPE} exec command is not exposed by the container. The following\
    \ ports are exposed: $CONTAINER_PORTS\"\n                next_steps+=(\"Get Deployment\
    \ Workload Details For \\`${DEPLOYMENT_NAME}\\`\")\n                next_steps+=(\"\
    Verify and Reconfigure Manifest $PROBE_TYPE with Valid Ports For \\`${DEPLOYMENT_NAME}\\\
    `\")\n            else\n                echo \"Container \\`$CONTAINER_NAME\\\
    `: Port $PORT_IN_COMMAND in ${PROBE_TYPE} exec command is valid.\"\n         \
    \   fi\n        fi\n\n        # Check exec permission and execute command\n  \
    \      # Executes a given command to test while falling back to replacement ports\
    \ if the original command failed\n        if ${KUBERNETES_DISTRIBUTION_BINARY}\
    \ auth can-i create pods/exec -n \"$NAMESPACE\" >/dev/null 2"
  name: check_readiness_probe_configuration_for_deployment_deployment_name
- command: 'kubectl get events --context ${CONTEXT} -n ${NAMESPACE} -o json | jq ''(now
    - (60*60)) as $time_limit | [ .items[] | select(.type == "Warning" and (.involvedObject.kind
    == "Deployment" or .involvedObject.kind == "ReplicaSet" or .involvedObject.kind
    == "Pod") and (.involvedObject.name | tostring | contains("${DEPLOYMENT_NAME}"))
    and (.lastTimestamp | fromdateiso8601) >= $time_limit) | {kind: .involvedObject.kind,
    name: .involvedObject.name, reason: .reason, message: .message, firstTimestamp:
    .firstTimestamp, lastTimestamp: .lastTimestamp} ] | group_by([.kind, .name]) |
    map({kind: .[0].kind, name: .[0].name, count: length, reasons: map(.reason) |
    unique, messages: map(.message) | unique, firstTimestamp: map(.firstTimestamp
    | fromdateiso8601) | sort | .[0] | todateiso8601, lastTimestamp: map(.lastTimestamp
    | fromdateiso8601) | sort | reverse | .[0] | todateiso8601})'''
  doc_links: '

    - [Kubectl get events command - official docs](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get-events){:target="_blank"}

    - [Kubectl context command - official docs](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#context){:target="_blank"}

    - [Kubernetes namespaces - official docs](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Using jq command utility to parse JSON - official docs](https://stedolan.github.io/jq/tutorial/){:target="_blank"}'
  explanation: '


    This command will list all the events within a Kubernetes cluster in json format.
    It filters for only warnings, deployments, replicasets, and pods with the specified
    deployment name that have occurred within the last hour. The output includes the
    kind of event, the name of the object that was affected by the event, the reason
    for the event, any messages associated with the event, and the first and last
    time stamp of the event.'
  multi_line_details: "\n\n# This command gets events from a Kubernetes cluster, filtered\
    \ to get only Warnings from Deployment, ReplicaSet or Pod which contain the specified\
    \ DEPLOYMENT_NAME. It is then grouped by kind and name and mapped in to shorten\
    \ form with additional fields\n\nkubectl get events \\  # Get events from the\
    \ Kubernetes cluster \n    --context ${CONTEXT} \\  # Specify the context of the\
    \ kubernetes cluster\n    -n ${NAMESPACE} \\  # The namespace from which to get\
    \ events from\n    -o json | \\  # Output the result in json format\n    jq '(now\
    \ - (60*60)) as $time_limit | \\  # Define time limit for the events i.e. last\
    \ one hour\n        [ .items[] | \\  # Get all items from the response\n     \
    \       select(.type == \"Warning\" and \\  # Filter for Warning type of events\n\
    \            (.involvedObject.kind == \"Deployment\" \\  # Filter for Events related\
    \ to Deployment objects\n            or .involvedObject.kind == \"ReplicaSet\"\
    \ \\  # Filter for Events related to ReplicaSet objects\n            or .involvedObject.kind\
    \ == \"Pod\") \\  # Filter for Events related to Pod objects\n            and\
    \ (.involvedObject.name | tostring | contains(\"${DEPLOYMENT_NAME}\")) \\  # Filter\
    \ on name of the deployment\n            and (.lastTimestamp | fromdateiso8601)\
    \ >= $time_limit) \\  # Filter on timestamp of the events\n        | {kind: .involvedObject.kind,\
    \ name: .involvedObject.name, reason: .reason, message: .message,  # Map events\
    \ into simplified form with additional fields\n            firstTimestamp: .firstTimestamp,\
    \ lastTimestamp: .lastTimestamp} ] \\\n        | group_by([.kind, .name]) \\ \
    \ # Group the events based on kind and name\n        | map({kind: .[0].kind, name:\
    \ .[0].name, count: length, \\  # Further map the data to list counts, reasons\
    \ and messages\n            reasons: map(.reason) | unique, messages: map(.message)\
    \ | unique, \n            firstTimestamp: map(.firstTimestamp | fromdateiso8601)\
    \ | sort | .[0] | todateiso8601, \\\n            lastTimestamp: map(.lastTimestamp\
    \ | fromdateiso8601) | sort | reverse | .[0] | todateiso8601})'"
  name: troubleshoot_deployment_warning_events_for_deployment_name
- command: kubectl get deployment/${DEPLOYMENT_NAME} --context ${CONTEXT} -n ${NAMESPACE}
    -o yaml
  doc_links: '

    - [Kubernetes documentation on kubectl](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands){:target="_blank"}

    - [Official Kubernetes kubectl get deployment documentation](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get-deployment){:target="_blank"}

    - [Kubernetes documentation on namespace](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubernetes documentation on output format](https://kubernetes.io/docs/reference/using-api/api-overview/#application-programming-interface-command-line-interface){:target="_blank"}'
  explanation: '


    This command tells Kubernetes to get information about a particular deployment
    that has been specified by the name (${DEPLOYMENT_NAME}). The context (${CONTEXT})
    and namespace (${NAMESPACE}) provide Kubernetes with more information as to where
    exactly this deployment lives. Finally, you are asking Kubernetes to output the
    results in the yaml format.'
  multi_line_details: "\n\n#This line of code will retrieve the deployment configuration\
    \ info from Kubernetes corresponding to a given deployment name, context, and\
    \ namespace in a yaml format\n\nkubectl \\\n    #This is the kubernetes command\
    \ line interface command\n    get \\\n    #Use the 'get' subcommand to retrieve\
    \ information/objects\n    deployment/${DEPLOYMENT_NAME} \\\n    #In this case,\
    \ we're specifically looking for Deployments with the given deployment name\n\
    \    --context ${CONTEXT} \\\n    #Optionally specify a 'context' - an isolated\
    \ cluster role for the operation. We set this variable separately, as it's value\
    \ may differ between users/environments.\n    -n ${NAMESPACE} \\\n    #Specify\
    \ a 'namespace' - the environment where all objects of type K8s live. This variable\
    \ should be set separately, as it's value can change between users/environments.\n\
    \    -o yaml\\\n    #The output format will be in yaml, as specified by the '-o\
    \ yaml' option."
  name: get_deployment_workload_details_for_deployment_name_and_add_to_report
- command: 'kubectl get deployment/${DEPLOYMENT_NAME} --context ${CONTEXT} -n ${NAMESPACE}
    -o json | jq ''.status | {desired_replicas: .replicas, ready_replicas: (.readyReplicas
    // 0), missing_replicas: ((.replicas // 0) - (.readyReplicas // 0)), unavailable_replicas:
    (.unavailableReplicas // 0), available_condition: (if any(.conditions[]; .type
    == "Available") then (.conditions[] | select(.type == "Available")) else "Condition
    not available" end), progressing_condition: (if any(.conditions[]; .type == "Progressing")
    then (.conditions[] | select(.type == "Progressing")) else "Condition not available"
    end)}'''
  doc_links: '

    - [Kubectl Commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands){:target="_blank"}

    - [Kubectl Contexts](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-current-context){:target="_blank"}

    - [Using JSON Path in JQ](https://stedolan.github.io/jq/manual/#Basicfilters%20and%20paths){:target="_blank"}

    - [JQ Functions](https://stedolan.github.io/jq/manual/#Basicoperatorsandcomparisons){:target="_blank"}'
  explanation: '


    This command is retrieving the status of a Kubernetes deployment. A deployment
    defines how a particular pod or set of pods should be deployed and managed by
    Kubernetes. It will retrieve the desired number of replicas (defined replicas)
    for that deployment, the ready replicas (number of replicas already created and
    working), the missing replicas (replicas defined but not yet created) and the
    unavailable replicas (number of replicas that vice versa are working but not defined).
    In addition, it will provide two conditions, available and progressing, to check
    their related statuses. This command will allow you to see if the deployment is
    up and running with all the given data.'
  multi_line_details: "\n\n# Get deployment specified by the ${DEPLOYMENT_NAME} variable\
    \ and associated context, namespace. Output in json format\nkubectl get deployment/${DEPLOYMENT_NAME}\
    \ \\ \n    --context ${CONTEXT} \\\n    -n ${NAMESPACE} \\\n    -o json \n\n#\
    \ Run jq command to specify desired replicas, ready replicas, missing replicas,\
    \ unavailable replicas, available condition, and progressing condition\n| jq '.status\
    \ | {desired_replicas: .replicas, ready_replicas: (.readyReplicas // 0), missing_replicas:\
    \ ((.replicas // 0) - (.readyReplicas // 0)), unavailable_replicas: (.unavailableReplicas\
    \ // 0), available_condition: (if any(.conditions[]; .type == \"Available\") then\
    \ (.conditions[] | select(.type == \"Available\")) else \"Condition not available\"\
    \ end), progressing_condition: (if any(.conditions[]; .type == \"Progressing\"\
    ) then (.conditions[] | select(.type == \"Progressing\")) else \"Condition not\
    \ available\" end)}'"
  name: troubleshoot_deployment_replicas_for_deployment_name
- command: 'kubectl get events --context ${CONTEXT} -n ${NAMESPACE} -o json | jq ''(now
    - (60*60)) as $time_limit | [ .items[] | select(.type != "Warning" and (.involvedObject.kind
    == "Deployment" or .involvedObject.kind == "ReplicaSet" or .involvedObject.kind
    == "Pod") and (.involvedObject.name | tostring | contains("${DEPLOYMENT_NAME}")))
    | {kind: .involvedObject.kind, count: .count, name: .involvedObject.name, reason:
    .reason, message: .message, firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp,
    duration: (if (((.lastTimestamp | fromdateiso8601) - (.firstTimestamp | fromdateiso8601))
    == 0) then 1 else (((.lastTimestamp | fromdateiso8601) - (.firstTimestamp | fromdateiso8601))/60)
    end) } ] | group_by([.kind, .name]) | map({kind: .[0].kind, name: .[0].name, count:
    (map(.count) | add), reasons: map(.reason) | unique, messages: map(.message) |
    unique, average_events_per_minute: (if .[0].duration == 1 then 1 else ((map(.count)
    | add)/.[0].duration ) end),firstTimestamp: map(.firstTimestamp | fromdateiso8601)
    | sort | .[0] | todateiso8601, lastTimestamp: map(.lastTimestamp | fromdateiso8601)
    | sort | reverse | .[0] | todateiso8601})'''
  doc_links: '

    - [Kubernetes Documentation - kubectl](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands){:target="_blank"}

    - [jq Manual](https://stedolan.github.io/jq/){:target="_blank"}'
  explanation: '


    This command allows the user to get events from Kubernetes based on a specified
    context, namespace, and deployment name. It takes the output from kubectl and
    adds additional contextual information like the count, messages, first and last
    timestamp of the event, and the average number of events per minute. This makes
    it easier to see what type of events happened related to the given context, namespace,
    and deployment name, and how long each of those events took to complete.'
  multi_line_details: "\n\n# This is a Kubernetes command to get events from the context\
    \ of the given namespace filtered by specific deployment name and convert it into\
    \ a JSON fromat.\n# This command can be broken down into multiple lines for better\
    \ readability.\n\n# Set the CONTEXT, NAMESPACE, DEPLOYMENT_NAME environment variables\
    \ in the current shell\nCONTEXT=\"<insert context>\"\nNAMESPACE=\"<insert namespace>\"\
    \nDEPLOYMENT_NAME=\"<insert deployment>\"\n\n# Get events using the kubectl command\
    \ with json formatting\nkubectl get events \\\n    --context ${CONTEXT} \\\n \
    \   -n ${NAMESPACE} \\ \n    -o json \\\n\n# Pipe the output to jq for additional\
    \ filtering.\n| jq '(now - (60*60)) as $time_limit | [ .items[] | select(.type\
    \ != \"Warning\" and (.involvedObject.kind == \"Deployment\" or .involvedObject.kind\
    \ == \"ReplicaSet\" or .involvedObject.kind == \"Pod\") and (.involvedObject.name\
    \ | tostring | contains(\"${DEPLOYMENT_NAME}\"))) | {kind: .involvedObject.kind,\
    \ count: .count, name: .involvedObject.name, reason: .reason, message: .message,\
    \ firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp, duration: (if\
    \ (((.lastTimestamp | fromdateiso8601) - (.firstTimestamp | fromdateiso8601))\
    \ == 0) then 1 else (((.lastTimestamp | fromdateiso8601) - (.firstTimestamp |\
    \ fromdateiso8601))/60) end) } ] | group_by([.kind, .name]) | map({kind: .[0].kind,\
    \ name: .[0].name, count: (map(.count) | add), reasons: map(.reason) | unique,\
    \ messages: map(.message) | unique, average_events_per_minute: (if .[0].duration\
    \ == 1 then 1 else ((map(.count) | add)/.[0].duration ) end),firstTimestamp: map(.firstTimestamp\
    \ | fromdateiso8601) | sort | .[0] | todateiso8601, lastTimestamp: map(.lastTimestamp\
    \ | fromdateiso8601) | sort | reverse | .[0] | todateiso8601})'"
  name: check_deployment_event_anomalies_for_deployment_name
