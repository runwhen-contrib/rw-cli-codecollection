commands:
- command: bash 'validate_probes.sh' livenessProbe
  doc_links: '

    - [Kubernetes Probes documentation](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/){:target="_blank"}

    - [Understanding Container Ports in Kubernetes](https://kubernetes.io/docs/concepts/services-networking/service/#multi-port-services){:target="_blank"}'
  explanation: This script is used to check the probes (livenessProbe or readinessProbe)
    of containers in a Kubernetes deployment. It also looks at port numbers in these
    probes and provides recommendations based on what it finds.
  multi_line_details: "```shell\n#!/bin/bash\n\n# Set deployment name and namespace\n\
    PROBE_TYPE=\"${1:-readinessProbe}\"  # Default to livenessProbe, can be set to\
    \ readinessProbe\n\n# Function to extract data using jq\nextract_data() {\n  \
    \  echo \"$1\" | jq -r \"$2\" 2>/dev/null\n}\n\n# Function to extract port from\
    \ command\nextract_port_from_command() {\n    echo \"$1\" | grep -oP '(?<=:)\\\
    d+' | head -n 1\n}\n\n# Get deployment manifest in JSON format\nMANIFEST=$(${KUBERNETES_DISTRIBUTION_BINARY}\
    \ get deployment \"$DEPLOYMENT_NAME\" -n \"$NAMESPACE\" --context \"$CONTEXT\"\
    \ -o json)\nif [ $? -ne 0 ]; then\n    echo \"Error fetching deployment details:\
    \ $MANIFEST\"\n    exit 1\nfi\n\n# Get number of containers\nNUM_CONTAINERS=$(extract_data\
    \ \"$MANIFEST\" '.spec.template.spec.containers | length')\nif [ -z \"$NUM_CONTAINERS\"\
    \ ]; then\n    echo \"No containers found in deployment.\"\n    exit 1\nfi\n\n\
    \n# Loop through containers and validate probes\nfor ((i=0; i<NUM_CONTAINERS;\
    \ i++)); do\n    PROBE=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].${PROBE_TYPE}\"\
    )\n    CONTAINER_NAME=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].name\"\
    )\n    printf \"## $CONTAINER_NAME $PROBE_TYPE START\\n\"\n    echo \"Container:\
    \ \\`$CONTAINER_NAME\\`\"\n    echo \"$PROBE_TYPE: $PROBE\"\n\n    # List container\
    \ ports\n    CONTAINER_PORTS=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].ports[].containerPort\"\
    )\n    if [ -n \"$CONTAINER_PORTS\" ]; then\n        echo \"Exposed Ports: $CONTAINER_PORTS\"\
    \n    else\n        echo \"No ports exposed.\"\n    fi\n\n    if [ -z \"$PROBE\"\
    \ ]; then\n        echo \"Container \\`$CONTAINER_NAME\\`: ${PROBE_TYPE} not found.\"\
    \n        continue\n    fi\n\n    # Validate that the port in the probe is defined\
    \ in the container's ports\n    if echo \"$PROBE\" | jq -e '.httpGet, .tcpSocket'\
    \ >/dev/null; then\n        PROBE_PORT=$(extract_data \"$PROBE\" '.httpGet.port\
    \ // .tcpSocket.port')\n        CONTAINER_PORTS=$(extract_data \"$MANIFEST\" \"\
    .spec.template.spec.containers[$i].ports[].containerPort\")\n\n        if [[ !\
    \ \" $CONTAINER_PORTS \" == *\"$PROBE_PORT\"* ]]; then\n            echo \"Container\
    \ \\`$CONTAINER_NAME\\`: Port $PROBE_PORT used in $PROBE_TYPE is not exposed by\
    \ the container.\"\n            next_steps+=(\"Update $PROBE_TYPE For \\`${DEPLOYMENT_NAME}\\\
    ` to use one of the following ports: $CONTAINER_PORTS\")\n        else\n     \
    \       echo \"Container \\`$CONTAINER_NAME\\`: ${PROBE_TYPE} port $PROBE_PORT\
    \ is valid.\"\n        fi\n    fi\n\n# Check if exec permissions are available\
    \ (for exec type probes)\nif echo \"$PROBE\" | jq -e '.exec' >/dev/null; then\n\
    \    IFS=$'\\n' read -r -d '' -a EXEC_COMMAND_ARRAY < <(echo \"$PROBE\" | jq -r\
    \ '.exec.command[]' && printf '\\0')\n    PORT_IN_COMMAND=$(extract_port_from_command\
    \ \"${EXEC_COMMAND_ARRAY[*]}\")\n\n    # Check if we see the port in the exec\
    \ command, and if so, if it's defined in the manifest\n    if [ -n \"$PORT_IN_COMMAND\"\
    \ ]; then\n        CONTAINER_PORTS=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].ports[].containerPort\"\
    )\n        if [[ ! \" $CONTAINER_PORTS \" == *\"$PORT_IN_COMMAND\"* ]]; then\n\
    \            echo \"Container \\`$CONTAINER_NAME\\`: Port $PORT_IN_COMMAND used\
    \ in ${PROBE_TYPE} exec command is not exposed by the container. The following\
    \ ports are exposed: $CONTAINER_PORTS\"\n            next_steps+=(\"Get Deployment\
    \ Workload Details For \\`${DEPLOYMENT_NAME}\\`\")\n            next_steps+=(\"\
    Verify and Reconfigure Manifest $PROBE_TYPE with Valid Ports For \\`${DEPLOYMENT_NAME}\\\
    `\")\n        else\n            echo \"Container \\`$CONTAINER_NAME\\`: Port $PORT_IN_COMMAND\
    \ in ${PROBE_TYPE} exec command is valid.\"\n        fi\n    fi\n\n    # Check\
    \ exec permission and execute command\n    if ${KUBERNETES_DISTRIBUTION_BINARY}\
    \ auth can-i create pods/exec -n \"$NAMESPACE\" >/dev/null 2>&1; then\n      \
    \  POD_NAME=$(${KUBERNETES_DISTRIBUTION_BINARY} get pods -n \"$NAMESPACE\" -l\
    \ \"app=$DEPLOYMENT_NAME\" -o jsonpath=\"{.items[0].metadata.name}\")\n      \
    \  if [ -z \"$POD_NAME\" ]; then\n            echo \"No pods found for deployment\
    \ $DEPLOYMENT_NAME.\"\n            continue\n        fi\n\n        # Execute command\n\
    \        printf \"\\n"
  name: check_liveness_probe_configuration_for_deployment_deployment_name
- command: bash 'validate_probes.sh' readinessProbe
  doc_links: '

    - [Kubernetes Probes documentation](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/){:target="_blank"}

    - [Understanding Container Ports in Kubernetes](https://kubernetes.io/docs/concepts/services-networking/service/#multi-port-services){:target="_blank"}'
  explanation: This script is used to check the probes (livenessProbe or readinessProbe)
    of containers in a Kubernetes deployment. It also looks at port numbers in these
    probes and provides recommendations based on what it finds.
  multi_line_details: "```shell\n#!/bin/bash\n\n# Set deployment name and namespace\n\
    PROBE_TYPE=\"${1:-readinessProbe}\"  # Default to livenessProbe, can be set to\
    \ readinessProbe\n\n# Function to extract data using jq\nextract_data() {\n  \
    \  echo \"$1\" | jq -r \"$2\" 2>/dev/null\n}\n\n# Function to extract port from\
    \ command\nextract_port_from_command() {\n    echo \"$1\" | grep -oP '(?<=:)\\\
    d+' | head -n 1\n}\n\n# Get deployment manifest in JSON format\nMANIFEST=$(${KUBERNETES_DISTRIBUTION_BINARY}\
    \ get deployment \"$DEPLOYMENT_NAME\" -n \"$NAMESPACE\" --context \"$CONTEXT\"\
    \ -o json)\nif [ $? -ne 0 ]; then\n    echo \"Error fetching deployment details:\
    \ $MANIFEST\"\n    exit 1\nfi\n\n# Get number of containers\nNUM_CONTAINERS=$(extract_data\
    \ \"$MANIFEST\" '.spec.template.spec.containers | length')\nif [ -z \"$NUM_CONTAINERS\"\
    \ ]; then\n    echo \"No containers found in deployment.\"\n    exit 1\nfi\n\n\
    \n# Loop through containers and validate probes\nfor ((i=0; i<NUM_CONTAINERS;\
    \ i++)); do\n    PROBE=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].${PROBE_TYPE}\"\
    )\n    CONTAINER_NAME=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].name\"\
    )\n    printf \"## $CONTAINER_NAME $PROBE_TYPE START\\n\"\n    echo \"Container:\
    \ \\`$CONTAINER_NAME\\`\"\n    echo \"$PROBE_TYPE: $PROBE\"\n\n    # List container\
    \ ports\n    CONTAINER_PORTS=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].ports[].containerPort\"\
    )\n    if [ -n \"$CONTAINER_PORTS\" ]; then\n        echo \"Exposed Ports: $CONTAINER_PORTS\"\
    \n    else\n        echo \"No ports exposed.\"\n    fi\n\n    if [ -z \"$PROBE\"\
    \ ]; then\n        echo \"Container \\`$CONTAINER_NAME\\`: ${PROBE_TYPE} not found.\"\
    \n        continue\n    fi\n\n    # Validate that the port in the probe is defined\
    \ in the container's ports\n    if echo \"$PROBE\" | jq -e '.httpGet, .tcpSocket'\
    \ >/dev/null; then\n        PROBE_PORT=$(extract_data \"$PROBE\" '.httpGet.port\
    \ // .tcpSocket.port')\n        CONTAINER_PORTS=$(extract_data \"$MANIFEST\" \"\
    .spec.template.spec.containers[$i].ports[].containerPort\")\n\n        if [[ !\
    \ \" $CONTAINER_PORTS \" == *\"$PROBE_PORT\"* ]]; then\n            echo \"Container\
    \ \\`$CONTAINER_NAME\\`: Port $PROBE_PORT used in $PROBE_TYPE is not exposed by\
    \ the container.\"\n            next_steps+=(\"Update $PROBE_TYPE For \\`${DEPLOYMENT_NAME}\\\
    ` to use one of the following ports: $CONTAINER_PORTS\")\n        else\n     \
    \       echo \"Container \\`$CONTAINER_NAME\\`: ${PROBE_TYPE} port $PROBE_PORT\
    \ is valid.\"\n        fi\n    fi\n\n# Check if exec permissions are available\
    \ (for exec type probes)\nif echo \"$PROBE\" | jq -e '.exec' >/dev/null; then\n\
    \    IFS=$'\\n' read -r -d '' -a EXEC_COMMAND_ARRAY < <(echo \"$PROBE\" | jq -r\
    \ '.exec.command[]' && printf '\\0')\n    PORT_IN_COMMAND=$(extract_port_from_command\
    \ \"${EXEC_COMMAND_ARRAY[*]}\")\n\n    # Check if we see the port in the exec\
    \ command, and if so, if it's defined in the manifest\n    if [ -n \"$PORT_IN_COMMAND\"\
    \ ]; then\n        CONTAINER_PORTS=$(extract_data \"$MANIFEST\" \".spec.template.spec.containers[$i].ports[].containerPort\"\
    )\n        if [[ ! \" $CONTAINER_PORTS \" == *\"$PORT_IN_COMMAND\"* ]]; then\n\
    \            echo \"Container \\`$CONTAINER_NAME\\`: Port $PORT_IN_COMMAND used\
    \ in ${PROBE_TYPE} exec command is not exposed by the container. The following\
    \ ports are exposed: $CONTAINER_PORTS\"\n            next_steps+=(\"Get Deployment\
    \ Workload Details For \\`${DEPLOYMENT_NAME}\\`\")\n            next_steps+=(\"\
    Verify and Reconfigure Manifest $PROBE_TYPE with Valid Ports For \\`${DEPLOYMENT_NAME}\\\
    `\")\n        else\n            echo \"Container \\`$CONTAINER_NAME\\`: Port $PORT_IN_COMMAND\
    \ in ${PROBE_TYPE} exec command is valid.\"\n        fi\n    fi\n\n    # Check\
    \ exec permission and execute command\n    if ${KUBERNETES_DISTRIBUTION_BINARY}\
    \ auth can-i create pods/exec -n \"$NAMESPACE\" >/dev/null 2>&1; then\n      \
    \  POD_NAME=$(${KUBERNETES_DISTRIBUTION_BINARY} get pods -n \"$NAMESPACE\" -l\
    \ \"app=$DEPLOYMENT_NAME\" -o jsonpath=\"{.items[0].metadata.name}\")\n      \
    \  if [ -z \"$POD_NAME\" ]; then\n            echo \"No pods found for deployment\
    \ $DEPLOYMENT_NAME.\"\n            continue\n        fi\n\n        # Execute command\n\
    \        printf \"\\n"
  name: check_readiness_probe_configuration_for_deployment_deployment_name
- command: 'kubectl get events --context ${CONTEXT} -n ${NAMESPACE} -o json | jq ''(now
    - (60*60)) as $time_limit | [ .items[] | select(.type == "Warning" and (.involvedObject.kind
    == "Deployment" or .involvedObject.kind == "ReplicaSet" or .involvedObject.kind
    == "Pod") and (.involvedObject.name | tostring | contains("${DEPLOYMENT_NAME}"))
    and (.lastTimestamp | fromdateiso8601) >= $time_limit) | {kind: .involvedObject.kind,
    name: .involvedObject.name, reason: .reason, message: .message, firstTimestamp:
    .firstTimestamp, lastTimestamp: .lastTimestamp} ] | group_by([.kind, .name]) |
    map({kind: .[0].kind, name: .[0].name, count: length, reasons: map(.reason) |
    unique, messages: map(.message) | unique, firstTimestamp: map(.firstTimestamp
    | fromdateiso8601) | sort | .[0] | todateiso8601, lastTimestamp: map(.lastTimestamp
    | fromdateiso8601) | sort | reverse | .[0] | todateiso8601})'''
  doc_links: '

    - [kubectl Overview](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [kubectl get events](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get-events){:target="_blank"}

    - [kubectl context](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#context){:target="_blank"}

    - [kubectl namespace](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [jq Manual (Official GitHub Repository)](https://stedolan.github.io/jq/manual/){:target="_blank"}

    - [Filtering and mapping using jq](https://learnxinyminutes.com/docs/jq/){:target="_blank"}'
  explanation: This command uses kubectl to get events from a specific context and
    namespace, then uses jq to filter out and format the events related to a specific
    deployment name that have occurred in the last hour.
  multi_line_details: "```bash\n# Set the context to use for the kubectl command\n\
    CONTEXT=${CONTEXT}\n# Set the namespace to use for the kubectl command\nNAMESPACE=${NAMESPACE}\n\
    # Set the time limit for events to filter based on their timestamp\nTIME_LIMIT=$(now\
    \ - (60*60))\n\n# Get events from the specified context and namespace in JSON\
    \ format\nkubectl get events --context ${CONTEXT} -n ${NAMESPACE} -o json \\\n\
    \  # Pipe the output to the jq command to filter and format the data\n  | jq '(.items[]\
    \ | select(\n    # Filter events with \"Warning\" type and involve Deployment,\
    \ ReplicaSet or Pod\n    .type == \"Warning\" and (.involvedObject.kind == \"\
    Deployment\" or .involvedObject.kind == \"ReplicaSet\" or .involvedObject.kind\
    \ == \"Pod\") and \n    # Check if the event is related to the specified deployment\
    \ name\n    (.involvedObject.name | tostring | contains(\"${DEPLOYMENT_NAME}\"\
    )) and \n    # Compare the lastTimestamp of the event with the time limit\n  \
    \  (.lastTimestamp | fromdateiso8601) >= $time_limit\n  ) | \n  # Map the selected\
    \ fields into a new object\n  {kind: .involvedObject.kind, name: .involvedObject.name,\
    \ reason: .reason, message: .message, firstTimestamp: .firstTimestamp, lastTimestamp:\
    \ .lastTimestamp}) | \n  # Group the events by kind and name\n  group_by([.kind,\
    \ .name]) | \n  # Map the grouped events into a new object\n  map({\n    kind:\
    \ .[0].kind, \n    name: .[0].name, \n    count: length, \n    reasons: map(.reason)\
    \ | unique, \n    messages: map(.message) | unique, \n    firstTimestamp: map(.firstTimestamp\
    \ | fromdateiso8601) | sort | .[0] | todateiso8601, \n    lastTimestamp: map(.lastTimestamp\
    \ | fromdateiso8601) | sort | reverse | .[0] | todateiso8601\n  })'\n```"
  name: troubleshoot_deployment_warning_events_for_deployment_name
- command: kubectl get deployment/${DEPLOYMENT_NAME} --context ${CONTEXT} -n ${NAMESPACE}
    -o yaml
  doc_links: '

    - [Kubernetes kubectl explain command](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#explain){:target="_blank"}

    - [Kubernetes Contexts](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters){:target="_blank"}

    - [Kubernetes Namespaces](https://kubernetes.io/docs/tasks/administer-cluster/namespaces/){:target="_blank"}

    - [YAML Format](https://learnxinyminutes.com/docs/yaml/){:target="_blank"}'
  explanation: This command is used to retrieve detailed information about a specific
    deployment within a specified Kubernetes context and namespace, and the output
    will be in YAML format.
  multi_line_details: '```bash

    # Set the variable DEPLOYMENT_NAME to the name of the deployment you want to get
    information about

    DEPLOYMENT_NAME=my-deployment


    # Set the variable CONTEXT to the Kubernetes context you want to use (e.g. minikube,
    production, etc.)

    CONTEXT=minikube


    # Set the variable NAMESPACE to the namespace in which the deployment is located

    NAMESPACE=my-namespace


    # Use the kubectl command to get the YAML representation of the deployment specified
    by DEPLOYMENT_NAME,

    # within the Kubernetes cluster specified by CONTEXT and in the namespace specified
    by NAMESPACE

    kubectl get deployment/${DEPLOYMENT_NAME} --context ${CONTEXT} -n ${NAMESPACE}
    -o yaml

    ```'
  name: get_deployment_workload_details_for_deployment_name_and_add_to_report
- command: 'kubectl get deployment/${DEPLOYMENT_NAME} --context ${CONTEXT} -n ${NAMESPACE}
    -o json | jq ''.status | {desired_replicas: .replicas, ready_replicas: (.readyReplicas
    // 0), missing_replicas: ((.replicas // 0) - (.readyReplicas // 0)), unavailable_replicas:
    (.unavailableReplicas // 0), available_condition: (if any(.conditions[]; .type
    == "Available") then (.conditions[] | select(.type == "Available")) else "Condition
    not available" end), progressing_condition: (if any(.conditions[]; .type == "Progressing")
    then (.conditions[] | select(.type == "Progressing")) else "Condition not available"
    end)}'''
  doc_links: '

    - [Kubernetes kubectl explain Deployment](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#explain){:target="_blank"}

    - [Kubernetes kubectl scale Command](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#scale){:target="_blank"}

    - [Kubernetes JSON Path Support](https://kubernetes.io/docs/reference/kubectl/jsonpath){:target="_blank"}

    - [jq Documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command retrieves information about a specific deployment in Kubernetes,
    including the number of desired replicas, ready replicas, missing replicas, unavailable
    replicas, and the availability and progression conditions. It uses JSON output
    and the jq tool to format the data.
  multi_line_details: "```bash\n# Set the variables for deployment name, context and\
    \ namespace\nDEPLOYMENT_NAME=\"example-deployment\"\nCONTEXT=\"example-context\"\
    \nNAMESPACE=\"example-namespace\"\n\n# Get the deployment information in JSON\
    \ format and pipe it to jq for better output formatting\nkubectl get deployment/${DEPLOYMENT_NAME}\
    \ --context ${CONTEXT} -n ${NAMESPACE} -o json | \njq '.status | {\n  desired_replicas:\
    \ .replicas, \n  ready_replicas: (.readyReplicas // 0), \n  missing_replicas:\
    \ ((.replicas // 0) - (.readyReplicas // 0)), \n  unavailable_replicas: (.unavailableReplicas\
    \ // 0), \n  available_condition: (if any(.conditions[]; .type == \"Available\"\
    ) then (.conditions[] | select(.type == \"Available\")) else \"Condition not available\"\
    \ end), \n  progressing_condition: (if any(.conditions[]; .type == \"Progressing\"\
    ) then (.conditions[] | select(.type == \"Progressing\")) else \"Condition not\
    \ available\" end)\n}'\n```\nThis multi-line command sets the variables for deployment\
    \ name, context, and namespace, then uses the `kubectl` command to get deployment\
    \ information in JSON format. It pipes the output to `jq` for better formatting\
    \ and parses the status of the deployment, including desired replicas, ready replicas,\
    \ missing replicas, unavailable replicas, available condition, and progressing\
    \ condition.\nAlways remember to replace `example-deployment`, `example-context`,\
    \ and `example-namespace` with your actual deployment name, context, and namespace."
  name: troubleshoot_deployment_replicas_for_deployment_name
- command: 'kubectl get events --context ${CONTEXT} -n ${NAMESPACE} -o json | jq ''(now
    - (60*60)) as $time_limit | [ .items[] | select(.type != "Warning" and (.involvedObject.kind
    == "Deployment" or .involvedObject.kind == "ReplicaSet" or .involvedObject.kind
    == "Pod") and (.involvedObject.name | tostring | contains("${DEPLOYMENT_NAME}")))
    | {kind: .involvedObject.kind, count: .count, name: .involvedObject.name, reason:
    .reason, message: .message, firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp,
    duration: (if (((.lastTimestamp | fromdateiso8601) - (.firstTimestamp | fromdateiso8601))
    == 0) then 1 else (((.lastTimestamp | fromdateiso8601) - (.firstTimestamp | fromdateiso8601))/60)
    end) } ] | group_by([.kind, .name]) | map({kind: .[0].kind, name: .[0].name, count:
    (map(.count) | add), reasons: map(.reason) | unique, messages: map(.message) |
    unique, average_events_per_minute: (if .[0].duration == 1 then 1 else ((map(.count)
    | add)/.[0].duration ) end),firstTimestamp: map(.firstTimestamp | fromdateiso8601)
    | sort | .[0] | todateiso8601, lastTimestamp: map(.lastTimestamp | fromdateiso8601)
    | sort | reverse | .[0] | todateiso8601})'''
  doc_links: '

    - [Kubernetes Events documentation](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [Kubernetes Statistics calculation documentation](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#top_deployment_object){:target="_blank"}'
  explanation: This command retrieves events from a Kubernetes cluster, filters them
    based on certain criteria, and then organizes and calculates statistics about
    the events for specific deployment objects.
  multi_line_details: "```shell\n# Set the context for the kubectl command to the\
    \ value of the CONTEXT variable\nkubectl config use-context ${CONTEXT}\n\n# Get\
    \ events from the namespace specified in the NAMESPACE variable in JSON format\
    \ and pipe the output to the jq command\nkubectl get events -n ${NAMESPACE} -o\
    \ json | \n\n# Utilize the jq command to transform the JSON output\njq '(now -\
    \ (60*60)) as $time_limit |\n\n# Create an array of items based on certain criteria\
    \ such as type, involvedObject kind, and deployment name\n[ .items[] | \n    select(\n\
    \        .type != \"Warning\" and \n        (.involvedObject.kind == \"Deployment\"\
    \ or .involvedObject.kind == \"ReplicaSet\" or .involvedObject.kind == \"Pod\"\
    ) and \n        (.involvedObject.name | tostring | contains(\"${DEPLOYMENT_NAME}\"\
    ))\n    ) | \n\n    # Select specific fields to include in the final output\n\
    \    {kind: .involvedObject.kind, count: .count, name: .involvedObject.name, reason:\
    \ .reason, message: .message, firstTimestamp: .firstTimestamp, lastTimestamp:\
    \ .lastTimestamp, \n        duration: (if (((.lastTimestamp | fromdateiso8601)\
    \ - (.firstTimestamp | fromdateiso8601)) == 0) then 1 else (((.lastTimestamp |\
    \ fromdateiso8601) - (.firstTimestamp | fromdateiso8601))/60) end) } ] | \n\n\
    # Group the items by kind and name\ngroup_by([.kind, .name]) | \n\n# Map the grouped\
    \ items and calculate aggregate values for each group\nmap({kind: .[0].kind, name:\
    \ .[0].name, count: (map(.count) | add), reasons: map(.reason) | unique, messages:\
    \ map(.message) | unique, average_events_per_minute: (if .[0].duration == 1 then\
    \ 1 else ((map(.count) | add)/.[0].duration ) end),\n    firstTimestamp: map(.firstTimestamp\
    \ | fromdateiso8601) | sort | .[0] | todateiso8601,\n    lastTimestamp: map(.lastTimestamp\
    \ | fromdateiso8601) | sort | reverse | .[0] | todateiso8601})'\n```"
  name: check_deployment_event_anomalies_for_deployment_name
