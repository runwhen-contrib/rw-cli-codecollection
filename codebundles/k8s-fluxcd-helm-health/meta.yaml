commands:
- command: kubectl get ${RESOURCE_NAME} -n ${NAMESPACE} --context ${CONTEXT}
  doc_links: '

    - [Kubectl get documentation](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#kubectl-get){:target="_blank"}

    - [Kubernetes resource names](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/){:target="_blank"}

    - [Kubernetes namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubectl contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}'
  explanation: 'This command is used to retrieve information about a specific resource
    in a Kubernetes cluster. Let me break it down for you:


    - "kubectl" is the command line tool used to interact with Kubernetes clusters.

    - "get" is the action we want to perform, which in this case is retrieving information
    about a resource.

    - "${RESOURCE_NAME}" is the name of the resource you want to retrieve information
    about. For example, it could be "pods", "services", "deployments", etc.

    - "-n ${NAMESPACE}" specifies the namespace in which the resource is located.
    A namespace is a way to organize and isolate resources within a cluster.

    - "--context ${CONTEXT}" specifies the context, or the cluster configuration,
    that you want to use for this operation. If you are working with multiple Kubernetes
    clusters, you can use different contexts to switch between them.


    So, when you run this command, it will retrieve information about the specified
    resource in the specified namespace within the specified cluster context. This
    can be very useful for monitoring and troubleshooting your applications running
    in a Kubernetes environment.'
  multi_line_details: '# Set the kubernetes context to use

    kubectl config use-context ${CONTEXT}


    # Get the resource information from a specific namespace

    kubectl get ${RESOURCE_NAME} -n ${NAMESPACE}'
  name: list_all_available_fluxcd_helmreleases_in_namespace_namespace
- command: 'kubectl get ${RESOURCE_NAME} -n ${NAMESPACE} -o=jsonpath="{range .items[*]}{''\nName:
    ''}{@.metadata.name}{''\nlastAppliedRevision:''}{@.status.lastAppliedRevision}{''\nlastAttemptedRevision:''}{@.status.lastAttemptedRevision}{''\n---''}{end}"
    --context ${CONTEXT} || true'
  doc_links: '

    - [Understanding Kubernetes resource naming](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/){:target="_blank"}

    - [Using Kubernetes namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [JSONPath syntax](https://kubernetes.io/docs/reference/kubectl/jsonpath/){:target="_blank"}'
  explanation: 'This command is used to retrieve information about a specific resource
    within a particular Kubernetes namespace. Let''s break it down step by step.


    1. kubectl get: This is the command-line tool used to interact with the Kubernetes
    API and perform various operations, such as retrieving information about resources.


    2. ${RESOURCE_NAME}: This placeholder refers to the type of Kubernetes resource
    you want to retrieve information about, such as pods, services, deployments, etc.
    You would replace ${RESOURCE_NAME} with the actual name of the resource you''re
    interested in, such as "pods" or "services".


    3. -n ${NAMESPACE}: This specifies the namespace in which the resource is located.
    Namespaces are used to organize and isolate resources within a Kubernetes cluster.
    Replace ${NAMESPACE} with the actual name of the namespace you want to target.


    4. -o=jsonpath="{range .items[*]}{''\nName: ''}{@.metadata.name}{''\nlastAppliedRevision:''}{@.status.lastAppliedRevision}{''\nlastAttemptedRevision:''}{@.status.lastAttemptedRevision}{''\n---''}{end}"
    : This part of the command uses JSONPath to format the output of the `kubectl
    get` command. It extracts specific fields from the retrieved resource objects,
    such as name, lastAppliedRevision, and lastAttemptedRevision, and organizes them
    into a custom format. For example, it will display the name of the resource and
    its last applied and attempted revisions.


    5. --context ${CONTEXT}: This specifies the context to use for the operation.
    Contexts in Kubernetes are used to switch between different clusters and user
    identities. Replace ${CONTEXT} with the actual name of the context you want to
    use.


    6. || true: This is a safety feature that ensures that the command will not return
    an error if the resource or namespace does not exist. It essentially allows the
    command to fail gracefully without causing issues.


    In summary, this command is a way to retrieve specific information about a particular
    resource within a Kubernetes namespace and format the output using JSONPath. As
    you continue to work with Kubernetes, you will become more familiar with these
    types of commands and how to customize them for different use cases.'
  multi_line_details: '```bash

    # Set the resource name, namespace, and context for the kubectl command

    RESOURCE_NAME="pods"

    NAMESPACE="my-namespace"

    CONTEXT="my-kube-context"


    # Use kubectl command to get specific information from the specified resource
    and namespace in JSON format

    # The -o=jsonpath flag allows us to format the output using a custom template


    kubectl get ${RESOURCE_NAME} -n ${NAMESPACE} -o=jsonpath="{range .items[*]}{''\nName:
    ''}{@.metadata.name}{''\nlastAppliedRevision:''}{@.status.lastAppliedRevision}{''\nlastAttemptedRevision:''}{@.status.lastAttemptedRevision}{''\n---''}{end}"
    --context ${CONTEXT} || true

    # If the kubectl command fails, the "|| true" at the end ensures that it does
    not affect the overall execution of the script.

    ```'
  name: fetch_installed_fluxcd_helmrelease_versions_in_namespace_namespace
- command: 'kubectl get ${RESOURCE_NAME} -n ${NAMESPACE} -o json --context ${CONTEXT}
    | jq -r ''.items[] | select(.status.lastAppliedRevision!=.status.lastAttemptedRevision)
    | "Name: " + .metadata.name + " Last Attempted Version: " + .status.lastAttemptedRevision
    + " Last Applied Revision: " + .status.lastAppliedRevision'''
  doc_links: '

    - [kubectl Resource Management](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [jq Manual](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: 'This command is used to get information about a specific resource
    in a Kubernetes cluster. Let''s break it down:


    - `kubectl`: This is the command-line tool for interacting with Kubernetes clusters.


    - `get`: This is the action we want to perform, in this case, retrieve information
    about a resource.


    - `${RESOURCE_NAME}`: This is where you specify the type of resource you are interested
    in, such as pods, services, deployments, etc.


    - `-n ${NAMESPACE}`: This specifies the namespace in which the resource is located.
    Namespaces are used to organize and isolate resources within a cluster.


    - `-o json`: This option tells Kubernetes to output the information in JSON format.


    - `--context ${CONTEXT}`: This specifies the context or configuration to use for
    the command, usually referring to a specific cluster in your environment.


    - `| jq -r ''.items[] | select(.status.lastAppliedRevision!=.status.lastAttemptedRevision)
    | "Name: " + .metadata.name + " Last Attempted Version: " + .status.lastAttemptedRevision
    + " Last Applied Revision: " + .status.lastAppliedRevision''`: This part of the
    command takes the output of the previous command and applies a filter using the
    `jq` tool to display only specific information. It selects items where the last
    applied revision is not equal to the last attempted revision, and then formats
    and prints out the name of the resource along with its last attempted and last
    applied revisions.


    In summary, this command allows you to retrieve and display specific information
    about a Kubernetes resource in a particular namespace and context, while filtering
    the data to show only the relevant details.'
  multi_line_details: '# Step 1: Use kubectl to get the resource with the given RESOURCE_NAME
    in the specified NAMESPACE and output it as JSON,

    # using the specified context

    kubectl get ${RESOURCE_NAME} -n ${NAMESPACE} -o json --context ${CONTEXT}


    # Step 2: Pipe the output of the previous command to jq, a lightweight and flexible
    command-line JSON processor,

    # which will filter the .items array to only include resources where the lastAppliedRevision
    is different from the lastAttemptedRevision

    | jq -r ''.items[] | select(.status.lastAppliedRevision!=.status.lastAttemptedRevision)
    |

    "Name: " + .metadata.name + " Last Attempted Version: " + .status.lastAttemptedRevision
    + " Last Applied Revision: " + .status.lastAppliedRevision'''
  name: fetch_mismatched_fluxcd_helmrelease_version_in_namespace_namespace
- command: 'kubectl get ${RESOURCE_NAME} -n ${NAMESPACE} -o=jsonpath="{range .items[?(@.status.conditions[].status==''False'')]}{''-----\nName:
    ''}{@.metadata.name}{''\n''}{@.status.conditions[*].message}{''\n''}{end}" --context
    ${CONTEXT} || true'
  doc_links: '

    - [kubectl get command - Kubernetes Documentation](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [JSONPath support in kubectl - Kubernetes Documentation](https://kubernetes.io/docs/reference/kubectl/jsonpath/){:target="_blank"}

    - [Kubernetes Namespaces - Kubernetes Documentation](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubectl context - Kubernetes Documentation](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/){:target="_blank"}'
  explanation: 'This command is used to get and display certain resources in a Kubernetes
    cluster. Let''s break it down step by step:


    - `kubectl`: This is the command-line tool used to interact with Kubernetes clusters.

    - `get`: This is the action we want to perform, which is getting information about
    certain resources.

    - `${RESOURCE_NAME}`: Replace this with the name of the resource you want to retrieve,
    such as Pods, Deployments, or Services.

    - `-n ${NAMESPACE}`: This flag specifies the namespace in which the resource is
    located. Replace `${NAMESPACE}` with the actual namespace name.

    - `-o=jsonpath="{range .items[?(@.status.conditions[].status==''False'')]}{''-----\nName:
    ''}{@.metadata.name}{''\n''}{@.status.conditions[*].message}{''\n''}{end}"`: This
    flag tells Kubernetes how we want the data to be formatted when it''s outputted.
    It''s using JSONPath to filter and format the output according to our needs.

    - `--context ${CONTEXT}`: This flag specifies the context/cluster where the command
    should be executed. Replace `${CONTEXT}` with the actual context name.

    - `|| true`: This part of the command says that if the previous command fails,
    proceed and return a success status.


    So in summary, this command fetches resource(s) of a given type within a specific
    namespace and formats the output according to a specified template using JSONPath.
    This will help you as an engineer to gather specific information about resources
    in your Kubernetes clusters.'
  multi_line_details: "```yaml\n# Set the resource name, namespace, and context you\
    \ want to use\nRESOURCE_NAME=\"pods\" \nNAMESPACE=\"default\"\nCONTEXT=\"my-cluster\"\
    \n\n# Use kubectl to get the pods from the specified namespace in the specific\
    \ context\nkubectl get ${RESOURCE_NAME} -n ${NAMESPACE} \\\n  -o=jsonpath=\"{range\
    \ .items[?(@.status.conditions[].status=='False')]}{'-----\\nName: '}{@.metadata.name}{'\\\
    n'}{@.status.conditions[*].message}{'\\n'}{end}\" \\\n  --context ${CONTEXT} ||\
    \ true\n```\n\nIn this multi-line command, we set the variables RESOURCE_NAME,\
    \ NAMESPACE, and CONTEXT with the values we want to use. Then, we use the kubectl\
    \ command to retrieve the pods from the specified namespace in the chosen context,\
    \ using the output in jsonpath format, applying a filter to check for specific\
    \ status conditions. The `|| true` at the end ensures that the command does not\
    \ return an error even if no resources are found or there is any other issue."
  name: fetch_fluxcd_helmrelease_error_messages_in_namespace_namespace
- command: 'namespace="${NAMESPACE}" context="${CONTEXT}"; helm_releases=$(kubectl
    get ${RESOURCE_NAME} -n "$namespace" --context "$context" -o json | jq -r ''.items[]
    | .metadata.name''); echo "$helm_releases" | while IFS= read -r release; do chart_details=$(kubectl
    get ${RESOURCE_NAME} "$release" -n "$namespace" --context "$context" -o json |
    jq -r ''.spec.chart.spec // empty''); if [[ -n "$chart_details" ]]; then chart_kind=$(echo
    "$chart_details" | jq -r ''.sourceRef.kind // empty''); chart_name=$(echo "$chart_details"
    | jq -r ''.chart // empty''); chart_source_name=$(echo "$chart_details" | jq -r
    ''.sourceRef.name // empty''); chart_namespace=$(echo "$chart_details" | jq -r
    ''.sourceRef.namespace // empty''); chart_version=$(echo "$chart_details" | jq
    -r ''.version // "N/A"''); if [[ "$chart_kind" == "HelmRepository" && -n "$chart_name"
    && -n "$chart_namespace" ]]; then repo_url=$(kubectl get helmrepositories.source.toolkit.fluxcd.io
    "$chart_source_name" -n "$chart_namespace" --context "$context" -o json | jq -r
    ''.spec.url // empty''); if [[ -n "$repo_url" ]]; then temp_repo_name="$chart_source_name-temp-$release";
    add_repo=$(helm repo add "$temp_repo_name" "$repo_url"); available_chart_version=$(helm
    search repo "$temp_repo_name"/"$chart_name" --version ">$chart_version" --output
    json | jq -r ''.[].version''); if [[ -n "$available_chart_version" ]]; then sorted_versions=($(echo
    "\${available_chart_version[@]}" | tr '' '' ''\n'' | sort -V)); available_version=\${sorted_versions[-1]};
    version_update_available="True"; else available_version="N/A"; version_update_available="False";
    fi; remove_repo=$(helm repo remove "$temp_repo_name"); else available_version="N/A";
    version_update_available="False"; fi; else available_version="N/A"; version_update_available="False";
    fi; else chart_name="N/A"; chart_namespace="N/A"; chart_version="N/A"; available_version="N/A";
    version_update_available="False"; fi; echo "Release: $release | Chart: $chart_namespace/$chart_name
    | Installed Version: $chart_version | Available Update: $version_update_available
    | Available Version: $available_version"; done'
  doc_links: '

    '
  explanation: "This command is a shell script that utilizes the `kubectl` and `helm`\
    \ commands to gather information about Helm releases within a Kubernetes cluster.\
    \ Let's break it down step by step.\n\nFirst, the variables `namespace` and `context`\
    \ are set using the values contained in the environment variable `$NAMESPACE`\
    \ and `$CONTEXT`.\n\nNext, the script retrieves a list of Helm releases in the\
    \ specified namespace by running the `kubectl get` command with the `-o json`\
    \ option, which formats the output as JSON. The results are then parsed using\
    \ `jq` to extract the `metadata.name` of each release.\n\nFor each release, the\
    \ script retrieves details about the Helm chart using the `kubectl get` command\
    \ again, this time obtaining information from the `spec.chart.spec` field, if\
    \ available. This includes details such as the kind of chart (`HelmRepository`),\
    \ the chart name, source name, namespace, and version.\n\nIf the chart is sourced\
    \ from a Helm repository, the script extracts the repository URL and uses `helm\
    \ repo add` and `helm search repo` commands to check for available updates. If\
    \ an update is found, the latest version is determined and compared to the installed\
    \ version. \n\nFinally, the script prints out information about each release including\
    \ the release name, chart namespace/name, installed version, whether an update\
    \ is available, and the available version.\n\nIn essence, this script automates\
    \ the process of checking for available updates for Helm releases within a Kubernetes\
    \ cluster and provides relevant information for each release. As an engineer using\
    \ Kubernetes daily, understanding and familiarizing yourself with commands like\
    \ these will be beneficial for managing applications and deployments within your\
    \ Kubernetes environment."
  multi_line_details: "```bash\n# Define the context and namespace to be used in the\
    \ commands below\nnamespace=\"${NAMESPACE}\" \ncontext=\"${CONTEXT}\" \n\n# Retrieve\
    \ the list of releases for a specific resource in the defined namespace and context\n\
    helm_releases=$(kubectl get ${RESOURCE_NAME} -n \"$namespace\" --context \"$context\"\
    \ -o json | jq -r '.items[] | .metadata.name')\n\n# Iterate over each release\
    \ obtained\necho \"$helm_releases\" | while IFS= read -r release; do\n  \n  #\
    \ Access details of the chart for the current release\n  chart_details=$(kubectl\
    \ get ${RESOURCE_NAME} \"$release\" -n \"$namespace\" --context \"$context\" -o\
    \ json | jq -r '.spec.chart.spec // empty')\n  \n  # Check if chart details are\
    \ available and proceed accordingly\n  if [[ -n \"$chart_details\" ]]; then\n\
    \    chart_kind=$(echo \"$chart_details\" | jq -r '.sourceRef.kind // empty')\n\
    \    chart_name=$(echo \"$chart_details\" | jq -r '.chart // empty')\n    chart_source_name=$(echo\
    \ \"$chart_details\" | jq -r '.sourceRef.name // empty')\n    chart_namespace=$(echo\
    \ \"$chart_details\" | jq -r '.sourceRef.namespace // empty')\n    chart_version=$(echo\
    \ \"$chart_details\" | jq -r '.version // \"N/A\"')\n    \n    # If the chart\
    \ kind is HelmRepository and required details are available, proceed to identify\
    \ the available version\n    if [[ \"$chart_kind\" == \"HelmRepository\" && -n\
    \ \"$chart_name\" && -n \"$chart_namespace\" ]]; then\n      repo_url=$(kubectl\
    \ get helmrepositories.source.toolkit.fluxcd.io \"$chart_source_name\" -n \"$chart_namespace\"\
    \ --context \"$context\" -o json | jq -r '.spec.url // empty')\n\n      # If the\
    \ repository URL is available, apply further processing\n      if [[ -n \"$repo_url\"\
    \ ]]; then\n        temp_repo_name=\"$chart_source_name-temp-$release\"\n    \
    \    add_repo=$(helm repo add \"$temp_repo_name\" \"$repo_url\")\n        available_chart_version=$(helm\
    \ search repo \"$temp_repo_name\"/\"$chart_name\" --version \">$chart_version\"\
    \ --output json | jq -r '.[].version')\n        \n        # Identify the latest\
    \ available version and check if an update is available\n        if [[ -n \"$available_chart_version\"\
    \ ]]; then\n            sorted_versions=($(echo \"${available_chart_version[@]}\"\
    \ | tr ' ' '\\n' | sort -V))\n            available_version=${sorted_versions[-1]}\n\
    \            version_update_available=\"True\"\n        else\n            available_version=\"\
    N/A\"\n            version_update_available=\"False\"\n        fi\n        \n\
    \        remove_repo=$(helm repo remove \"$temp_repo_name\")\n      else\n   \
    \     available_version=\"N/A\"\n        version_update_available=\"False\"\n\
    \      fi\n    else\n      available_version=\"N/A\"\n      version_update_available=\"\
    False\"\n    fi\n  else\n    chart_name=\"N/A\"\n    chart_namespace=\"N/A\"\n\
    \    chart_version=\"N/A\"\n    available_version=\"N/A\"\n    version_update_available=\"\
    False\"\n  fi\n  \n  # Print the details of the release, including available updates\
    \ and versions\n  echo \"Release: $release | Chart: $chart_namespace/$chart_name\
    \ | Installed Version: $chart_version | Available Update: $version_update_available\
    \ | Available Version: $available_version\"\ndone\n```"
  name: check_for_available_helm_chart_updates_in_namespace_namespace
