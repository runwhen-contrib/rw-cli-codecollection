commands:
- command: 'NAMESPACE="${NAMESPACE}";CONTEXT="${CONTEXT}";ingresses=$(kubectl get
    ingress -n "$NAMESPACE" --context "$CONTEXT" -o jsonpath=''{range .items[*]}{.metadata.name}{"\n"}{end}'');for
    ingress in $ingresses;do echo "Ingress: $ingress";health_status="NA";backend_services=$(kubectl
    get ingress "$ingress" -n "$NAMESPACE" --context "$CONTEXT" -o jsonpath=''{range
    .spec.rules[*].http.paths[*]}{.backend.service.name}{"|"}{.backend.service.port.number}{"\n"}{end}'');while
    IFS=''|'' read -r service port;do echo "Backend Service: $service, Port: $port";target_ports=$(kubectl
    get service "$service" -n "$NAMESPACE" --context "$CONTEXT" -o jsonpath="{.spec.ports[?(@.port==$port)].targetPort}");service_exists=$(kubectl
    get service "$service" -n "$NAMESPACE" --context "$CONTEXT" -ojsonpath=''{.metadata.name}'');if
    [ -z "$service_exists" ];then health_status="Unhealthy";echo "Error: Service $service
    does not exist";echo "Next Step: Check namespace $NAMESPACE for service name $service.";continue;else
    selectors=$(kubectl get svc "$service" -n "$NAMESPACE" --context "$CONTEXT" -o
    jsonpath=''{.spec.selector}'');label_selector="";for key in $(echo $selectors
    | jq -r ''keys[]'');do value=$(echo $selectors | jq -r --arg key "$key" ''.[$key]'');label_selector="\${label_selector}\${key}=\${value},";done;label_selector=\${label_selector::-1};found_owner=0;for
    kind in deployment statefulset daemonset;do matching_owners=$(kubectl get $kind
    -n "$NAMESPACE" --context "$CONTEXT" -l "$label_selector" -o jsonpath=''{.items[*].metadata.name}'');if
    [ -n "$matching_owners" ];then for owner in $matching_owners;do echo "Owner Kind:
    $kind";echo "Owner Name: $owner";found_owner=1;done;fi;done;if [ "$found_owner"
    == 0 ];then echo "Error: No matching deployment, statefulset, or daemonset found
    to match label selector \`"$label_selector"\`";echo "Next Steps:\n- Check namespace
    \`"$NAMESPACE"\` for deployment, statefulset, or daemonset with labels that match
    \`"$label_selector"\`";fi;port_found="No";associated_pods=$(kubectl get pods -n
    "$NAMESPACE" --context "$CONTEXT" -l "$label_selector" -o jsonpath=''{.items[*].metadata.name}'');for
    pod in $associated_pods;do container_ports=$(kubectl get pod "$pod" -n "$NAMESPACE"
    --context "$CONTEXT" -o jsonpath=''{.spec.containers[*].ports[*].containerPort}'');for
    target_port in $target_ports;do if echo "$container_ports" | grep -wq "$target_port";then
    port_found="Yes";break;fi;done;done;if [ "$port_found" = "No" ];then health_status="Unhealthy";echo
    "Warning: targetPort $target_ports of service $service is not found as a containerPort
    in associated pods";else health_status="Healthy";fi;endpoint_pods=$(kubectl get
    endpoints "$service" -n "$NAMESPACE" --context "$CONTEXT" -ojsonpath=''{range
    .subsets[*].addresses[*]}- Pod Name: {.targetRef.name}\n Pod IP: {.ip}\n{end}'');if
    [ -z "$endpoint_pods" ];then health_status="Unhealthy";echo "Error: Endpoint for
    service \`"$service"\` does not have any running pods"; echo "Next Steps:\n- Troubleshoot
    Container Restarts in Namespace \`"$NAMESPACE"\` \n- Troubleshoot Pending Pods
    In Namespace \`"$NAMESPACE"\`\n- Troubleshoot Failed Pods In Namespace \`"$NAMESPACE"\`";else
    echo "Endpoint Pod:";echo "$endpoint_pods";health_status="Healthy";fi;fi;done<<<"$backend_services";echo
    "Health Status: $health_status";echo "------------";done'
  doc_links: '

    '
  explanation: 'This is a command that is used in Kubernetes to retrieve and analyze
    the health status of ingresses and their associated backend services in a specified
    namespace and context.


    Let''s break down the command step by step:

    1. The first few lines are setting up variables for the namespace and context
    to be used in subsequent commands.


    2. Then, the script uses the `kubectl get ingress` command to retrieve a list
    of all ingresses in the specified namespace and context, storing the names in
    the `ingresses` variable.


    3. Next, the script loops through each ingress in the `ingresses` list and retrieves
    information about the backend services associated with each ingress.


    4. For each backend service, it checks if the service exists in the specified
    namespace, and if not, it sets the `health_status` variable to "Unhealthy" and
    provides an error message.


    5. If the service exists, the script retrieves the labels associated with the
    service and searches for matching deployments, statefulsets, or daemonsets within
    the namespace. If a matching owner is found, it prints out the owner kind and
    name.


    6. It then checks if the target ports of the backend service match any container
    ports of the associated pods. If not, it sets the `health_status` variable to
    "Unhealthy" and provides a warning message.


    7. The script also checks if the endpoint for the service has running pods, and
    if not, it sets the `health_status` variable to "Unhealthy" and provides troubleshooting
    steps.


    8. Finally, the script prints out the health status of the backend service and
    moves on to the next one.


    Overall, this command is useful for analyzing the health and status of ingresses
    and their associated backend services within a Kubernetes environment. It provides
    detailed information and troubleshooting steps to ensure that everything is functioning
    properly.'
  multi_line_details: "```bash\n# Set the NAMESPACE and CONTEXT variables\nNAMESPACE=\"\
    ${NAMESPACE}\"\nCONTEXT=\"${CONTEXT}\"\n\n# Get all the ingresses in a namespace\
    \ and iterate through the list\ningresses=$(kubectl get ingress -n \"$NAMESPACE\"\
    \ --context \"$CONTEXT\" -o jsonpath='{range .items[*]}{.metadata.name}{\"\\n\"\
    }{end}')\nfor ingress in $ingresses; do\n    echo \"Ingress: $ingress\"\n    health_status=\"\
    NA\"\n\n    # Get backend services associated with the ingress\n    backend_services=$(kubectl\
    \ get ingress \"$ingress\" -n \"$NAMESPACE\" --context \"$CONTEXT\" -o jsonpath='{range\
    \ .spec.rules[*].http.paths[*]}{.backend.service.name}{\"|\"}{.backend.service.port.number}{\"\
    \\n\"}{end}')\n\n    # Iterate through each backend service and its port\n   \
    \ while IFS='|' read -r service port; do\n        echo \"Backend Service: $service,\
    \ Port: $port\"\n        target_ports=$(kubectl get service \"$service\" -n \"\
    $NAMESPACE\" --context \"$CONTEXT\" -o jsonpath=\"{.spec.ports[?(@.port==$port)].targetPort}\"\
    )\n        service_exists=$(kubectl get service \"$service\" -n \"$NAMESPACE\"\
    \ --context \"$CONTEXT\" -ojsonpath='{.metadata.name}')\n\n        # Check if\
    \ the service exists\n        if [ -z \"$service_exists\" ]; then\n          \
    \  health_status=\"Unhealthy\"\n            echo \"Error: Service $service does\
    \ not exist\"\n            echo \"Next Step: Check namespace $NAMESPACE for service\
    \ name $service.\"\n            continue\n        else\n            selectors=$(kubectl\
    \ get svc \"$service\" -n \"$NAMESPACE\" --context \"$CONTEXT\" -o jsonpath='{.spec.selector}')\n\
    \            label_selector=\"\"\n            \n            # Construct label\
    \ selector to find the owner of the service\n            for key in $(echo $selectors\
    \ | jq -r 'keys[]'); do\n                value=$(echo $selectors | jq -r --arg\
    \ key \"$key\" '.[$key]')\n                label_selector=\"\\${label_selector}\\\
    ${key}=\\${value},\"\n            done\n\n            label_selector=\\${label_selector::-1}\n\
    \            found_owner=0\n            \n            # Find the owner (deployment,\
    \ statefulset, or daemonset) associated with the service\n            for kind\
    \ in deployment statefulset daemonset; do\n                matching_owners=$(kubectl\
    \ get $kind -n \"$NAMESPACE\" --context \"$CONTEXT\" -l \"$label_selector\" -o\
    \ jsonpath='{.items[*].metadata.name}')\n                \n                if\
    \ [ -n \"$matching_owners\" ]; then\n                    for owner in $matching_owners;\
    \ do\n                        echo \"Owner Kind: $kind\"\n                   \
    \     echo \"Owner Name: $owner\"\n                        found_owner=1\n   \
    \                 done\n                fi\n            done\n\n            #\
    \ If no matching owner found, display error message\n            if [ \"$found_owner\"\
    \ == 0 ]; then\n                echo \"Error: No matching deployment, statefulset,\
    \ or daemonset found to match label selector \\`\"$label_selector\"\\`\"\n   \
    \             echo \"Next Steps:\\n- Check namespace \\`\"$NAMESPACE\"\\` for\
    \ deployment, statefulset, or daemonset with labels that match \\`\"$label_selector\"\
    \\`\"\n            fi\n            \n            port_found=\"No\"\n         \
    \   associated_pods=$(kubectl get pods -n \"$NAMESPACE\" --context \"$CONTEXT\"\
    \ -l \"$label_selector\" -o jsonpath='{.items[*].metadata.name}')\n          \
    \  \n            # Check if the target port is found as a container port in associated\
    \ pods\n            for pod in $associated_pods; do\n                container_ports=$(kubectl\
    \ get pod \"$pod\" -n \"$NAMESPACE\" --context \"$CONTEXT\" -o jsonpath='{.spec.containers[*].ports[*].containerPort}')\n\
    \                \n                for target_port in $target_ports; do\n    \
    \                if echo \"$container_ports\" | grep -wq \"$target_port\"; then\n\
    \                        port_found=\"Yes\"\n                        break\n \
    \                   fi\n                done\n            done\n\n           \
    \ # If the target port is not found as a container port, set health status to\
    \ Unhealthy\n            if [ \"$port_found\" = \"No\" ]; then\n             \
    \   health_status=\"Unhealthy\"\n                echo \"Warning: targetPort $target_ports\
    \ of service $service is not found as a containerPort in associated pods\"\n \
    \           else\n                health_status=\"Healthy\"\n            fi\n\n\
    \            # Get endpoint pods associated with the service\n            endpoint_pods=$(kubectl\
    \ get endpoints \"$service\" -n \"$NAMESPACE\" --context \"$CONTEXT\" -ojsonpath='{range\
    \ .subsets[*].addresses[*]}- Pod Name: {.targetRef.name}\\n Pod IP: {.ip}\\n{end}')\n\
    \n            # If there are no endpoint pods, set health status to Unhealthy\
    \ and display error message\n            if [ -z \"$endpoint_pods\" ]; then\n\
    \                health_status=\"Unhealthy\"\n                echo \"Error: Endpoint\
    \ for service \\`\"$service\"\\` does not have any running pods\"\n          \
    \      echo \"Next Steps:\\n- Troubleshoot Container Restarts in Namespace \\\
    `\"$NAMESPACE\"\\` \\n- Troubleshoot Pending Pods In Namespace \\`\"$NAMESPACE\"\
    `\\n- Troubleshoot Failed Pods In Namespace \\`\"$NAMESPACE\"\\`\"\n         \
    \   else\n                echo \"Endpoint Pod:\"\n                echo \"$endpoint_pods\"\
    \n                health_status=\"Healthy\"\n            fi\n        fi\n    done\
    \ <<< \"$backend_services\"\n\n    echo \"Health Status: $health_status\"\n  \
    \  echo \"------------\"\ndone\n```"
  name: fetch_ingress_object_health_in_namespace_namespace
- command: 'CONTEXT="${CONTEXT}"; NAMESPACE="${NAMESPACE}"; kubectl --context "${CONTEXT}"
    --namespace "${NAMESPACE}" get ingress -o json | jq -r ''.items[] | select(.status.loadBalancer.ingress)
    | .metadata.name as \$name | .status.loadBalancer.ingress[0].ip as \$ingress_ip
    | .spec.rules[]?.http.paths[]? | "\($name) \($ingress_ip) \(.backend.service.name)
    \(.backend.service.port.number)"'' | while read -r ingress_name ingress_ip service_name
    service_port; do kubectl --context "${CONTEXT}" --namespace "${NAMESPACE}" get
    svc "$service_name" -o json | jq --arg ingress_name "$ingress_name" --arg ingress_ip
    "$ingress_ip" --arg service_name "$service_name" --arg service_port "$service_port"
    -r ''if .spec.type == "LoadBalancer" then .status.loadBalancer.ingress[0].ip as
    $service_ip | if $ingress_ip and $service_ip and $service_ip != $ingress_ip then
    "WARNING: Ingress \($ingress_name) IP (\($ingress_ip)) differs from Service \($service_name)
    IP (\($service_ip))" else "OK: Ingress \($ingress_name) - Service \($service_name)
    is of type LoadBalancer with IP (\($service_ip))" end else "OK: Ingress \($ingress_name)
    - Service \($service_name) is of type \(.spec.type) on port \($service_port)"
    end''; done'
  doc_links: '

    - [Kubectl Get Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/){:target="_blank"}

    - [Json Output for Kubectl Get](https://kubernetes.io/docs/reference/kubectl/jsonpath/){:target="_blank"}

    - [JQ Command Documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: 'This command is used to retrieve information about ingresses and services
    in a Kubernetes cluster. Let''s break it down step by step.


    First, the variables CONTEXT and NAMESPACE are being set based on some external
    configuration. These variables will be used to specify the context and namespace
    for all subsequent kubectl commands.


    The main part of the command uses the kubectl tool to retrieve a list of ingresses
    in the specified context and namespace, and then formats the output as JSON using
    the ''-o json'' option. The ''jq'' command-line JSON processor is then used to
    filter and manipulate this JSON data.


    The jq command selects specific fields from the JSON output, such as the name
    of the ingress, its IP address, and the backend service name and port. It then
    pipes this information into a while loop, which reads each line of the filtered
    output and assigns the values to variables (ingress_name, ingress_ip, service_name,
    service_port).


    Within the while loop, another kubectl command is used to retrieve information
    about the specified service. The output of this command is also processed using
    jq to check if the service type is "LoadBalancer" and compare the IP addresses
    of the service and the ingress. Depending on the comparison, a different message
    is generated to indicate whether the configuration is correct or if there''s a
    potential issue.


    Overall, this command is quite complex and involves multiple levels of filtering
    and processing of Kubernetes resources to validate the configuration of ingresses
    and services in a given context and namespace. As an engineer learning to use
    Kubernetes daily, you would typically encounter commands like these when troubleshooting
    or validating the configuration of resources in your cluster. It''s important
    to familiarize yourself with tools like kubectl and jq, as well as the various
    Kubernetes resource types and their configurations.'
  multi_line_details: "```bash\n# Defining the variables for Context and Namespace\n\
    CONTEXT=\"${CONTEXT}\"\nNAMESPACE=\"${NAMESPACE}\"\n\n# Retrieving the ingress\
    \ resources in JSON format from the specified context and namespace\nkubectl --context\
    \ \"${CONTEXT}\" --namespace \"${NAMESPACE}\" get ingress -o json | \n  jq -r\
    \ '.items[] | select(.status.loadBalancer.ingress) | .metadata.name as \\$name\
    \ | .status.loadBalancer.ingress[0].ip as \\$ingress_ip | .spec.rules[]?.http.paths[]?\
    \ | \"\\($name) \\($ingress_ip) \\(.backend.service.name) \\(.backend.service.port.number)\"\
    ' | \n  while read -r ingress_name ingress_ip service_name service_port; do\n\n\
    \    # Retrieving the service resource in JSON format using the service name\n\
    \    kubectl --context \"${CONTEXT}\" --namespace \"${NAMESPACE}\" get svc \"\
    $service_name\" -o json | \n      jq --arg ingress_name \"$ingress_name\" --arg\
    \ ingress_ip \"$ingress_ip\" --arg service_name \"$service_name\" --arg service_port\
    \ \"$service_port\" -r '\n        if .spec.type == \"LoadBalancer\" then\n   \
    \       .status.loadBalancer.ingress[0].ip as $service_ip |\n          if $ingress_ip\
    \ and $service_ip and $service_ip != $ingress_ip then\n            \"WARNING:\
    \ Ingress \\($ingress_name) IP (\\($ingress_ip)) differs from Service \\($service_name)\
    \ IP (\\($service_ip))\"\n          else\n            \"OK: Ingress \\($ingress_name)\
    \ - Service \\($service_name) is of type LoadBalancer with IP (\\($service_ip))\"\
    \n          end\n        else\n          \"OK: Ingress \\($ingress_name) - Service\
    \ \\($service_name) is of type \\(.spec.type) on port \\($service_port)\"\n  \
    \      end'\n  done\n```"
  name: check_for_ingress_and_service_conflicts_in_namespace_namespace
