commands:
- command: kubectl exec statefulset/${STATEFULSET_NAME} --context=${CONTEXT} -n ${NAMESPACE}
    -- curl -s -o /dev/null -w "%{http_code}" localhost:8080/login
  doc_links: " \n\nHelpful Documentation Links:\n\n- [Kubernetes Docs: kubectl exec](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#exec):\
    \ This page explains how to use the `kubectl exec` command which is used in this\
    \ script\n- [Kubernetes Docs: Context and Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#contexts):\
    \ This page explains the concept of contexts and namespaces in Kubernetes, which\
    \ are both specified as arguments in this script.\n- [jq Manual](https://stedolan.github.io/jq/manual/):\
    \ Since jq is not mentioned in the script, this manual provides the necessary\
    \ details to understand how it works and how it can be incorporated in the script.\
    \  \n- [Curl: Understanding HTTP Responses](https://ec.haxx.se/usingcurl-http-responses.html):\
    \ This page digs deep into the concepts of understanding http responses, which\
    \ is done in this script with the `-w \"%{http_code}` argument. \n- [Introduction\
    \ to Services - NodePort](https://kubernetes.io/docs/tutorials/services/expose-intro/):\
    \ The target endpoint specified in the script is `localhost:8080/login`, so this\
    \ tutorial is a perfect fit to learn more about services and how they work within\
    \ Kubernetes clusters."
  explanation: '


    This command is used to run a curl command on a container that is part of a stateful
    set in a specified Kubernetes context and namespace. The command will send a request
    to the container''s localhost at port 8080, sending it to the /login resource.
    The output of the command will be the HTTP status code from the response. This
    can be useful for verifying that the application is running correctly within the
    Kubernetes cluster.'
  multi_line_details: "\n\n# Execute a command in a container in a pod of the specified\
    \ statefulset \n# Context and namespace are arguments necessary in utilizing the\
    \ Kubernetes cluster\nkubectl exec statefulset/${STATEFULSET_NAME} \\\n--context=${CONTEXT}\
    \ \\\n-n ${NAMESPACE} \\\n-- \\            # Runs the command after this on the\
    \ pod/container\ncurl -s -o /dev/null \\      # This sends an http request (-s\
    \ silent, -o output)\n-w \"%{http_code}\" \\          # This reads the http response.\n\
    localhost:8080/login         # This is the target endpoint."
  name: query_the_jenkins_kubernetes_workload_http_endpoint
- command: kubectl exec statefulset/${STATEFULSET_NAME} --context=${CONTEXT} -n ${NAMESPACE}
    -- curl -s localhost:8080/api/json?pretty=true --user $${JENKINS_SA_USERNAME.key}:$${JENKINS_SA_TOKEN.key}
  doc_links: " \n\n\n**Documentation Links:**\n- [Kubectl Cheat Sheet](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands):\
    \ A reference sheet of commands available for kubectl.\n- [StatefulSets Documentation](https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/#prerequisites):\
    \ Learn more about statefulsets. \n- [Curl Command Tutorial](https://curl.haxx.se/docs/manual.html):\
    \ Detailed guide on the usage of curl. \n- [Kubernetes Contexts & Namespaces](https://kubernetes.io/docs/tasks/administer-cluster/namespaces-walkthrough-demo/):\
    \ A demonstration of how contexts and namespaces work in Kubernetes."
  explanation: '


    Kubectl exec is a command that lets you execute commands inside a running Kubernetes
    pod. This command executes a curl command on a statefulset which has the name
    ${STATEFULSET_NAME} in the namespace ${NAMESPACE}, using the kubernetes context
    ${CONTEXT}. The curl command is aimed at localhost on port 8080. It sends user
    credentials to authenticate - these credentials are stored as environment variables
    with the keys JENKINS_SA_USERNAME and JENKINS_SA_TOKEN. The parameter pretty=true
    makes sure the response is formatted for easier reading.'
  multi_line_details: "\n\n#Execute a command against a statefulset resource in the\
    \ specified context and namespace \nkubectl exec \\\n    statefulset/${STATEFULSET_NAME}\
    \ \\ #Specifying the target resource name \n    --context=${CONTEXT} \\ #Name\
    \ of the current context\n    -n ${NAMESPACE} \\ #Specifying the desired namespace\n\
    \    -- curl -s localhost:8080/api/json?pretty=true \\ #Specifying command to\
    \ execute against the target resource  \n    --user $${JENKINS_SA_USERNAME.key}:$${JENKINS_SA_TOKEN.key}\
    \ \\ #Specifying username and token as authentication credentials    \n    #No\
    \ need for any further options as curl command will be executed against our target\
    \ resource"
  name: query_the_jenkins_kubernetes_workload_http_endpoint
- command: 'kubectl exec statefulset/${STATEFULSET_NAME} --context=${CONTEXT} -n ${NAMESPACE}
    -- curl -s localhost:8080/queue/api/json --user $${JENKINS_SA_USERNAME.key}:$${JENKINS_SA_TOKEN.key}
    | jq -r ''.items[] | select((.stuck == true) or (.blocked == true)) | "Why: "
    + .why + "\nBlocked: " + (.blocked|tostring) + "\nStuck: " + (.stuck|tostring)'''
  doc_links: '


    1. [Kubernetes Documentation for kubectl](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands)

    2. [Jenkins Documentation for Secrets](https://jenkins.io/doc/book/using/using-secrets/)

    3. [cURL Documentation](https://curl.haxx.se/docs/)

    4. [jq Manual](https://stedolan.github.io/jq/manual/)'
  explanation: "\n\nThis command is used to identify the cause of stuck or blocked\
    \ jobs in a Jenkins instance. The command calls the Jenkins API and filters out\
    \ stuck and/or blocked jobs, displaying the related \"why\" value as well as their\
    \ respective statuses - blocked and/or stuck. \n\nThe command consists of several\
    \ parts. The kubectl exec component enables the execution of a command within\
    \ the StatefulSet, identified by its name (${STATEFULSET_NAME}). The --context\
    \ flag specifies the Kubernetes context for the command's execution and the -n\
    \ ${NAMESPACE} flag defines the namespace. After that, the command itself comes\
    \ into play. It uses the curl utility, which connects to the Jenkins API at port\
    \ 8080 on localhost and uses the ${JENKINS_SA_USERNAME.key} and ${JENKINS_SA_TOKEN.key}\
    \ environment variables as credentials. Next, the output (in JSON format) is piped\
    \ through jq - a command-line tool used to filter and parse JSON data - to select\
    \ only what we need - stuck or blocked jobs and their why values."
  multi_line_details: "\n\n# Execute a curl command against the api of the specified\
    \ statefulset to retrieve stuck and blocked tasks\nkubectl exec \\\n  statefulset/${STATEFULSET_NAME}\
    \ \\\n  --context=${CONTEXT} \\\n  -n ${NAMESPACE} \\\n  -- curl -s localhost:8080/queue/api/json\
    \ \\\n  --user $${JENKINS_SA_USERNAME.key}:$${JENKINS_SA_TOKEN.key} \\\n| jq -r\
    \ '.items[] | select((.stuck == true) or (.blocked == true)) | \"Why: \" + .why\
    \ + \"\\nBlocked: \" + (.blocked|tostring) + \"\\nStuck: \" + (.stuck|tostring)'"
  name: query_for_stuck_jenkins_jobs
