commands:
- command: 'kubectl get events --field-selector type=Warning --context ${CONTEXT}
    -n ${NAMESPACE} -o json > $HOME/warning_events.json && cat $HOME/warning_events.json
    | jq -r ''[.items[] | {namespace: .involvedObject.namespace, kind: .involvedObject.kind,
    baseName: ((if .involvedObject.kind == "Pod" then (.involvedObject.name | split("-")[:-1]
    | join("-")) else .involvedObject.name end) // ""), count: .count, firstTimestamp:
    .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason, message: .message}]
    | group_by(.namespace, .kind, .baseName) | map({object: (.[0].namespace + "/"
    + .[0].kind + "/" + .[0].baseName), total_events: (reduce .[] as $event (0; .
    + $event.count)), summary_messages: (map(.message) | unique | join("; ")), oldest_timestamp:
    (map(.firstTimestamp) | sort | first), most_recent_timestamp: (map(.lastTimestamp)
    | sort | last)}) | map(select((now - ((.most_recent_timestamp | fromdateiso8601)))/60
    <= 30))'''
  doc_links: '

    - [Kubernetes warning events](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-kubectl-get-events){:target="_blank"}

    - [Understanding Kubernetes contexts and namespaces](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}

    - [Formatting output in JSON file with kubectl](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#formatting-output){:target="_blank"}

    - [Filtering and organizing data with kubectl](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-kubectl-get){:target="_blank"}'
  explanation: This command gets warning events from a specific context and namespace
    in Kubernetes, then formats the output into a JSON file. It also filters and organizes
    the data to generate a summary of the events within the last 30 minutes.
  multi_line_details: '```shell

    # Get warning events from Kubernetes cluster in JSON format and save them to a
    file

    kubectl get events --field-selector type=Warning --context ${CONTEXT} -n ${NAMESPACE}
    -o json > $HOME/warning_events.json


    # Read the JSON file, filter and format the data using jq

    cat $HOME/warning_events.json | jq -r ''[.items[] | {namespace: .involvedObject.namespace,
    kind: .involvedObject.kind, baseName: ((if .involvedObject.kind == "Pod" then
    (.involvedObject.name | split("-")[:-1] | join("-")) else .involvedObject.name
    end) // ""), count: .count, firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp,
    reason: .reason, message: .message}] | group_by(.namespace, .kind, .baseName)
    | map({object: (.[0].namespace + "/" + .[0].kind + "/" + .[0].baseName), total_events:
    (reduce .[] as $event (0; . + $event.count)), summary_messages: (map(.message)
    | unique | join("; ")), oldest_timestamp: (map(.firstTimestamp) | sort | first),
    most_recent_timestamp: (map(.lastTimestamp) | sort | last)}) | map(select((now
    - ((.most_recent_timestamp | fromdateiso8601)))/60 <= 30))''

    ```'
  name: troubleshoot_warning_events_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} -o json | jq -r
    --argjson exit_code_explanations ''{"0": "Success", "1": "Error", "2": "Misconfiguration",
    "130": "Pod terminated by SIGINT", "134": "Abnormal Termination SIGABRT", "137":
    "Pod terminated by SIGKILL - Possible OOM", "143":"Graceful Termination SIGTERM"}''
    ''.items[] | select(.status.containerStatuses != null) | select(any(.status.containerStatuses[];
    .restartCount > 0)) | "---\npod_name: \(.metadata.name)\n" + (.status.containerStatuses[]
    | "containers: \(.name)\nrestart_count: \(.restartCount)\nmessage: \(.state.waiting.message
    // "N/A")\nterminated_reason: \(.lastState.terminated.reason // "N/A")\nterminated_finishedAt:
    \(.lastState.terminated.finishedAt // "N/A")\nterminated_exitCode: \(.lastState.terminated.exitCode
    // "N/A")\nexit_code_explanation: \($exit_code_explanations[.lastState.terminated.exitCode
    | tostring] // "Unknown exit code")") + "\n---\n"'''
  doc_links: '

    - [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [JSON output format in kubectl](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#formatting-output-using-jsonpath){:target="_blank"}

    - [jq tool documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command uses kubectl to get information about pods in a specific
    context and namespace in JSON format, then uses jq to format the output to include
    details about any containers that have been restarted, including the exit code
    and an explanation for each exit code based on a predefined set of codes.
  multi_line_details: "```shell\nkubectl get pods --context=${CONTEXT} -n ${NAMESPACE}\
    \ -o json | jq -r --argjson exit_code_explanations '{\"0\": \"Success\", \"1\"\
    : \"Error\", \"2\": \"Misconfiguration\", \"130\": \"Pod terminated by SIGINT\"\
    , \"134\": \"Abnormal Termination SIGABRT\", \"137\": \"Pod terminated by SIGKILL\
    \ - Possible OOM\", \"143\":\"Graceful Termination SIGTERM\"}' '.items[] \n  \
    \  | select(.status.containerStatuses != null) \n    | select(any(.status.containerStatuses[];\
    \ .restartCount > 0)) \n    | \"---\\npod_name: \\(.metadata.name)\\n\" + (.status.containerStatuses[]\
    \ \n        | \"containers: \\(.name)\\nrestart_count: \\(.restartCount)\\nmessage:\
    \ \\(.state.waiting.message // \"N/A\")\\nterminated_reason: \\(.lastState.terminated.reason\
    \ // \"N/A\")\\nterminated_finishedAt: \\(.lastState.terminated.finishedAt //\
    \ \"N/A\")\\nterminated_exitCode: \\(.lastState.terminated.exitCode // \"N/A\"\
    )\\nexit_code_explanation: \\($exit_code_explanations[.lastState.terminated.exitCode\
    \ | tostring] // \"Unknown exit code\")\") + \"\\n---\\n\"'\n```"
  name: troubleshoot_container_restarts_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Pending
    --no-headers -o json | jq -r ''.items[] | "pod_name: \(.metadata.name)\nstatus:
    \(.status.phase // "N/A")\nmessage: \(.status.conditions[0].message // "N/A")\nreason:
    \(.status.conditions[0].reason // "N/A")\ncontainerStatus: \((.status.containerStatuses[0].state
    // "N/A"))\ncontainerMessage: \(.status.containerStatuses[0].state.waiting?.message
    // "N/A")\ncontainerReason: \(.status.containerStatuses[0].state.waiting?.reason
    // "N/A")\n------------"'''
  doc_links: '

    - [Kubernetes Official Documentation](https://kubernetes.io/docs/home/){:target="_blank"}

    - [Kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Jq Documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command retrieves information about pods in a specific context
    and namespace that are in a pending state, and formats the output using jq to
    display details about each pod's name, status, message, reason, container status,
    container message, and container reason.
  multi_line_details: "```bash\n# Set the context for the command\nCONTEXT=${CONTEXT}\n\
    # Set the namespace for the command\nNAMESPACE=${NAMESPACE}\n\n# Retrieve pods\
    \ from the specified context and namespace with a pending status in JSON format\
    \ \npods=$(kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Pending\
    \ --no-headers -o json)\n\n# Parse the JSON output to extract and display relevant\
    \ information about the pods\nparsed_pods=$(echo $pods | jq -r '.items[] | \"\
    pod_name: \\(.metadata.name)\\nstatus: \\(.status.phase // \"N/A\")\\nmessage:\
    \ \\(.status.conditions[0].message // \"N/A\")\\nreason: \\(.status.conditions[0].reason\
    \ // \"N/A\")\\ncontainerStatus: \\((.status.containerStatuses[0].state // \"\
    N/A\"))\\ncontainerMessage: \\(.status.containerStatuses[0].state.waiting?.message\
    \ // \"N/A\")\\ncontainerReason: \\(.status.containerStatuses[0].state.waiting?.reason\
    \ // \"N/A\")\\n------------\"')\n\n# Output the parsed information\necho \"$parsed_pods\"\
    \n```"
  name: troubleshoot_pending_pods_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Failed
    --no-headers -o json | jq -r --argjson exit_code_explanations ''{"0": "Success",
    "1": "Error", "2": "Misconfiguration", "130": "Pod terminated by SIGINT", "134":
    "Abnormal Termination SIGABRT", "137": "Pod terminated by SIGKILL - Possible OOM",
    "143":"Graceful Termination SIGTERM"}'' ''.items[] | "pod_name: \(.metadata.name)\nrestart_count:
    \(.status.containerStatuses[0].restartCount // "N/A")\nmessage: \(.status.message
    // "N/A")\nterminated_finishedAt: \(.status.containerStatuses[0].state.terminated.finishedAt
    // "N/A")\nexit_code: \(.status.containerStatuses[0].state.terminated.exitCode
    // "N/A")\nexit_code_explanation: \($exit_code_explanations[.status.containerStatuses[0].state.terminated.exitCode
    | tostring] // "Unknown exit code")\n------------"'''
  doc_links: '

    - [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [pods](https://kubernetes.io/docs/concepts/workloads/pods/){:target="_blank"}

    - [specific context and namespace](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#context-and-namespace){:target="_blank"}

    - [failed pods](https://kubernetes.io/docs/tasks/debug-application-cluster/determine-reason-pod-failure/){:target="_blank"}

    - [jq](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command uses kubectl to get information about pods in a specific
    context and namespace that have failed. It then formats the output using "jq"
    to provide details about each failed pod, including its name, restart count, message,
    termination time, exit code, and an explanation of the exit code.
  multi_line_details: "```sh\n# Get the failed pods in a specific namespace\nkubectl\
    \ get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Failed\
    \ --no-headers -o json \\\n    # Extract relevant information and format it using\
    \ jq\n    | jq -r --argjson exit_code_explanations '{\"0\": \"Success\", \"1\"\
    : \"Error\", \"2\": \"Misconfiguration\", \"130\": \"Pod terminated by SIGINT\"\
    , \"134\": \"Abnormal Termination SIGABRT\", \"137\": \"Pod terminated by SIGKILL\
    \ - Possible OOM\", \"143\":\"Graceful Termination SIGTERM\"}' \\\n    '.items[]\
    \ | \"pod_name: \\(.metadata.name)\\nrestart_count: \\(.status.containerStatuses[0].restartCount\
    \ // \"N/A\")\\nmessage: \\(.status.message // \"N/A\")\\nterminated_finishedAt:\
    \ \\(.status.containerStatuses[0].state.terminated.finishedAt // \"N/A\")\\nexit_code:\
    \ \\(.status.containerStatuses[0].state.terminated.exitCode // \"N/A\")\\nexit_code_explanation:\
    \ \\($exit_code_explanations[.status.containerStatuses[0].state.terminated.exitCode\
    \ | tostring] // \"Unknown exit code\")\\n------------\"'\n```"
  name: troubleshoot_failed_pods_in_namespace_namespace
- command: 'kubectl get pods --context ${CONTEXT} -n ${NAMESPACE} -o json | jq -r
    ''.items[] | select(.status.conditions[]? | select(.type == "Ready" and .status
    == "False" and .reason != "PodCompleted")) | {kind: .kind, name: .metadata.name,
    conditions: .status.conditions}'' | jq -s ''.'''
  doc_links: '

    - [Kubernetes Concepts](https://kubernetes.io/docs/concepts/){:target="_blank"}

    - [Kubectl Command Documentation](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands){:target="_blank"}

    - [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [jq Tool Documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command retrieves information about pods in a Kubernetes cluster,
    within a specific context and namespace, and displays it in JSON format. It uses
    the `jq` tool to filter out specific conditions of the pods such as status not
    being ready or completed.
  multi_line_details: "```shell\n# Get the pods from a specific context and namespace\
    \ in JSON format\nkubectl get pods --context ${CONTEXT} -n ${NAMESPACE} -o json\
    \ | \n  # Use jq to filter out the pods that are not ready with certain conditions,\
    \ and extract specific data like kind, name, and conditions\n  jq -r '.items[]\
    \ | select(.status.conditions[]? | select(.type == \"Ready\" and .status == \"\
    False\" and .reason != \"PodCompleted\")) | {kind: .kind, name: .metadata.name,\
    \ conditions: .status.conditions}' | \n  # Use jq to format the final output as\
    \ an array\n  jq -s '.'\n```"
  name: troubleshoot_workload_status_conditions_in_namespace_namespace
- command: kubectl api-resources --verbs=list --namespaced -o name --context=${CONTEXT}
    | xargs -n 1 kubectl get --show-kind --ignore-not-found -n ${NAMESPACE} --context=${CONTEXT}
  doc_links: '

    - [kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [API Resources in Kubernetes](https://kubernetes.io/docs/reference/using-api/api-overview/){:target="_blank"}

    - [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}'
  explanation: This command uses kubectl to list all the API resources available in
    a given Kubernetes context, and then retrieves detailed information for each resource
    within a specific namespace. It is useful for quickly querying and understanding
    the resources available within a Kubernetes cluster.
  multi_line_details: "```bash\n#!/bin/bash\n\n# Get the names of all API resources\
    \ in the current context\nresource_names=$(kubectl api-resources --verbs=list\
    \ --namespaced -o name --context=${CONTEXT})\n\n# Iterate through each resource\
    \ to get its details\nfor resource in $resource_names\ndo\n    # Get the details\
    \ of the resource in the specified namespace and context\n    kubectl get --show-kind\
    \ --ignore-not-found -n ${NAMESPACE} --context=${CONTEXT} $resource\ndone\n```"
  name: get_listing_of_resources_in_namespace_namespace
- command: 'kubectl get events --field-selector type!=Warning --context ${CONTEXT}
    -n ${NAMESPACE} -o json > $HOME/events.json && cat $HOME/events.json | jq -r ''[.items[]
    | {namespace: .involvedObject.namespace, kind: .involvedObject.kind, name: ((if
    .involvedObject and .involvedObject.kind == "Pod" then (.involvedObject.name |
    split("-")[:-1] | join("-")) else .involvedObject.name end) // ""), count: .count,
    firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason,
    message: .message}] | group_by(.namespace, .kind, .name) | .[] | {(.[0].namespace
    + "/" + .[0].kind + "/" + .[0].name): {events: .}}'' | jq -r --argjson threshold
    "${ANOMALY_THRESHOLD}" ''to_entries[] | {object: .key, oldest_timestamp: ([.value.events[]
    | .firstTimestamp] | min), most_recent_timestamp: (reduce .value.events[] as $event
    (.value.firstTimestamp; if ($event.lastTimestamp > .) then $event.lastTimestamp
    else . end)), events_per_minute: (reduce .value.events[] as $event (0; . + ($event.count
    / (((($event.lastTimestamp | fromdateiso8601) - ($event.firstTimestamp | fromdateiso8601))
    / 60) | if . == 0 then 1 else . end))) | floor), total_events: (reduce .value.events[]
    as $event (0; . + $event.count)), summary_messages: [.value.events[] | .message]
    | unique | join("; ")} | select(.events_per_minute > $threshold)'' | jq -s ''.'''
  doc_links: '

    - [Using JQ to process JSON](https://stedolan.github.io/jq/manual/){:target="_blank"}

    - [Formatting Data with JQ](https://programminghistorian.org/en/lessons/json-and-jq){:target="_blank"}'
  explanation: This command retrieves events from a Kubernetes cluster that are not
    warnings, and then filters and formats the data using jq to extract specific information
    about the events and present it in a structured JSON format.
  multi_line_details: "```shell\n# Store kubectl get events in a json file\nkubectl\
    \ get events --field-selector type!=Warning --context ${CONTEXT} -n ${NAMESPACE}\
    \ -o json > $HOME/events.json && \n# Read from the stored json file and extract\
    \ specific information using jq\ncat $HOME/events.json | jq -r '\n    [.items[]\
    \ | \n    # Filter and format the output with \n    {namespace: .involvedObject.namespace,\
    \ kind: .involvedObject.kind, name: ((if .involvedObject and .involvedObject.kind\
    \ == \"Pod\" \n    then (.involvedObject.name | split(\"-\")[:-1] | join(\"-\"\
    )) else .involvedObject.name end) // \"\"), count: .count, \n    firstTimestamp:\
    \ .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason, message: .message}]\
    \ | \n    # Group the extracted data by namespace, kind, and name\n    group_by(.namespace,\
    \ .kind, .name) | .[] | {(.[0].namespace + \"/\" + .[0].kind + \"/\" + .[0].name):\
    \ {events: .}}' | \n    # Extract relevant data for further analysis\n    jq -r\
    \ --argjson threshold \"${ANOMALY_THRESHOLD}\" 'to_entries[] | \n    {object:\
    \ .key, oldest_timestamp: ([.value.events[] | .firstTimestamp] | min), \n    most_recent_timestamp:\
    \ (reduce .value.events[] as $event (.value.firstTimestamp; \n    if ($event.lastTimestamp\
    \ > .) then $event.lastTimestamp else . end)), events_per_minute: \n    (reduce\
    \ .value.events[] as $event (0; . + ($event.count / (((($event.lastTimestamp |\
    \ fromdateiso8601) - ($event.firstTimestamp | fromdateiso8601)) / 60) | if . ==\
    \ 0 then 1 else . end))) | floor), \n    total_events: (reduce .value.events[]\
    \ as $event (0; . + $event.count)), summary_messages: \n    [.value.events[] |\
    \ .message] | unique | join(\"; \")} | select(.events_per_minute > $threshold)'\
    \ | \n    # Coalesce all results into a single homogeneous response   \n    jq\
    \ -s '.'\n```"
  name: check_event_anomalies_in_namespace_namespace
- command: 'services=($(kubectl get svc -o=name --context=${CONTEXT} -n ${NAMESPACE}))
    && [ \${#services[@]} -eq 0 ] && echo "No services found." || { > "logs.json";
    for service in "\${services[@]}"; do kubectl logs $service --limit-bytes=256000
    --since=2h --context=${CONTEXT} -n ${NAMESPACE} 2>/dev/null | grep -Ei "${SERVICE_ERROR_PATTERN}"
    | grep -Ev "${SERVICE_EXCLUDE_PATTERN}" | while read -r line; do service_name="\${service#*/}";
    message=$(echo "$line" | jq -aRs .); printf ''{"service": "%s", "message": %s}\n''
    "\${service_name}" "$message" >> "logs.json"; done; done; [ ! -s "logs.json" ]
    && echo "No log entries found." || cat "logs.json" | jq -s ''[ (group_by(.service)
    | map({service: .[0].service, total_logs: length})), (group_by(.service) | map({service:
    .[0].service, top_logs: (group_by(.message[0:200]) | map({message_start: .[0].message[0:200],
    count: length}) | sort_by(.count) | reverse | .[0:3])})) ] | add''; } > $HOME/output;
    cat $HOME/output'
  doc_links: '

    - [Kubernetes - Contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}

    - [Kubernetes - Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubernetes - Logging](https://kubernetes.io/docs/concepts/cluster-administration/logging/){:target="_blank"}

    - [Regular Expressions Overview](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions){:target="_blank"}

    - [JSON File Format](https://www.json.org/json-en.html){:target="_blank"}'
  explanation: This command retrieves the logs for all services in a specified Kubernetes
    context and namespace, filters them based on error and exclude patterns, then
    outputs the results to a JSON file. If no logs are found for any service, it will
    return a message indicating so.
  multi_line_details: "```shell\nservices=($(kubectl get svc -o=name --context=${CONTEXT}\
    \ -n ${NAMESPACE}))\n\n# If no services are found, display an error message\n\
    if [ \\${#services[@]} -eq 0 ]; then\n    echo \"No services found.\"\nelse\n\
    \    # Create a new file for storing JSON logs\n    > \"logs.json\"\n    \n  \
    \  # Loop through each service and retrieve logs\n    for service in \"\\${services[@]}\"\
    ; do \n        kubectl logs $service --limit-bytes=256000 --since=2h --context=${CONTEXT}\
    \ -n ${NAMESPACE} 2>/dev/null | grep -Ei \"${SERVICE_ERROR_PATTERN}\" | grep -Ev\
    \ \"${SERVICE_EXCLUDE_PATTERN}\" | while read -r line; do \n            # Extract\
    \ the service name from the current log line\n            service_name=\"\\${service#*/}\"\
    \n            \n            # Convert the log line into a JSON object\n      \
    \      message=$(echo \"$line\" | jq -aRs .)\n            \n            # Append\
    \ the resulting JSON object to the log file\n            printf '{\"service\"\
    : \"%s\", \"message\": %s}\\n' \"\\${service_name}\" \"$message\" >> \"logs.json\"\
    \n        done\n    done\n    \n    # If no log entries were found, display a\
    \ message\n    [ ! -s \"logs.json\" ] && echo \"No log entries found.\" || \n\n\
    \    # Process the log file using jq and store the results in a temporary output\
    \ file\n    cat \"logs.json\" | jq -s '[ (group_by(.service) | map({service: .[0].service,\
    \ total_logs: length})), (group_by(.service) | map({service: .[0].service, top_logs:\
    \ (group_by(.message[0:200]) | map({message_start: .[0].message[0:200], count:\
    \ length}) | sort_by(.count) | reverse | .[0:3])})) ] | add' > $HOME/output\n\
    \    \n    # Output the temporary output file\n    cat $HOME/output\nfi\n```"
  name: troubleshoot_services_and_application_workloads_in_namespace_namespace
- command: context="${CONTEXT}"; namespace="${NAMESPACE}"; check_health() { local
    type=$1; local name=$2; local replicas=$3; local selector=$4; local pdbs=$(kubectl
    --context "$context" --namespace "$namespace" get pdb -o json | jq -c --arg selector
    "$selector" '.items[] | select(.spec.selector.matchLabels | to_entries[] | .key
    + "=" + .value == $selector)'); if [[ $replicas -gt 1 && -z "$pdbs" ]]; then printf
    "%-30s %-30s %-10s\n" "$type/$name" "" "Missing"; else echo "$pdbs" | jq -c .
    | while IFS= read -r pdb; do local pdbName=$(echo "$pdb" | jq -r '.metadata.name');
    local minAvailable=$(echo "$pdb" | jq -r '.spec.minAvailable // ""'); local maxUnavailable=$(echo
    "$pdb" | jq -r '.spec.maxUnavailable // ""'); if [[ "$minAvailable" == "100%"
    || "$maxUnavailable" == "0" || "$maxUnavailable" == "0%" ]]; then printf "%-30s
    %-30s %-10s\n" "$type/$name" "$pdbName" "Risky"; elif [[ $replicas -gt 1 && ("$minAvailable"
    != "100%" || "$maxUnavailable" != "0" || "$maxUnavailable" != "0%") ]]; then printf
    "%-30s %-30s %-10s\n" "$type/$name" "$pdbName" "OK"; fi; done; fi; }; echo "Deployments:";
    echo "-----------"; printf "%-30s %-30s %-10s\n" "NAME" "PDB" "STATUS"; kubectl
    --context "$context" --namespace "$namespace" get deployments -o json | jq -c
    '.items[] | "\(.metadata.name) \(.spec.replicas) \(.spec.selector.matchLabels
    | to_entries[] | .key + "=" + .value)"' | while read -r line; do check_health
    "Deployment" $(echo $line | tr -d '"'); done; echo ""; echo "Statefulsets:"; echo
    "-------------"; printf "%-30s %-30s %-10s\n" "NAME" "PDB" "STATUS"; kubectl --context
    "$context" --namespace "$namespace" get statefulsets -o json | jq -c '.items[]
    | "\(.metadata.name) \(.spec.replicas) \(.spec.selector.matchLabels | to_entries[]
    | .key + "=" + .value)"' | while read -r line; do check_health "StatefulSet" $(echo
    $line | tr -d '"'); done
  doc_links: '

    - [Kubernetes official documentation for deploying applications](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/){:target="_blank"}

    - [Understanding StatefulSets in Kubernetes](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/){:target="_blank"}

    - [Managing Pod Disruption Budgets](https://kubernetes.io/docs/tasks/run-application/configure-pdb/){:target="_blank"}'
  explanation: This command checks the health status of deployments and statefulsets
    in a Kubernetes cluster by looking at their corresponding Pod Disruption Budgets
    (PDBs) and prints the status of each one as OK, Risky, or Missing. It does this
    by querying the PDBs for each deployment and statefulset and comparing their minimum
    availability and maximum unavailability settings with the number of replicas specified
    in the deployment/statefulset.
  multi_line_details: "```sh\n# Assign command line argument values to variables\n\
    context=\"${CONTEXT}\"; \nnamespace=\"${NAMESPACE}\"; \n\n# Define check_health\
    \ function with appropriate parameters\ncheck_health() { \n  local type=$1; \n\
    \  local name=$2; \n  local replicas=$3; \n  local selector=$4; \n  local pdbs=$(kubectl\
    \ --context \"$context\" --namespace \"$namespace\" get pdb -o json | jq -c --arg\
    \ selector \"$selector\" '.items[] | select(.spec.selector.matchLabels | to_entries[]\
    \ | .key + \"=\" + .value == $selector)'); \n\n  if [[ $replicas -gt 1 && -z \"\
    $pdbs\" ]]; then \n    printf \"%-30s %-30s %-10s\\n\" \"$type/$name\" \"\" \"\
    Missing\"; \n  else \n    echo \"$pdbs\" | jq -c . | while IFS= read -r pdb; do\
    \ \n      local pdbName=$(echo \"$pdb\" | jq -r '.metadata.name'); \n      local\
    \ minAvailable=$(echo \"$pdb\" | jq -r '.spec.minAvailable // \"\"'); \n     \
    \ local maxUnavailable=$(echo \"$pdb\" | jq -r '.spec.maxUnavailable // \"\");\
    \ \n\n      if [[ \"$minAvailable\" == \"100%\" || \"$maxUnavailable\" == \"0\"\
    \ || \"$maxUnavailable\" == \"0%\" ]]; then \n        printf \"%-30s %-30s %-10s\\\
    n\" \"$type/$name\" \"$pdbName\" \"Risky\"; \n      elif [[ $replicas -gt 1 &&\
    \ (\"$minAvailable\" != \"100%\" || \"$maxUnavailable\" != \"0\" || \"$maxUnavailable\"\
    \ != \"0%\") ]]; then \n        printf \"%-30s %-30s %-10s\\n\" \"$type/$name\"\
    \ \"$pdbName\" \"OK\"; \n      fi; \n    done;\n  fi; \n}; \n\n# Display Deployments,\
    \ retrieve information and run health check for each\necho \"Deployments:\"; \n\
    echo \"-----------\"; \nprintf \"%-30s %-30s %-10s\\n\" \"NAME\" \"PDB\" \"STATUS\"\
    ; \nkubectl --context \"$context\" --namespace \"$namespace\" get deployments\
    \ -o json | jq -c '.items[] | \"\\(.metadata.name) \\(.spec.replicas) \\(.spec.selector.matchLabels\
    \ | to_entries[] | .key + \"=\" + .value)\"' | while read -r line; \ndo check_health\
    \ \"Deployment\" $(echo $line | tr -d '\"'); \ndone; \necho \"\"; \n\n# Display\
    \ Statefulsets, retrieve information and run health check for each\necho \"Statefulsets:\"\
    ; \necho \"-------------\"; \nprintf \"%-30s %-30s %-10s\\n\" \"NAME\" \"PDB\"\
    \ \"STATUS\"; \nkubectl --context \"$context\" --namespace \"$namespace\" get\
    \ statefulsets -o json | jq -c '.items[] | \"\\(.metadata.name) \\(.spec.replicas)\
    \ \\(.spec.selector.matchLabels | to_entries[] | .key + \"=\" + .value)\"' | while\
    \ read -r line; \ndo check_health \"StatefulSet\" $(echo $line | tr -d '\"');\
    \ \ndone\n```"
  name: check_missing_or_risky_poddisruptionbudget_policies_in_namepace_namespace
