commands:
- command: kubectl get events --field-selector type=Warning --context ${CONTEXT} -n
    ${NAMESPACE} -o json
  explanation: '


    This command retrieves a list of Kubernetes events for the provided context (e.g.
    the name of the cluster) and namespace (a unique identifier associated with a
    running application). The "--field-selector type=Warning" option also ensures
    that only events with a severity of warning are retrieved - meaning, they indicate
    something went wrong or a problem might be occurring that needs attention. The
    "-o json" option allows the output to be in a machine-friendly JSON format for
    easy processing and analysis by automation tools.'
  multi_line_details: "\n\n# This command will query events in a particular namespace\
    \ and filter the output to only show events of type \"Warning\"\n# First, set\
    \ the context and namespace you want to work with\nCONTEXT=\"<the name of your\
    \ cluster context>\"\nNAMESPACE=\"<the namespace you want to query events from>\"\
    \n\n# Then, run the following command to get all the events of type \"Warning\"\
    \nkubectl get events \\\n    --field-selector type=Warning \\\n\t--context ${CONTEXT}\
    \ \\\n\t-n ${NAMESPACE} \\\n\t-o json"
  name: trace_and_troubleshoot_namespace_warning_events_and_errors
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} -o json | jq -r
    --argjson exit_code_explanations ''{"0": "Success", "1": "Error", "2": "Misconfiguration",
    "130": "Pod terminated by SIGINT", "134": "Abnormal Termination SIGABRT", "137":
    "Pod terminated by SIGKILL - Possible OOM", "143":"Graceful Termination SIGTERM"}''
    ''.items[] | select(.status.containerStatuses != null) | select(.status.containerStatuses[].restartCount
    > 0) | "---\npod_name: \(.metadata.name)\ncontainers: \(.status.containerStatuses
    | map(.name) | join(", "))\nrestart_count: \(.status.containerStatuses[].restartCount)\nmessage:
    \(.status.message // "N/A")\n\(.status.containerStatuses[] | select(.state.running
    != null) | .lastState.terminated | "terminated_reason: \(.reason // "N/A")\nterminated_finishedAt:
    \(.finishedAt // "N/A")\nterminated_exitCode: \(.exitCode // "N/A")\nexit_code_explanation:
    \($exit_code_explanations[.exitCode | tostring] // "Unknown exit code")")\n---\n"'''
  explanation: '


    This command is used to get all of the pods in a Kubernetes cluster. Context and
    namespace are provided, along with an output type of json. We then add jq -r for
    json manipulation and execution of further commands to provide info about the
    pod status. This command then outputs detailed information about each of the pods,
    like its name, containers names, restart count, message, terminated reason, finishedAt
    time, exit code and corresponding explanation.'
  multi_line_details: "\n\n# Convert this one-line command into a multi-line command,\
    \ adding verbose comments to educate new users of Kubernetes and related cli commands.\n\
    # This command is used to find the container in a Kubernetes deployment that have\
    \ more than one restart count. \n\n# Get all Pods associated with the given context\
    \ & namespace\nkubectl get pods --context=${CONTEXT} -n ${NAMESPACE} \\\n\n# Output\
    \ the response as JSON\n-o json \\\n\n# Use jq to query & filter the output of\
    \ kubctl\n| jq -r --argjson exit_code_explanations '{\"0\": \"Success\", \"1\"\
    : \"Error\", \"2\": \"Misconfiguration\", \"130\": \"Pod terminated by SIGINT\"\
    , \"134\": \"Abnormal Termination SIGABRT\", \"137\": \"Pod terminated by SIGKILL\
    \ - Possible OOM\", \"143\":\"Graceful Termination SIGTERM\"}' \\\n\n# Get Pods\
    \ that satisfy two conditions\n# i)The Pod has containers\n# ii)At least on container\
    \ has more than one restart count\n'.items[] | \n select(.status.containerStatuses\
    \ != null) \n | select(.status.containerStatuses[].restartCount > 0) \n\n# Output\
    \ the result as multiline text\n| \"---\\npod_name: \\(.metadata.name)\\ncontainers:\
    \ \\(.status.containerStatuses | map(.name) | join(\", \"))\\nrestart_count: \\\
    (.status.containerStatuses[].restartCount)\\nmessage: \\(.status.message // \"\
    N/A\")\\n\\(.status.containerStatuses[] | select(.state.running != null) | .lastState.terminated\
    \ | \"terminated_reason: \\(.reason // \"N/A\")\\nterminated_finishedAt: \\(.finishedAt\
    \ // \"N/A\")\\nterminated_exitCode: \\(.exitCode // \"N/A\")\\nexit_code_explanation:\
    \ \\($exit_code_explanations[.exitCode | tostring] // \"Unknown exit code\")\"\
    )\\n---\\n\"'"
  name: troubleshoot_container_restarts_in_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Pending
    --no-headers -o json | jq -r ''.items[] | "---\npod_name: \(.metadata.name)\nstatus:
    \(.status.phase // "N/A")\nmessage: \(.status.conditions[].message // "N/A")\nreason:
    \(.status.conditions[].reason // "N/A")\ncontainerStatus: \((.status.containerStatuses
    // [{}])[].state // "N/A")\ncontainerMessage: \((.status.containerStatuses //
    [{}])[].state?.waiting?.message // "N/A")\ncontainerReason: \((.status.containerStatuses
    // [{}])[].state?.waiting?.reason // "N/A")\n---\n"'''
  explanation: ' | grep "${pod_name}"


    This command is used to query Kubernetes pods. It uses the context and namespace
    defined by both "${CONTEXT}" and "${NAMESPACE}". Additionally, this command specifies
    that it will only return pods in a pending state with "--field-selector=status.phase=Pending".
    The output is then piped to jq which processes the json data into a more readable
    format and outputs the result. The final part of the command can be used to filter
    the results by a pod name of choice with "grep ${pod_name}". This command will
    help you investigate why certain pods are in a pending status and what you can
    do to fix it.'
  multi_line_details: "\n\n# This command will list all the pod information for pods\
    \ in a given namespace with status \"Pending\", using JSON output:\nkubectl get\
    \ pods \\  # command to get a list of pods\n    --context=${CONTEXT} \\ # specifying\
    \ the Kubernetes context to use \n    -n ${NAMESPACE} \\ # specify the namespace\
    \ to use\n    --field-selector=status.phase=Pending \\ # filter the results to\
    \ include only objects where the \"status.phase\" is \"Pending\"\n    --no-headers\
    \ \\ # exclude the table header information from the response\n    -o json # format\
    \ the response as json\n\n| # pipe the response to the subsequent command\njq\
    \ -r '.items[] | \"---\\npod_name: \\(.metadata.name)\\nstatus: \\(.status.phase\
    \ // \"N/A\")\\nmessage: \\(.status.conditions[].message // \"N/A\")\\nreason:\
    \ \\(.status.conditions[].reason // \"N/A\")\\ncontainerStatus: \\((.status.containerStatuses\
    \ // [{}])[].state // \"N/A\")\\ncontainerMessage: \\((.status.containerStatuses\
    \ // [{}])[].state?.waiting?.message // \"N/A\")\\ncontainerReason: \\((.status.containerStatuses\
    \ // [{}])[].state?.waiting?.reason // \"N/A\")\\n---\\n\"' \\ # parse the data\
    \ using jq (JSON processor) to display fields from each pod object in the response\
    \ in a nicely formatted output"
  name: troubleshoot_pending_pods_in_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Failed
    --no-headers -o json | jq -r --argjson exit_code_explanations ''{"0": "Success",
    "1": "Error", "2": "Misconfiguration", "130": "Pod terminated by SIGINT", "134":
    "Abnormal Termination SIGABRT", "137": "Pod terminated by SIGKILL - Possible OOM",
    "143":"Graceful Termination SIGTERM"}'' ''.items[] | "---\npod_name: \(.metadata.name)\nrestart_count:
    \(.status.containerStatuses[0].restartCount // "N/A")\nmessage: \(.status.message
    // "N/A")\nterminated_finishedAt: \(.status.containerStatuses[0].state.terminated.finishedAt
    // "N/A")\nexit_code: \(.status.containerStatuses[0].state.terminated.exitCode
    // "N/A")\nexit_code_explanation: \($exit_code_explanations[.status.containerStatuses[0].state.terminated.exitCode
    | tostring] // "Unknown exit code")\n---\n"'''
  explanation: '


    This command will get all the pods with failed status in a specific namespace
    (${NAMESPACE}) of a Kubernetes cluster''s context (${CONTEXT}) and output the
    details in JSON format. The details include pod name, restart count, messages,
    finished time of terminations and exit codes with an explanation for successful/error/misconfigured
    or terminated (by SIGINT/ABRT/KILL/TERM) pods.'
  multi_line_details: "\n\n# The following command retrieves information about all\
    \ Pods with status \"Failed\" in the Kubernetes environment context defined by\
    \ the variable $CONTEXT and the namespace defined by the variable $NAMESPACE.\
    \ It then utilizes jq to format the output showing each item for each Pod on its\
    \ own line and interpret codes used in Kubernetes as human-readable explanations,\
    \ returning the value of those fields:\n\n# Get pods with status Failed in designated\
    \ context and namespace\nkubectl get pods \\\n    --context=${CONTEXT} \\\n  \
    \  -n ${NAMESPACE} \\\n    --field-selector=status.phase=Failed \\\n    --no-headers\
    \ \\\n    -o json\n\n# Convert the json output into human-readable information\
    \ using jq formatting\njq -r \\\n    --argjson exit_code_explanations '{\"0\"\
    : \"Success\", \"1\": \"Error\", \"2\": \"Misconfiguration\", \"130\": \"Pod terminated\
    \ by SIGINT\", \"134\": \"Abnormal Termination SIGABRT\", \"137\": \"Pod terminated\
    \ by SIGKILL - Possible OOM\", \"143\":\"Graceful Termination SIGTERM\"}' \\\n\
    \    '.items[] | \"---\\npod_name: \\(.metadata.name)\\nrestart_count: \\(.status.containerStatuses[0].restartCount\
    \ // \"N/A\")\\nmessage: \\(.status.message // \"N/A\")\\nterminated_finishedAt:\
    \ \\(.status.containerStatuses[0].state.terminated.finishedAt // \"N/A\")\\nexit_code:\
    \ \\(.status.containerStatuses[0].state.terminated.exitCode // \"N/A\")\\nexit_code_explanation:\
    \ \\($exit_code_explanations[.status.containerStatuses[0].state.terminated.exitCode\
    \ | tostring] // \"Unknown exit code\")\\n---\\n\"'"
  name: troubleshoot_failed_pods_in_namespace
- command: kubectl get all --context ${CONTEXT} -n ${NAMESPACE} -o json
  explanation: '


    This command tells Kubernetes to get all of the resources it manages in a specific
    context, namespace and output them in JSON format. The context is a collection
    of clusters (or single cluster) and the namespace is a logical grouping of objects
    within a Kubernetes cluster. This command can be used to quickly view all the
    resources that are part of your current context and namespace.'
  multi_line_details: "path=\"{..ingress[*].host}\"\n\n# Multi-line command with comments:\
    \ \n# Get list of ingress hosts for a specific namespace in the cluster using\
    \ kubectl\n# Set the context to allow kubectl access to the desired pod\nexport\
    \ CONTEXT=some-context\n\n# Set the namespace to query; any existing namespace\
    \ can be used\nexport NAMESPACE=some-namespace\n\n# Query Kubernetes API to list\
    \ all objects/resources\nkubectl get all \\\n    --context ${CONTEXT} \\\n   \
    \ -n ${NAMESPACE} \\\n    -o jsonpath=\"{..ingress[*].host}\""
  name: troubleshoot_workload_status_conditions_in_namespace
- command: kubectl api-resources --verbs=list --namespaced -o name --context=${CONTEXT}
    | xargs -n 1 kubectl get --show-kind --ignore-not-found -n ${NAMESPACE} --context=${CONTEXT}
  explanation: ' -o yaml


    This command uses the kubectl (Kubernetes Command Line) tool to list out all of
    the Kubernetes API resources in a given namespace, which is indicated by the --namespaced
    tag. We are specifying the context of the command with the --context flag and
    passing it an argument from the CONTEXT variable. Then we use xargs -n 1 to split
    the output into individual lines and pass each one as an argument to the kubectl
    get command. The --ignore-not-found flag will cause the command to ignore any
    resources that don''t exist and the --show-kind flag will output the type of resource
    being listed. Finally, we are setting the output format to YAML with the -o yaml
    flag at the end.'
  multi_line_details: "\n\n# This command retrieves a list of all kubernetes API resources\
    \ currently available, \n# filtered for those that use the list verb only in a\
    \ namespaced manner.\nCONTEXT=\"mycontext\" # Replace with the name of the specific\
    \ Kubernetes context you need to access\nNAMESPACE=\"mynamespace\" # Replace with\
    \ the specific namespace you need access to\n\n# Retrieve a list of api-resources\
    \ using \"list\" verb in a namespaced manner\nkubectl \\\n    api-resources \\\
    \n        --verbs=list \\\n        --namespaced \\\n        -o name \\\n     \
    \   --context=${CONTEXT}\n\n# Pipe the output into xargs to read the commands\
    \ line-by-line\nxargs \\\n    -n 1 \\\n    kubectl \\\n        get \\\n      \
    \      --show-kind \\\n            --ignore-not-found \\\n            -n ${NAMESPACE}\
    \ \\\n            --context=${CONTEXT}"
  name: get_listing_of_resources_in_namespace
- command: services=($(kubectl get svc -o=name --context=${CONTEXT} -n ${NAMESPACE}));
    logs=""; for service in "\${services[@]}"; do logs+=$(kubectl logs $service --limit-bytes=256000
    --since=2h --context=${CONTEXT} -n ${NAMESPACE} | grep -Ei "${SERVICE_ERROR_PATTERN}"
    | grep -Ev "${SERVICE_EXCLUDE_PATTERN}" | sort | uniq -c | awk '{print "Issue
    Occurences:",$0}'); done; echo "\${logs}"
  explanation: '


    This command is used to help gathering logs from Kubernetes for troubleshooting
    purposes. It does so by retrieving a list of services from a specific Kubernetes
    context and namespace, then using the retrieved list to get recent log entries
    (within 2 hours) for each service, combining the entries retrieved from logs across
    all service, counting the number of occurrences of an "issue" (as specified via
    the SERVICE_ERROR_PATTERN), and filtering out undesired log entries as specified
    via the SERVICE_EXCLUDE_PATTERN). At the end of this process, it will print out
    the combined log entries with the total number of issue occurrences for each entry.'
  multi_line_details: "\n\n# Save the list of services in an array named 'services'\n\
    services=($(kubectl get svc -o=name --context=${CONTEXT} -n ${NAMESPACE}))\n\n\
    # Set an empty string for variable 'logs', which will contain the logs of all\
    \ services\nlogs=\"\"\n\n# Loop through each service name, getting the logs and\
    \ appending them to `logs` with result count\nfor service in \"\\${services[@]}\"\
    ; do\n  logs+=$(kubectl logs $service --limit-bytes=256000 --since=2h --context=${CONTEXT}\
    \ -n ${NAMESPACE} | grep -Ei \"${SERVICE_ERROR_PATTERN}\" | grep -Ev \"${SERVICE_EXCLUDE_PATTERN}\"\
    \ | sort | uniq -c | awk '{print \"Issue Occurences:\",$0}')\ndone\n\n# Echo out\
    \ the logs to the terminal\necho \"\\${logs}\""
  name: troubleshoot_namespace_services_and_application_workloads
- command: context="${CONTEXT}"; namespace="${NAMESPACE}"; check_health() { local
    type=$1; local name=$2; local replicas=$3; local selector=$4; local pdbs=$(kubectl
    --context "$context" --namespace "$namespace" get pdb -o json | jq -c --arg selector
    "$selector" '.items[] | select(.spec.selector.matchLabels | to_entries[] | .key
    + "=" + .value == $selector)'); if [[ $replicas -gt 1 && -z "$pdbs" ]]; then printf
    "%-30s %-30s %-10s\n" "$type/$name" "" "Missing"; else echo "$pdbs" | jq -c .
    | while IFS= read -r pdb; do local pdbName=$(echo "$pdb" | jq -r '.metadata.name');
    local minAvailable=$(echo "$pdb" | jq -r '.spec.minAvailable // ""'); local maxUnavailable=$(echo
    "$pdb" | jq -r '.spec.maxUnavailable // ""'); if [[ "$minAvailable" == "100%"
    || "$maxUnavailable" == "0" || "$maxUnavailable" == "0%" ]]; then printf "%-30s
    %-30s %-10s\n" "$type/$name" "$pdbName" "Risky"; elif [[ $replicas -gt 1 && ("$minAvailable"
    != "100%" || "$maxUnavailable" != "0" || "$maxUnavailable" != "0%") ]]; then printf
    "%-30s %-30s %-10s\n" "$type/$name" "$pdbName" "OK"; fi; done; fi; }; echo "Deployments:";
    echo "-----------"; printf "%-30s %-30s %-10s\n" "NAME" "PDB" "STATUS"; kubectl
    --context "$context" --namespace "$namespace" get deployments -o json | jq -c
    '.items[] | "\(.metadata.name) \(.spec.replicas) \(.spec.selector.matchLabels
    | to_entries[] | .key + "=" + .value)"' | while read -r line; do check_health
    "Deployment" $(echo $line | tr -d '"'); done; echo ""; echo "Statefulsets:"; echo
    "-------------"; printf "%-30s %-30s %-10s\n" "NAME" "PDB" "STATUS"; kubectl --context
    "$context" --namespace "$namespace" get statefulsets -o json | jq -c '.items[]
    | "\(.metadata.name) \(.spec.replicas) \(.spec.selector.matchLabels | to_entries[]
    | .key + "=" + .value)"' | while read -r line; do check_health "StatefulSet" $(echo
    $line | tr -d '"'); done
  explanation: "\n\nThis Kubernetes command checks the health of the deployments and\
    \ statefulsets in a given context and namespace. It displays the status of each\
    \ deployment/statefulset and the Pod Disruption Budgets (PDBs) associated with\
    \ it. \n\nThe first set of lines calls the check_health () function to extract\
    \ information about the pods within each deployment and compare the min available\
    \ and max unavailable metrics with the replicas value. If there is a mismatch,\
    \ it displays a 'Risky' or 'OK' message accordingly. \n\nThe final line runs a\
    \ query which returns the name of the deployment or statefulset as well as their\
    \ respective replication factors and selectors. This allows us to then loop through\
    \ each deployment/statefulset and call the check_health function to get their\
    \ status."
  multi_line_details: "\n\n# This command evaluates the Kubernetes PPeriodic Backup\
    \ (PDB) status for given deployments and stateful sets in a namespace. It verifies\
    \ that the deployment and/or statefulSet(s) meet the minimum required configurations\
    \ for their respective workloads. \n\n# Step 1: Setting up variables\nCONTEXT=\"\
    ${CONTEXT}\";\nNAMESPACE=\"${NAMESPACE}\";\n\n# Step 2: Defining the check_health\
    \ function. This function tests if the PDBs of the given workload are correctly\
    \ configured\ncheck_health() {\n\n    # Step 2a: getting value of required parameters\n\
    \    local type=$1;\n    local name=$2;\n    local replicas=$3;\n    local selector=$4;\n\
    \n    # Step 2b: In order to test the correctness of the PDB configuration, we\
    \ need to get the associated PDBs for the specified workload using jq. We use\
    \ 'kubectl' to get the Pod Disruption Budgets (PDBs) related to the workload\n\
    \    local pdbs=$(kubectl --context \"$context\" --namespace \"$namespace\" get\
    \ pdb -o json | jq -c --arg selector \"$selector\" '.items[] | select(.spec.selector.matchLabels\
    \ | to_entries[] | .key + \"=\" + .value == $selector)');\n\n    # Step 2c: If\
    \ the number of replicas for the given workload is greater than 1 and no pod disruption\
    \ budget is found, then the workload does not have a minimum safe/correct configuration\
    \  \n    if [[ $replicas -gt 1 && -z \"$pdbs\" ]]; then\n\n        # Print appropriate\
    \ message\n        printf \"%-30s %-30s %-10s\\n\" \"$type/$name\" \"\" \"Missing\"\
    ;\n\n    else\n        \n        # Step 2d: Iterate through each found POD disruption\
    \ budget\n        echo \"$pdbs\" | jq -c . | while IFS= read -r pdb; do\n\n  \
    \          # Step 2e: Get the name of the Pod Disruption Budget\n            local\
    \ pdbName=$(echo \"$pdb\" | jq -r '.metadata.name');\n\n            # Step 2f:\
    \ Get the minAvailable and maxUnavailable values from the PDB specification\n\
    \            local minAvailable=$(echo \"$pdb\" | jq -r '.spec.minAvailable //\
    \ \"\"');\n            local maxUnavailable=$(echo \"$pdb\" | jq -r '.spec.maxUnavailable\
    \ // \"\"');\n\n            # Step 2g: Check if the values for the PDB specifications\
    \ meet the recommended criteria\n            if [[ \"$minAvailable\" == \"100%\"\
    \ || \"$maxUnavailable\" == \"0\" || \"$maxUnavailable\" == \"0%\" ]]; then\n\n\
    \                # Step 2h: If the values dont meet the recommended criteria,\
    \ print out an appropriate message\n                printf \"%-30s %-30s %-10s\\\
    n\" \"$type/$name\" \"$pdbName\" \"Risky\";\n\n            # Step 2i: If the number\
    \ of replicas for the given  workload is greater than 1 and the values meet the\
    \ recommended criteria\n            elif [[ $replicas -gt 1 && (\"$minAvailable\"\
    \ != \"100%\" || \"$maxUnavailable\" != \"0\" || \"$maxUnavailable\" != \"0%\"\
    ) ]]; then\n                \n                # Step 2j: Print out an appropriate\
    \ message\n                printf \"%-30s %-30s %-10s\\n\" \"$type/$name\" \"\
    $pdbName\" \"OK\";\n            fi;\n        done;\n    fi;\n};\n\n# Step 3: Evaluating\
    \ health of deployments\necho \"Deployments:\";\necho \"-----------\";\n\n# Step\
    \ 3a: Represeted the columns for output messages\nprintf \"%-30s %-30s %-10s\\\
    n\" \"NAME\" \"PDB\" \"STATUS\";\n\n# Step 3b: Iterate through deployments present\
    \ in the context and namespace using kubectl and jq\nkubectl --context \"$context\"\
    \ --namespace \"$namespace\" get deployments -o json | jq -c '.items[] | \"\\\
    (.metadata.name) \\(.spec.replicas) \\(.spec.selector.matchLabels | to_entries[]\
    \ | .key + \"=\" + .value)\"' | while read -r line; do\n\n    # Step 3c: Invoke\
    \ the check_health with relevant parameters\n    check_health \"Deployment\" $(echo\
    \ $line | tr -d '\"');\ndone;\n\n# Step 4: Leaving a blank line for better readability\n\
    echo \"\";\n\n# Step 5: Evaluating health of StatefulSets\necho \"Statefulsets:\"\
    ;\necho \"-------------\";\n\n# Step 5a: Represented the columns for output messages\n\
    printf \"%-30s %-30s %-10s\\n\" \"NAME\" \"PDB\" \"STATUS\";\n\n# Step 5b: Iterate\
    \ through stateful sets present in the context and namespace using kubectl and\
    \ jq\nkubectl --context \"$context\" --namespace \"$namespace\" get statefulsets\
    \ -o json | jq -c '.items[] | \"\\(.metadata.name) \\(.spec.replicas) \\(.spec.selector.matchLabels\
    \ | to_entries[] | .key + \"=\" + .value)\"' | while read -r line; do\n\n    #\
    \ Step 5c: Invoke the check_health with relevant parameters\n    check_health\
    \ \"StatefulSet\" $(echo $line | tr -d '\"');\ndone"
  name: check_missing_or_risky_poddisruptionbudget_policies
