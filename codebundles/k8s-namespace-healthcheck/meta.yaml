commands:
- command: 'kubectl get events --field-selector type=Warning --context ${CONTEXT}
    -n ${NAMESPACE} -o json > $HOME/warning_events.json && cat $HOME/warning_events.json
    | jq -r ''[.items[] | {namespace: .involvedObject.namespace, kind: .involvedObject.kind,
    baseName: ((if .involvedObject.kind == "Pod" then (.involvedObject.name | split("-")[:-1]
    | join("-")) else .involvedObject.name end) // ""), count: .count, firstTimestamp:
    .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason, message: .message}]
    | group_by(.namespace, .kind, .baseName) | map({object: (.[0].namespace + "/"
    + .[0].kind + "/" + .[0].baseName), total_events: (reduce .[] as $event (0; .
    + $event.count)), summary_messages: (map(.message) | unique | join("; ")), oldest_timestamp:
    (map(.firstTimestamp) | sort | first), most_recent_timestamp: (map(.lastTimestamp)
    | sort | last)}) | map(select((now - ((.most_recent_timestamp | fromdateiso8601)))/60
    <= 30))'''
  doc_links: '

    - [Kubernetes warning events](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-kubectl-get-events){:target="_blank"}

    - [Understanding Kubernetes contexts and namespaces](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}

    - [Formatting output in JSON file with kubectl](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#formatting-output){:target="_blank"}

    - [Filtering and organizing data with kubectl](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-kubectl-get){:target="_blank"}'
  explanation: This command gets warning events from a specific context and namespace
    in Kubernetes, then formats the output into a JSON file. It also filters and organizes
    the data to generate a summary of the events within the last 30 minutes.
  multi_line_details: "```sh\n# Set field-selector to Warning and context and namespace\n\
    kubectl get events --field-selector type=Warning \\\n  --context ${CONTEXT} -n\
    \ ${NAMESPACE} -o json > $HOME/warning_events.json\n\n# Use jq to process JSON\
    \ file\ncat $HOME/warning_events.json | jq -r '[.items[] | \n  {\n    namespace:\
    \ .involvedObject.namespace, \n    kind: .involvedObject.kind, \n    baseName:\
    \ (\n      (if .involvedObject.kind == \"Pod\" then (.involvedObject.name | split(\"\
    -\")[:-1] | join(\"-\")) else .involvedObject.name end) // \"\"\n    ), \n   \
    \ count: .count, \n    firstTimestamp: .firstTimestamp, \n    lastTimestamp: .lastTimestamp,\
    \ \n    reason: .reason, \n    message: .message\n  }\n] | group_by(.namespace,\
    \ .kind, .baseName) | map(\n  {\n    object: (.[0].namespace + \"/\" + .[0].kind\
    \ + \"/\" + .[0].baseName), \n    total_events: (reduce .[] as $event (0; . +\
    \ $event.count)), \n    summary_messages: (map(.message) | unique | join(\"; \"\
    )), \n    oldest_timestamp: (map(.firstTimestamp) | sort | first), \n    most_recent_timestamp:\
    \ (map(.lastTimestamp) | sort | last)\n  }\n) | map(select((now - ((.most_recent_timestamp\
    \ | fromdateiso8601)))/60 <= 30))'\n```\n\nThis command retrieves warning events\
    \ from a Kubernetes cluster using `kubectl`, stores the output in a JSON file,\
    \ and processes the data using `jq` to extract specific information related to\
    \ the warning events. It then filters the output based on the age of the events\
    \ and selects those that are less than or equal to 30 minutes old."
  name: troubleshoot_warning_events_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} -o json | jq -r
    --argjson exit_code_explanations ''{"0": "Success", "1": "Error", "2": "Misconfiguration",
    "130": "Pod terminated by SIGINT", "134": "Abnormal Termination SIGABRT", "137":
    "Pod terminated by SIGKILL - Possible OOM", "143":"Graceful Termination SIGTERM"}''
    ''.items[] | select(.status.containerStatuses != null) | select(any(.status.containerStatuses[];
    .restartCount > 0)) | "---\npod_name: \(.metadata.name)\n" + (.status.containerStatuses[]
    | "containers: \(.name)\nrestart_count: \(.restartCount)\nmessage: \(.state.waiting.message
    // "N/A")\nterminated_reason: \(.lastState.terminated.reason // "N/A")\nterminated_finishedAt:
    \(.lastState.terminated.finishedAt // "N/A")\nterminated_exitCode: \(.lastState.terminated.exitCode
    // "N/A")\nexit_code_explanation: \($exit_code_explanations[.lastState.terminated.exitCode
    | tostring] // "Unknown exit code")") + "\n---\n"'''
  doc_links: '

    - [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [JSON output format in kubectl](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#formatting-output-using-jsonpath){:target="_blank"}

    - [jq tool documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command uses kubectl to get information about pods in a specific
    context and namespace in JSON format, then uses jq to format the output to include
    details about any containers that have been restarted, including the exit code
    and an explanation for each exit code based on a predefined set of codes.
  multi_line_details: "```bash\n#!/bin/bash\n\n# Description: Extracts information\
    \ about pod restarts and errors from Kubernetes pods\n# Context: Kubernetes cluster\
    \ context\n# Namespace: Kubernetes namespace\n\nkubectl get pods --context=${CONTEXT}\
    \ -n ${NAMESPACE} -o json | \\\n    jq -r --argjson exit_code_explanations '{\"\
    0\": \"Success\", \"1\": \"Error\", \"2\": \"Misconfiguration\", \"130\": \"Pod\
    \ terminated by SIGINT\", \"134\": \"Abnormal Termination SIGABRT\", \"137\":\
    \ \"Pod terminated by SIGKILL - Possible OOM\", \"143\":\"Graceful Termination\
    \ SIGTERM\"}' \\\n    '.items[] | select(.status.containerStatuses != null) |\
    \ select(any(.status.containerStatuses[]; .restartCount > 0)) | \"---\\npod_name:\
    \ \\(.metadata.name)\\n\" + (.status.containerStatuses[] | \"containers: \\(.name)\\\
    nrestart_count: \\(.restartCount)\\nmessage: \\(.state.waiting.message // \"N/A\"\
    )\\nterminated_reason: \\(.lastState.terminated.reason // \"N/A\")\\nterminated_finishedAt:\
    \ \\(.lastState.terminated.finishedAt // \"N/A\")\\nterminated_exitCode: \\(.lastState.terminated.exitCode\
    \ // \"N/A\")\\nexit_code_explanation: \\($exit_code_explanations[.lastState.terminated.exitCode\
    \ | tostring] // \"Unknown exit code\")\") + \"\\n---\\n\"'\n```"
  name: troubleshoot_container_restarts_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Pending
    --no-headers -o json | jq -r ''.items[] | "pod_name: \(.metadata.name)\nstatus:
    \(.status.phase // "N/A")\nmessage: \(.status.conditions[0].message // "N/A")\nreason:
    \(.status.conditions[0].reason // "N/A")\ncontainerStatus: \((.status.containerStatuses[0].state
    // "N/A"))\ncontainerMessage: \(.status.containerStatuses[0].state.waiting?.message
    // "N/A")\ncontainerReason: \(.status.containerStatuses[0].state.waiting?.reason
    // "N/A")\n------------"'''
  doc_links: '

    - [Kubernetes Official Documentation](https://kubernetes.io/docs/home/){:target="_blank"}

    - [Kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Jq Documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command retrieves information about pods in a specific context
    and namespace that are in a pending state, and formats the output using jq to
    display details about each pod's name, status, message, reason, container status,
    container message, and container reason.
  multi_line_details: '```bash

    #!/bin/bash


    # This command retrieves information about pods in a specific namespace and context,
    filtering by pending status

    # It then uses jq to format the output in a human-readable way


    kubectl get pods \

    --context=${CONTEXT} \

    -n ${NAMESPACE} \

    --field-selector=status.phase=Pending \

    --no-headers \

    -o json | \

    jq -r ''.items[] | "pod_name: \(.metadata.name)\nstatus: \(.status.phase // "N/A")\nmessage:
    \(.status.conditions[0].message // "N/A")\nreason: \(.status.conditions[0].reason
    // "N/A")\ncontainerStatus: \((.status.containerStatuses[0].state // "N/A"))\ncontainerMessage:
    \(.status.containerStatuses[0].state.waiting?.message // "N/A")\ncontainerReason:
    \(.status.containerStatuses[0].state.waiting?.reason // "N/A")\n------------"''

    ```'
  name: troubleshoot_pending_pods_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Failed
    --no-headers -o json | jq -r --argjson exit_code_explanations ''{"0": "Success",
    "1": "Error", "2": "Misconfiguration", "130": "Pod terminated by SIGINT", "134":
    "Abnormal Termination SIGABRT", "137": "Pod terminated by SIGKILL - Possible OOM",
    "143":"Graceful Termination SIGTERM"}'' ''.items[] | "pod_name: \(.metadata.name)\nrestart_count:
    \(.status.containerStatuses[0].restartCount // "N/A")\nmessage: \(.status.message
    // "N/A")\nterminated_finishedAt: \(.status.containerStatuses[0].state.terminated.finishedAt
    // "N/A")\nexit_code: \(.status.containerStatuses[0].state.terminated.exitCode
    // "N/A")\nexit_code_explanation: \($exit_code_explanations[.status.containerStatuses[0].state.terminated.exitCode
    | tostring] // "Unknown exit code")\n------------"'''
  doc_links: '

    - [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [pods](https://kubernetes.io/docs/concepts/workloads/pods/){:target="_blank"}

    - [specific context and namespace](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#context-and-namespace){:target="_blank"}

    - [failed pods](https://kubernetes.io/docs/tasks/debug-application-cluster/determine-reason-pod-failure/){:target="_blank"}

    - [jq](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command uses kubectl to get information about pods in a specific
    context and namespace that have failed. It then formats the output using "jq"
    to provide details about each failed pod, including its name, restart count, message,
    termination time, exit code, and an explanation of the exit code.
  multi_line_details: "```bash\n# Get pods with specific field selector and output\
    \ as JSON\nkubectl get pods \\\n  --context=${CONTEXT} \\\n  -n ${NAMESPACE} \\\
    \n  --field-selector=status.phase=Failed \\\n  --no-headers \\\n  -o json | \\\
    \n  \n  # Use jq to process the JSON output\n  jq -r \\\n    --argjson exit_code_explanations\
    \ '{\"0\": \"Success\", \"1\": \"Error\", \"2\": \"Misconfiguration\", \"130\"\
    : \"Pod terminated by SIGINT\", \"134\": \"Abnormal Termination SIGABRT\", \"\
    137\": \"Pod terminated by SIGKILL - Possible OOM\", \"143\":\"Graceful Termination\
    \ SIGTERM\"}' \\\n  \n    # Extract specific fields and format the output\n  \
    \  '.items[] | \"pod_name: \\(.metadata.name)\\nrestart_count: \\(.status.containerStatuses[0].restartCount\
    \ // \"N/A\")\\nmessage: \\(.status.message // \"N/A\")\\nterminated_finishedAt:\
    \ \\(.status.containerStatuses[0].state.terminated.finishedAt // \"N/A\")\\nexit_code:\
    \ \\(.status.containerStatuses[0].state.terminated.exitCode // \"N/A\")\\nexit_code_explanation:\
    \ \\($exit_code_explanations[.status.containerStatuses[0].state.terminated.exitCode\
    \ | tostring] // \"Unknown exit code\")\\n------------\"'\n```\n\nThis multi-line\
    \ command retrieves failed pods, processes the JSON output using `jq`, and formats\
    \ the extracted fields with a descriptive explanation of the exit code."
  name: troubleshoot_failed_pods_in_namespace_namespace
- command: 'kubectl get pods --context ${CONTEXT} -n ${NAMESPACE} -o json | jq -r
    ''.items[] | select(.status.conditions[]? | select(.type == "Ready" and .status
    == "False" and .reason != "PodCompleted")) | {kind: .kind, name: .metadata.name,
    conditions: .status.conditions}'' | jq -s ''.'''
  doc_links: '

    - [Kubernetes Concepts](https://kubernetes.io/docs/concepts/){:target="_blank"}

    - [Kubectl Command Documentation](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands){:target="_blank"}

    - [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [jq Tool Documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command retrieves information about pods in a Kubernetes cluster,
    within a specific context and namespace, and displays it in JSON format. It uses
    the `jq` tool to filter out specific conditions of the pods such as status not
    being ready or completed.
  multi_line_details: "```bash\n# This command fetches a list of pods in the specified\
    \ context and namespace then filters out those that are not ready or have been\
    \ completed\nkubectl get pods --context ${CONTEXT} -n ${NAMESPACE} -o json | \n\
    \  jq -r '.items[] | select(.status.conditions[]? | select(.type == \"Ready\"\
    \ and .status == \"False\" and .reason != \"PodCompleted\")) | {kind: .kind, name:\
    \ .metadata.name, conditions: .status.conditions}' | \n  jq -s '.'\n```\n\nThe\
    \ first `jq` command selects and filters out only the relevant pods based on the\
    \ specified conditions, then the second `jq` command outputs the selected data\
    \ in JSON."
  name: troubleshoot_workload_status_conditions_in_namespace_namespace
- command: kubectl api-resources --verbs=list --namespaced -o name --context=${CONTEXT}
    | xargs -n 1 kubectl get --show-kind --ignore-not-found -n ${NAMESPACE} --context=${CONTEXT}
  doc_links: '

    - [kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [API Resources in Kubernetes](https://kubernetes.io/docs/reference/using-api/api-overview/){:target="_blank"}

    - [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}'
  explanation: This command uses kubectl to list all the API resources available in
    a given Kubernetes context, and then retrieves detailed information for each resource
    within a specific namespace. It is useful for quickly querying and understanding
    the resources available within a Kubernetes cluster.
  multi_line_details: '```bash

    # Command to list all resources in a Kubernetes cluster and get details for each
    resource

    #  using the specified context and namespace


    # List all resources in the Kubernetes cluster using the specified context

    kubectl api-resources --verbs=list --namespaced -o name --context=${CONTEXT} |


    # For each resource, get details using xargs with kubectl get command

    xargs -n 1 kubectl get --show-kind --ignore-not-found -n ${NAMESPACE} --context=${CONTEXT}

    ```'
  name: get_listing_of_resources_in_namespace_namespace
- command: 'kubectl get events --field-selector type!=Warning --context ${CONTEXT}
    -n ${NAMESPACE} -o json > $HOME/events.json && cat $HOME/events.json | jq -r ''[.items[]
    | {namespace: .involvedObject.namespace, kind: .involvedObject.kind, name: ((if
    .involvedObject and .involvedObject.kind == "Pod" then (.involvedObject.name |
    split("-")[:-1] | join("-")) else .involvedObject.name end) // ""), count: .count,
    firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason,
    message: .message}] | group_by(.namespace, .kind, .name) | .[] | {(.[0].namespace
    + "/" + .[0].kind + "/" + .[0].name): {events: .}}'' | jq -r --argjson threshold
    "${ANOMALY_THRESHOLD}" ''to_entries[] | {object: .key, oldest_timestamp: ([.value.events[]
    | .firstTimestamp] | min), most_recent_timestamp: (reduce .value.events[] as $event
    (.value.firstTimestamp; if ($event.lastTimestamp > .) then $event.lastTimestamp
    else . end)), events_per_minute: (reduce .value.events[] as $event (0; . + ($event.count
    / (((($event.lastTimestamp | fromdateiso8601) - ($event.firstTimestamp | fromdateiso8601))
    / 60) | if . == 0 then 1 else . end))) | floor), total_events: (reduce .value.events[]
    as $event (0; . + $event.count)), summary_messages: [.value.events[] | .message]
    | unique | join("; ")} | select(.events_per_minute > $threshold)'' | jq -s ''.'''
  doc_links: '

    - [Using JQ to process JSON](https://stedolan.github.io/jq/manual/){:target="_blank"}

    - [Formatting Data with JQ](https://programminghistorian.org/en/lessons/json-and-jq){:target="_blank"}'
  explanation: This command retrieves events from a Kubernetes cluster that are not
    warnings, and then filters and formats the data using jq to extract specific information
    about the events and present it in a structured JSON format.
  multi_line_details: "```bash\n# kubectl get events and format the output \nkubectl\
    \ get events \\\n  --field-selector type!=Warning \\\n    --context ${CONTEXT}\
    \ \\\n    -n ${NAMESPACE} \\\n    -o json > $HOME/events.json \\\n  && cat $HOME/events.json\
    \ | jq -r '[.items[] | {namespace: .involvedObject.namespace, kind: .involvedObject.kind,\
    \ name: ((if .involvedObject and .involvedObject.kind == \"Pod\" then (.involvedObject.name\
    \ | split(\"-\")[:-1] | join(\"-\")) else .involvedObject.name end) // \"\"),\
    \ count: .count, firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp,\
    \ reason: .reason, message: .message}] | group_by(.namespace, .kind, .name) |\
    \ .[] | {(.[0].namespace + \"/\" + .[0].kind + \"/\" + .[0].name): {events: .}}'\
    \ | jq -r --argjson threshold \"${ANOMALY_THRESHOLD}\" 'to_entries[] | {object:\
    \ .key, oldest_timestamp: ([.value.events[] | .firstTimestamp] | min), most_recent_timestamp:\
    \ (reduce .value.events[] as $event (.value.firstTimestamp; if ($event.lastTimestamp\
    \ > .) then $event.lastTimestamp else . end)), events_per_minute: (reduce .value.events[]\
    \ as $event (0; . + ($event.count / (((($event.lastTimestamp | fromdateiso8601)\
    \ - ($event.firstTimestamp | fromdateiso8601)) / 60) | if . == 0 then 1 else .\
    \ end))) | floor), total_events: (reduce .value.events[] as $event (0; . + $event.count)),\
    \ summary_messages: [.value.events[] | .message] | unique | join(\"; \")} | select(.events_per_minute\
    \ > $threshold)' | jq -s '.'\n```\n```plaintext\n# This command retrieves events\
    \ from a Kubernetes cluster using `kubectl`. It filters based on certain criteria,\
    \ then uses `jq` to format the JSON output in a specific way. The resulting structured\
    \ data is displayed at the end in an organized manner. Note that this command\
    \ is quite complex and involves multiple operations chained together.\n```"
  name: check_event_anomalies_in_namespace_namespace
- command: 'services=($(kubectl get svc -o=name --context=${CONTEXT} -n ${NAMESPACE}))
    && [ \${#services[@]} -eq 0 ] && echo "No services found." || { > "logs.json";
    for service in "\${services[@]}"; do kubectl logs $service --limit-bytes=256000
    --since=2h --context=${CONTEXT} -n ${NAMESPACE} 2>/dev/null | grep -Ei "${SERVICE_ERROR_PATTERN}"
    | grep -Ev "${SERVICE_EXCLUDE_PATTERN}" | while read -r line; do service_name="\${service#*/}";
    message=$(echo "$line" | jq -aRs .); printf ''{"service": "%s", "message": %s}\n''
    "\${service_name}" "$message" >> "logs.json"; done; done; [ ! -s "logs.json" ]
    && echo "No log entries found." || cat "logs.json" | jq -s ''[ (group_by(.service)
    | map({service: .[0].service, total_logs: length})), (group_by(.service) | map({service:
    .[0].service, top_logs: (group_by(.message[0:200]) | map({message_start: .[0].message[0:200],
    count: length}) | sort_by(.count) | reverse | .[0:3])})) ] | add''; } > $HOME/output;
    cat $HOME/output'
  doc_links: '

    - [Kubernetes - Contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}

    - [Kubernetes - Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubernetes - Logging](https://kubernetes.io/docs/concepts/cluster-administration/logging/){:target="_blank"}

    - [Regular Expressions Overview](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions){:target="_blank"}

    - [JSON File Format](https://www.json.org/json-en.html){:target="_blank"}'
  explanation: This command retrieves the logs for all services in a specified Kubernetes
    context and namespace, filters them based on error and exclude patterns, then
    outputs the results to a JSON file. If no logs are found for any service, it will
    return a message indicating so.
  multi_line_details: "```bash\n# Set the services array to contain service names\
    \ from kubectl get svc\nservices=($(kubectl get svc -o=name --context=${CONTEXT}\
    \ -n ${NAMESPACE}))\n# Check if no services have been found and print a message\
    \ if there are none\nif [ \\${#services[@]} -eq 0 ]; then\n  echo \"No services\
    \ found.\"\nelse\n  # Create the logs.json file and run a loop through each service\
    \ to gather logs, excluding unwanted patterns\n  > \"logs.json\"; \n  for service\
    \ in \"\\${services[@]}\"; do\n    kubectl logs $service --limit-bytes=256000\
    \ --since=2h --context=${CONTEXT} -n ${NAMESPACE} 2>/dev/null | grep -Ei \"${SERVICE_ERROR_PATTERN}\"\
    \ | grep -Ev \"${SERVICE_EXCLUDE_PATTERN}\" | while read -r line; do \n      service_name=\"\
    \\${service#*/}\"\n      message=$(echo \"$line\" | jq -aRs .)\n      printf '{\"\
    service\": \"%s\", \"message\": %s}\\n' \"\\${service_name}\" \"$message\" >>\
    \ \"logs.json\"\n    done\n  done\n  # Check if the logs.json file is empty and\
    \ print a message if no log entries are found\n  [ ! -s \"logs.json\" ] && echo\
    \ \"No log entries found.\" || \n  # Generate output containing grouped log data\
    \ using jq and store it in the $HOME directory\n  cat \"logs.json\" | jq -s '[\
    \ (group_by(.service) | map({service: .[0].service, total_logs: length})), (group_by(.service)\
    \ | map({service: .[0].service, top_logs: (group_by(.message[0:200]) | map({message_start:\
    \ .[0].message[0:200], count: length}) | sort_by(.count) | reverse | .[0:3])}))\
    \ ] | add' > $HOME/output\n  # Print the output\n  cat $HOME/output\nfi\n```"
  name: troubleshoot_services_and_application_workloads_in_namespace_namespace
- command: context="${CONTEXT}"; namespace="${NAMESPACE}"; check_health() { local
    type=$1; local name=$2; local replicas=$3; local selector=$4; local pdbs=$(kubectl
    --context "$context" --namespace "$namespace" get pdb -o json | jq -c --arg selector
    "$selector" '.items[] | select(.spec.selector.matchLabels | to_entries[] | .key
    + "=" + .value == $selector)'); if [[ $replicas -gt 1 && -z "$pdbs" ]]; then printf
    "%-30s %-30s %-10s\n" "$type/$name" "" "Missing"; else echo "$pdbs" | jq -c .
    | while IFS= read -r pdb; do local pdbName=$(echo "$pdb" | jq -r '.metadata.name');
    local minAvailable=$(echo "$pdb" | jq -r '.spec.minAvailable // ""'); local maxUnavailable=$(echo
    "$pdb" | jq -r '.spec.maxUnavailable // ""'); if [[ "$minAvailable" == "100%"
    || "$maxUnavailable" == "0" || "$maxUnavailable" == "0%" ]]; then printf "%-30s
    %-30s %-10s\n" "$type/$name" "$pdbName" "Risky"; elif [[ $replicas -gt 1 && ("$minAvailable"
    != "100%" || "$maxUnavailable" != "0" || "$maxUnavailable" != "0%") ]]; then printf
    "%-30s %-30s %-10s\n" "$type/$name" "$pdbName" "OK"; fi; done; fi; }; echo "Deployments:";
    echo "-----------"; printf "%-30s %-30s %-10s\n" "NAME" "PDB" "STATUS"; kubectl
    --context "$context" --namespace "$namespace" get deployments -o json | jq -c
    '.items[] | "\(.metadata.name) \(.spec.replicas) \(.spec.selector.matchLabels
    | to_entries[] | .key + "=" + .value)"' | while read -r line; do check_health
    "Deployment" $(echo $line | tr -d '"'); done; echo ""; echo "Statefulsets:"; echo
    "-------------"; printf "%-30s %-30s %-10s\n" "NAME" "PDB" "STATUS"; kubectl --context
    "$context" --namespace "$namespace" get statefulsets -o json | jq -c '.items[]
    | "\(.metadata.name) \(.spec.replicas) \(.spec.selector.matchLabels | to_entries[]
    | .key + "=" + .value)"' | while read -r line; do check_health "StatefulSet" $(echo
    $line | tr -d '"'); done
  doc_links: '

    - [Kubernetes official documentation for deploying applications](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/){:target="_blank"}

    - [Understanding StatefulSets in Kubernetes](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/){:target="_blank"}

    - [Managing Pod Disruption Budgets](https://kubernetes.io/docs/tasks/run-application/configure-pdb/){:target="_blank"}'
  explanation: This command checks the health status of deployments and statefulsets
    in a Kubernetes cluster by looking at their corresponding Pod Disruption Budgets
    (PDBs) and prints the status of each one as OK, Risky, or Missing. It does this
    by querying the PDBs for each deployment and statefulset and comparing their minimum
    availability and maximum unavailability settings with the number of replicas specified
    in the deployment/statefulset.
  multi_line_details: "```bash\n#!/bin/bash\n\n# Set context and namespace variables\
    \ based on provided values\ncontext=\"${CONTEXT}\"\nnamespace=\"${NAMESPACE}\"\
    \n\n# Function to check the health of a resource\ncheck_health() { \n    local\
    \ type=$1; \n    local name=$2; \n    local replicas=$3; \n    local selector=$4;\
    \ \n    local pdbs=$(kubectl --context \"$context\" --namespace \"$namespace\"\
    \ get pdb -o json | jq -c --arg selector \"$selector\" '.items[] | select(.spec.selector.matchLabels\
    \ | to_entries[] | .key + \"=\" + .value == $selector)'); \n    if [[ $replicas\
    \ -gt 1 && -z \"$pdbs\" ]]; then \n        printf \"%-30s %-30s %-10s\\n\" \"\
    $type/$name\" \"\" \"Missing\"; \n    else \n        echo \"$pdbs\" | jq -c .\
    \ | while IFS= read -r pdb; do \n            local pdbName=$(echo \"$pdb\" | jq\
    \ -r '.metadata.name'); \n            local minAvailable=$(echo \"$pdb\" | jq\
    \ -r '.spec.minAvailable // \"\"'); \n            local maxUnavailable=$(echo\
    \ \"$pdb\" | jq -r '.spec.maxUnavailable // \"\"); \n            if [[ \"$minAvailable\"\
    \ == \"100%\" || \"$maxUnavailable\" == \"0\" || \"$maxUnavailable\" == \"0%\"\
    \ ]]; then \n                printf \"%-30s %-30s %-10s\\n\" \"$type/$name\" \"\
    $pdbName\" \"Risky\"; \n            elif [[ $replicas -gt 1 && (\"$minAvailable\"\
    \ != \"100%\" || \"$maxUnavailable\" != \"0\" || \"$maxUnavailable\" != \"0%\"\
    ) ]]; then \n                printf \"%-30s %-30s %-10s\\n\" \"$type/$name\" \"\
    $pdbName\" \"OK\"; \n            fi; \n        done; \n    fi; \n}; \n\n# Get\
    \ health status for Deployments\necho \"Deployments:\";\necho \"-----------\"\
    ; \nprintf \"%-30s %-30s %-10s\\n\" \"NAME\" \"PDB\" \"STATUS\"; \nkubectl --context\
    \ \"$context\" --namespace \"$namespace\" get deployments -o json | jq -c '.items[]\
    \ | \"\\(.metadata.name) \\(.spec.replicas) \\(.spec.selector.matchLabels | to_entries[]\
    \ | .key + \"=\" + .value)\"' | while read -r line; do \n    check_health \"Deployment\"\
    \ $(echo $line | tr -d '\"'); \ndone; \necho \"\"; \n\n# Get health status for\
    \ Statefulsets\necho \"Statefulsets:\";\necho \"-------------\"; \nprintf \"%-30s\
    \ %-30s %-10s\\n\" \"NAME\" \"PDB\" \"STATUS\"; \nkubectl --context \"$context\"\
    \ --namespace \"$namespace\" get statefulsets -o json | jq -c '.items[] | \"\\\
    (.metadata.name) \\(.spec.replicas) \\(.spec.selector.matchLabels | to_entries[]\
    \ | .key + \"=\" + .value)\"' | while read -r line; do \n    check_health \"StatefulSet\"\
    \ $(echo $line | tr -d '\"'); \ndone\n```\nIn this multi-line command, docstrings/comments\
    \ are added at the beginning of each section to explain its purpose. Each subcommand\
    \ has also been broken down into individual lines for readability and clarity."
  name: check_missing_or_risky_poddisruptionbudget_policies_in_namepace_namespace
