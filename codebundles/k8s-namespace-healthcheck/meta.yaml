commands:
- command: 'kubectl get events --field-selector type=Warning --context ${CONTEXT}
    -n ${NAMESPACE} -o json > $HOME/warning_events.json && cat $HOME/warning_events.json
    | jq -r ''[.items[] | {namespace: .involvedObject.namespace, kind: .involvedObject.kind,
    baseName: ((if .involvedObject.kind == "Pod" then (.involvedObject.name | split("-")[:-1]
    | join("-")) else .involvedObject.name end) // ""), count: .count, firstTimestamp:
    .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason, message: .message}]
    | group_by(.namespace, .kind, .baseName) | map({object: (.[0].namespace + "/"
    + .[0].kind + "/" + .[0].baseName), total_events: (reduce .[] as $event (0; .
    + $event.count)), summary_messages: (map(.message) | unique | join("; ")), oldest_timestamp:
    (map(.firstTimestamp) | sort | first), most_recent_timestamp: (map(.lastTimestamp)
    | sort | last)}) | map(select((now - ((.most_recent_timestamp | fromdateiso8601)))/60
    <= 30))'''
  doc_links: '

    - [kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Kubectl Output Formats](https://kubernetes.io/docs/reference/kubectl/jsonpath/){:target="_blank"}

    - [JSONPath Examples](https://goessner.net/articles/JsonPath/){:target="_blank"}'
  explanation: This command is a complex kubectl query to get events of type Warning
    from a specific context and namespace, format the output as JSON, and extract
    specific information such as namespace, kind, base name, count, timestamps, reason,
    and message for further analysis.
  multi_line_details: "\n# Set the context and namespace for the kubectl command\n\
    CONTEXT=\"example-context\"\nNAMESPACE=\"example-namespace\"\n\n# Get events of\
    \ type Warning using kubectl and save them to a JSON file in the user's home directory\n\
    kubectl get events --field-selector type=Warning --context ${CONTEXT} -n ${NAMESPACE}\
    \ -o json > $HOME/warning_events.json \n\n# Use jq to parse the JSON file, extract\
    \ relevant information, and filter events that occurred within the last 30 minutes\n\
    cat $HOME/warning_events.json | \\\njq -r '[.items[] | {namespace: .involvedObject.namespace,\
    \ kind: .involvedObject.kind, \n    baseName: ((if .involvedObject.kind == \"\
    Pod\" then (.involvedObject.name | split(\"-\")[:-1] | join(\"-\")) \n       \
    \        else .involvedObject.name end) // \"\"), \n    count: .count, firstTimestamp:\
    \ .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason, message: .message}]\
    \ \n    | group_by(.namespace, .kind, .baseName) \n    | map({object: (.[0].namespace\
    \ + \"/\" + .[0].kind + \"/\" + .[0].baseName), \n           total_events: (reduce\
    \ .[] as $event (0; . + $event.count)), \n           summary_messages: (map(.message)\
    \ | unique | join(\"; \")), \n           oldest_timestamp: (map(.firstTimestamp)\
    \ | sort | first), \n           most_recent_timestamp: (map(.lastTimestamp) |\
    \ sort | last)}) \n    | map(select((now - ((.most_recent_timestamp | fromdateiso8601)))/60\
    \ <= 30))'\n\nThis multi-line command includes comments to explain each step,\
    \ making it easier for newer or less experienced devops engineers to understand\
    \ and learn from."
  name: troubleshoot_warning_events_in_namespace_namespace
- command: 'kubectl get events --field-selector type=Warning --context ${CONTEXT}
    -n ${NAMESPACE} -o json > $HOME/warning_events.json && cat $HOME/warning_events.json
    | jq -r ''[.items[] | {namespace: .involvedObject.namespace, kind: .involvedObject.kind,
    baseName: ((if .involvedObject.kind == "Pod" then (.involvedObject.name | split("-")[:-1]
    | join("-")) else .involvedObject.name end) // ""), count: .count, firstTimestamp:
    .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason, message: .message}]
    | group_by(.namespace, .kind, .baseName) | map({object: (.[0].namespace + "/"
    + .[0].kind + "/" + .[0].baseName), total_events: (reduce .[] as $event (0; .
    + $event.count)), summary_messages: (map(.message) | unique | join("; ")), oldest_timestamp:
    (map(.firstTimestamp) | sort | first), most_recent_timestamp: (map(.lastTimestamp)
    | sort | last)}) | map(select((now - ((.most_recent_timestamp | fromdateiso8601)))/60
    <= 30))'''
  doc_links: '

    - [kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Kubectl Output Formats](https://kubernetes.io/docs/reference/kubectl/jsonpath/){:target="_blank"}

    - [JSONPath Examples](https://goessner.net/articles/JsonPath/){:target="_blank"}'
  explanation: This command is a complex kubectl query to get events of type Warning
    from a specific context and namespace, format the output as JSON, and extract
    specific information such as namespace, kind, base name, count, timestamps, reason,
    and message for further analysis.
  multi_line_details: "\n# Set the context and namespace for the kubectl command\n\
    CONTEXT=\"example-context\"\nNAMESPACE=\"example-namespace\"\n\n# Get events of\
    \ type Warning using kubectl and save them to a JSON file in the user's home directory\n\
    kubectl get events --field-selector type=Warning --context ${CONTEXT} -n ${NAMESPACE}\
    \ -o json > $HOME/warning_events.json \n\n# Use jq to parse the JSON file, extract\
    \ relevant information, and filter events that occurred within the last 30 minutes\n\
    cat $HOME/warning_events.json | \\\njq -r '[.items[] | {namespace: .involvedObject.namespace,\
    \ kind: .involvedObject.kind, \n    baseName: ((if .involvedObject.kind == \"\
    Pod\" then (.involvedObject.name | split(\"-\")[:-1] | join(\"-\")) \n       \
    \        else .involvedObject.name end) // \"\"), \n    count: .count, firstTimestamp:\
    \ .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason, message: .message}]\
    \ \n    | group_by(.namespace, .kind, .baseName) \n    | map({object: (.[0].namespace\
    \ + \"/\" + .[0].kind + \"/\" + .[0].baseName), \n           total_events: (reduce\
    \ .[] as $event (0; . + $event.count)), \n           summary_messages: (map(.message)\
    \ | unique | join(\"; \")), \n           oldest_timestamp: (map(.firstTimestamp)\
    \ | sort | first), \n           most_recent_timestamp: (map(.lastTimestamp) |\
    \ sort | last)}) \n    | map(select((now - ((.most_recent_timestamp | fromdateiso8601)))/60\
    \ <= 30))'\n\nThis multi-line command includes comments to explain each step,\
    \ making it easier for newer or less experienced devops engineers to understand\
    \ and learn from."
  name: troubleshoot_warning_events_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} -o json | jq -r
    --argjson exit_code_explanations ''{"0": "Success", "1": "Error", "2": "Misconfiguration",
    "130": "Pod terminated by SIGINT", "134": "Abnormal Termination SIGABRT", "137":
    "Pod terminated by SIGKILL - Possible OOM", "143":"Graceful Termination SIGTERM"}''
    ''.items[] | select(.status.containerStatuses != null) | select(any(.status.containerStatuses[];
    .restartCount > 0)) | "---\npod_name: \(.metadata.name)\n" + (.status.containerStatuses[]
    | "containers: \(.name)\nrestart_count: \(.restartCount)\nmessage: \(.state.waiting.message
    // "N/A")\nterminated_reason: \(.lastState.terminated.reason // "N/A")\nterminated_finishedAt:
    \(.lastState.terminated.finishedAt // "N/A")\nterminated_exitCode: \(.lastState.terminated.exitCode
    // "N/A")\nexit_code_explanation: \($exit_code_explanations[.lastState.terminated.exitCode
    | tostring] // "Unknown exit code")") + "\n---\n"'''
  doc_links: '

    - [kubectl get pods](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [kubectl contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#context){:target="_blank"}

    - [kubectl namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [jq documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command uses kubectl to get information about pods in a specific
    context and namespace, then uses jq to format the output and provide detailed
    explanations for different exit codes related to container restarts.
  multi_line_details: "\n# Set the context and namespace for the Kubernetes cluster\n\
    CONTEXT=my-context\nNAMESPACE=my-namespace\n\n# Get a list of pods in JSON format\
    \ and use jq to extract relevant information\nkubectl get pods --context=${CONTEXT}\
    \ -n ${NAMESPACE} -o json | jq -r --argjson exit_code_explanations '{\"0\": \"\
    Success\", \"1\": \"Error\", \"2\": \"Misconfiguration\", \"130\": \"Pod terminated\
    \ by SIGINT\", \"134\": \"Abnormal Termination SIGABRT\", \"137\": \"Pod terminated\
    \ by SIGKILL - Possible OOM\", \"143\":\"Graceful Termination SIGTERM\"}' '.items[]\
    \ | select(.status.containerStatuses != null) | select(any(.status.containerStatuses[];\
    \ .restartCount > 0)) | \n    # Print a separator to distinguish different pods\n\
    \    \"---\\npod_name: \\(.metadata.name)\\n\" + (.status.containerStatuses[]\
    \ | \"containers: \\(.name)\\nrestart_count: \\(.restartCount)\\nmessage: \\(.state.waiting.message\
    \ // \"N/A\")\\nterminated_reason: \\(.lastState.terminated.reason // \"N/A\"\
    )\\nterminated_finishedAt: \\(.lastState.terminated.finishedAt // \"N/A\")\\nterminated_exitCode:\
    \ \\(.lastState.terminated.exitCode // \"N/A\")\\n\n    # Map the exit code to\
    \ an explanation using $exit_code_explanations\n    exit_code_explanation: \\\
    ($exit_code_explanations[.lastState.terminated.exitCode | tostring] // \"Unknown\
    \ exit code\")\") + \"\\n---\\n\"'\n\nThis multi-line command breaks down the\
    \ process of getting pods from a Kubernetes cluster, including setting the context\
    \ and namespace, interacting with the `kubectl` command, and processing the JSON\
    \ output using `jq`. It also includes comments throughout to explain each step\
    \ for clarity and understanding."
  name: troubleshoot_container_restarts_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} -o json | jq -r
    --argjson exit_code_explanations ''{"0": "Success", "1": "Error", "2": "Misconfiguration",
    "130": "Pod terminated by SIGINT", "134": "Abnormal Termination SIGABRT", "137":
    "Pod terminated by SIGKILL - Possible OOM", "143":"Graceful Termination SIGTERM"}''
    ''.items[] | select(.status.containerStatuses != null) | select(any(.status.containerStatuses[];
    .restartCount > 0)) | "---\npod_name: \(.metadata.name)\n" + (.status.containerStatuses[]
    | "containers: \(.name)\nrestart_count: \(.restartCount)\nmessage: \(.state.waiting.message
    // "N/A")\nterminated_reason: \(.lastState.terminated.reason // "N/A")\nterminated_finishedAt:
    \(.lastState.terminated.finishedAt // "N/A")\nterminated_exitCode: \(.lastState.terminated.exitCode
    // "N/A")\nexit_code_explanation: \($exit_code_explanations[.lastState.terminated.exitCode
    | tostring] // "Unknown exit code")") + "\n---\n"'''
  doc_links: '

    - [kubectl get pods](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [kubectl contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#context){:target="_blank"}

    - [kubectl namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [jq documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command uses kubectl to get information about pods in a specific
    context and namespace, then uses jq to format the output and provide detailed
    explanations for different exit codes related to container restarts.
  multi_line_details: "\n# Set the context and namespace for the Kubernetes cluster\n\
    CONTEXT=my-context\nNAMESPACE=my-namespace\n\n# Get a list of pods in JSON format\
    \ and use jq to extract relevant information\nkubectl get pods --context=${CONTEXT}\
    \ -n ${NAMESPACE} -o json | jq -r --argjson exit_code_explanations '{\"0\": \"\
    Success\", \"1\": \"Error\", \"2\": \"Misconfiguration\", \"130\": \"Pod terminated\
    \ by SIGINT\", \"134\": \"Abnormal Termination SIGABRT\", \"137\": \"Pod terminated\
    \ by SIGKILL - Possible OOM\", \"143\":\"Graceful Termination SIGTERM\"}' '.items[]\
    \ | select(.status.containerStatuses != null) | select(any(.status.containerStatuses[];\
    \ .restartCount > 0)) | \n    # Print a separator to distinguish different pods\n\
    \    \"---\\npod_name: \\(.metadata.name)\\n\" + (.status.containerStatuses[]\
    \ | \"containers: \\(.name)\\nrestart_count: \\(.restartCount)\\nmessage: \\(.state.waiting.message\
    \ // \"N/A\")\\nterminated_reason: \\(.lastState.terminated.reason // \"N/A\"\
    )\\nterminated_finishedAt: \\(.lastState.terminated.finishedAt // \"N/A\")\\nterminated_exitCode:\
    \ \\(.lastState.terminated.exitCode // \"N/A\")\\n\n    # Map the exit code to\
    \ an explanation using $exit_code_explanations\n    exit_code_explanation: \\\
    ($exit_code_explanations[.lastState.terminated.exitCode | tostring] // \"Unknown\
    \ exit code\")\") + \"\\n---\\n\"'\n\nThis multi-line command breaks down the\
    \ process of getting pods from a Kubernetes cluster, including setting the context\
    \ and namespace, interacting with the `kubectl` command, and processing the JSON\
    \ output using `jq`. It also includes comments throughout to explain each step\
    \ for clarity and understanding."
  name: troubleshoot_container_restarts_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Pending
    --no-headers -o json | jq -r ''.items[] | "pod_name: \(.metadata.name)\nstatus:
    \(.status.phase // "N/A")\nmessage: \(.status.conditions[0].message // "N/A")\nreason:
    \(.status.conditions[0].reason // "N/A")\ncontainerStatus: \((.status.containerStatuses[0].state
    // "N/A"))\ncontainerMessage: \(.status.containerStatuses[0].state.waiting?.message
    // "N/A")\ncontainerReason: \(.status.containerStatuses[0].state.waiting?.reason
    // "N/A")\n_______-"'''
  doc_links: '

    - [kubectl overview](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [kubectl get pods](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [kubectl contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#context){:target="_blank"}

    - [kubectl namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [jq manual](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command uses kubectl to retrieve information about specific pods
    in a certain context and namespace, and then formats the output using jq to display
    relevant details like pod name, status, message, reason, and container status.
  multi_line_details: "\n# Set the Kubernetes context and namespace to use for the\
    \ kubectl command\nCONTEXT=my-context\nNAMESPACE=my-namespace\n\n# Get pods from\
    \ the specified context and namespace that are in a Pending state\nkubectl get\
    \ pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Pending\
    \ --no-headers -o json \\\n\n# Pipe the output to jq to format it as specified,\
    \ printing the pod name, status, message, reason, and container status details\n\
    | jq -r '.items[] | \"pod_name: \\(.metadata.name)\\nstatus: \\(.status.phase\
    \ // \"N/A\")\\nmessage: \\(.status.conditions[0].message // \"N/A\")\\nreason:\
    \ \\(.status.conditions[0].reason // \"N/A\")\\ncontainerStatus: \\((.status.containerStatuses[0].state\
    \ // \"N/A\"))\\ncontainerMessage: \\(.status.containerStatuses[0].state.waiting?.message\
    \ // \"N/A\")\\ncontainerReason: \\(.status.containerStatuses[0].state.waiting?.reason\
    \ // \"N/A\")\\n_______-\"' \n"
  name: troubleshoot_pending_pods_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Pending
    --no-headers -o json | jq -r ''.items[] | "pod_name: \(.metadata.name)\nstatus:
    \(.status.phase // "N/A")\nmessage: \(.status.conditions[0].message // "N/A")\nreason:
    \(.status.conditions[0].reason // "N/A")\ncontainerStatus: \((.status.containerStatuses[0].state
    // "N/A"))\ncontainerMessage: \(.status.containerStatuses[0].state.waiting?.message
    // "N/A")\ncontainerReason: \(.status.containerStatuses[0].state.waiting?.reason
    // "N/A")\n_______-"'''
  doc_links: '

    - [kubectl overview](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [kubectl get pods](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [kubectl contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#context){:target="_blank"}

    - [kubectl namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [jq manual](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command uses kubectl to retrieve information about specific pods
    in a certain context and namespace, and then formats the output using jq to display
    relevant details like pod name, status, message, reason, and container status.
  multi_line_details: "\n# Set the Kubernetes context and namespace to use for the\
    \ kubectl command\nCONTEXT=my-context\nNAMESPACE=my-namespace\n\n# Get pods from\
    \ the specified context and namespace that are in a Pending state\nkubectl get\
    \ pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Pending\
    \ --no-headers -o json \\\n\n# Pipe the output to jq to format it as specified,\
    \ printing the pod name, status, message, reason, and container status details\n\
    | jq -r '.items[] | \"pod_name: \\(.metadata.name)\\nstatus: \\(.status.phase\
    \ // \"N/A\")\\nmessage: \\(.status.conditions[0].message // \"N/A\")\\nreason:\
    \ \\(.status.conditions[0].reason // \"N/A\")\\ncontainerStatus: \\((.status.containerStatuses[0].state\
    \ // \"N/A\"))\\ncontainerMessage: \\(.status.containerStatuses[0].state.waiting?.message\
    \ // \"N/A\")\\ncontainerReason: \\(.status.containerStatuses[0].state.waiting?.reason\
    \ // \"N/A\")\\n_______-\"' \n"
  name: troubleshoot_pending_pods_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Failed
    --no-headers -o json | jq -r --argjson exit_code_explanations ''{"0": "Success",
    "1": "Error", "2": "Misconfiguration", "130": "Pod terminated by SIGINT", "134":
    "Abnormal Termination SIGABRT", "137": "Pod terminated by SIGKILL - Possible OOM",
    "143":"Graceful Termination SIGTERM"}'' ''.items[] | "pod_name: \(.metadata.name)\nrestart_count:
    \(.status.containerStatuses[0].restartCount // "N/A")\nmessage: \(.status.message
    // "N/A")\nterminated_finishedAt: \(.status.containerStatuses[0].state.terminated.finishedAt
    // "N/A")\nexit_code: \(.status.containerStatuses[0].state.terminated.exitCode
    // "N/A")\nexit_code_explanation: \($exit_code_explanations[.status.containerStatuses[0].state.terminated.exitCode
    | tostring] // "Unknown exit code")\n_______-"'''
  doc_links: '

    - [kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Kubernetes Namespace](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [jq Manual](https://stedolan.github.io/jq/manual/){:target="_blank"}

    - [Understanding Kubernetes Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/){:target="_blank"}'
  explanation: This command uses kubectl to retrieve information about failed pods
    in a specific namespace, then formats and prints the results in JSON using the
    jq tool, including information like pod name, restart count, termination message,
    finished time, exit code, and an explanation of the exit code based on common
    values.
  multi_line_details: "\n# Set the context and namespace for the kubectl command\n\
    CONTEXT=my-context\nNAMESPACE=my-namespace\n\n# Use kubectl to get pods with a\
    \ failed status in the specified context and namespace, output as json\nkubectl\
    \ get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Failed\
    \ --no-headers -o json \n| \n# Pipe the output into jq to format and extract relevant\
    \ information\njq -r --argjson exit_code_explanations '{\"0\": \"Success\", \"\
    1\": \"Error\", \"2\": \"Misconfiguration\", \"130\": \"Pod terminated by SIGINT\"\
    , \"134\": \"Abnormal Termination SIGABRT\", \"137\": \"Pod terminated by SIGKILL\
    \ - Possible OOM\", \"143\":\"Graceful Termination SIGTERM\"}' \n'.items[] | \"\
    pod_name: \\(.metadata.name)\\nrestart_count: \\(.status.containerStatuses[0].restartCount\
    \ // \"N/A\")\\nmessage: \\(.status.message // \"N/A\")\\nterminated_finishedAt:\
    \ \\(.status.containerStatuses[0].state.terminated.finishedAt // \"N/A\")\\nexit_code:\
    \ \\(.status.containerStatuses[0].state.terminated.exitCode // \"N/A\")\\nexit_code_explanation:\
    \ \\($exit_code_explanations[.status.containerStatuses[0].state.terminated.exitCode\
    \ | tostring] // \"Unknown exit code\")\\n_______-\"'\n\n\nIn this multi-line\
    \ command, we set the desired context and namespace for the kubectl command before\
    \ running it. We then pipe the output into the `jq` command, which formats the\
    \ JSON output and extracts information about the failed pods, such as pod name,\
    \ restart count, message, termination time, exit code, and an explanation for\
    \ the exit code based on a predefined lookup table."
  name: troubleshoot_failed_pods_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Failed
    --no-headers -o json | jq -r --argjson exit_code_explanations ''{"0": "Success",
    "1": "Error", "2": "Misconfiguration", "130": "Pod terminated by SIGINT", "134":
    "Abnormal Termination SIGABRT", "137": "Pod terminated by SIGKILL - Possible OOM",
    "143":"Graceful Termination SIGTERM"}'' ''.items[] | "pod_name: \(.metadata.name)\nrestart_count:
    \(.status.containerStatuses[0].restartCount // "N/A")\nmessage: \(.status.message
    // "N/A")\nterminated_finishedAt: \(.status.containerStatuses[0].state.terminated.finishedAt
    // "N/A")\nexit_code: \(.status.containerStatuses[0].state.terminated.exitCode
    // "N/A")\nexit_code_explanation: \($exit_code_explanations[.status.containerStatuses[0].state.terminated.exitCode
    | tostring] // "Unknown exit code")\n_______-"'''
  doc_links: '

    - [kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Kubernetes Namespace](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [jq Manual](https://stedolan.github.io/jq/manual/){:target="_blank"}

    - [Understanding Kubernetes Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/){:target="_blank"}'
  explanation: This command uses kubectl to retrieve information about failed pods
    in a specific namespace, then formats and prints the results in JSON using the
    jq tool, including information like pod name, restart count, termination message,
    finished time, exit code, and an explanation of the exit code based on common
    values.
  multi_line_details: "\n# Set the context and namespace for the kubectl command\n\
    CONTEXT=my-context\nNAMESPACE=my-namespace\n\n# Use kubectl to get pods with a\
    \ failed status in the specified context and namespace, output as json\nkubectl\
    \ get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Failed\
    \ --no-headers -o json \n| \n# Pipe the output into jq to format and extract relevant\
    \ information\njq -r --argjson exit_code_explanations '{\"0\": \"Success\", \"\
    1\": \"Error\", \"2\": \"Misconfiguration\", \"130\": \"Pod terminated by SIGINT\"\
    , \"134\": \"Abnormal Termination SIGABRT\", \"137\": \"Pod terminated by SIGKILL\
    \ - Possible OOM\", \"143\":\"Graceful Termination SIGTERM\"}' \n'.items[] | \"\
    pod_name: \\(.metadata.name)\\nrestart_count: \\(.status.containerStatuses[0].restartCount\
    \ // \"N/A\")\\nmessage: \\(.status.message // \"N/A\")\\nterminated_finishedAt:\
    \ \\(.status.containerStatuses[0].state.terminated.finishedAt // \"N/A\")\\nexit_code:\
    \ \\(.status.containerStatuses[0].state.terminated.exitCode // \"N/A\")\\nexit_code_explanation:\
    \ \\($exit_code_explanations[.status.containerStatuses[0].state.terminated.exitCode\
    \ | tostring] // \"Unknown exit code\")\\n_______-\"'\n\n\nIn this multi-line\
    \ command, we set the desired context and namespace for the kubectl command before\
    \ running it. We then pipe the output into the `jq` command, which formats the\
    \ JSON output and extracts information about the failed pods, such as pod name,\
    \ restart count, message, termination time, exit code, and an explanation for\
    \ the exit code based on a predefined lookup table."
  name: troubleshoot_failed_pods_in_namespace_namespace
- command: 'kubectl get pods --context ${CONTEXT} -n ${NAMESPACE} -o json | jq -r
    ''.items[] | select(.status.conditions[]? | select(.type == "Ready" and .status
    == "False" and .reason != "PodCompleted")) | {kind: .kind, name: .metadata.name,
    conditions: .status.conditions}'' | jq -s ''.'''
  doc_links: '

    '
  explanation: This command retrieves information about pods in a specific namespace
    and context, then filters the results to show only pods that are not ready or
    have not completed, displaying their kind, name, and conditions in JSON format.
  multi_line_details: "\n# Set the context and namespace for the kubernetes command\n\
    CONTEXT=\"my-kube-context\"\nNAMESPACE=\"my-namespace\"\n\n# Get the existing\
    \ pods in JSON format using kubectl\nkubectl get pods --context ${CONTEXT} -n\
    \ ${NAMESPACE} -o json \\\n  # Use jq to filter out only the pods that meet specific\
    \ conditions\n  | jq -r '.items[] | select(.status.conditions[]? | select(.type\
    \ == \"Ready\" and .status == \"False\" and .reason != \"PodCompleted\")) \\\n\
    \  # Extract relevant information such as kind, name, and status conditions\n\
    \  | {kind: .kind, name: .metadata.name, conditions: .status.conditions}' \\\n\
    \  # Use jq with the -s option to treat the entire input as a single JSON array\n\
    \  | jq -s '.'\n\nThis multi-line command breaks down each step of the original\
    \ command with comments explaining what each part does. It's useful for newer\
    \ or less experienced devops engineers who may not be familiar with all the commands\
    \ used."
  name: troubleshoot_workload_status_conditions_in_namespace_namespace
- command: 'kubectl get pods --context ${CONTEXT} -n ${NAMESPACE} -o json | jq -r
    ''.items[] | select(.status.conditions[]? | select(.type == "Ready" and .status
    == "False" and .reason != "PodCompleted")) | {kind: .kind, name: .metadata.name,
    conditions: .status.conditions}'' | jq -s ''.'''
  doc_links: '

    '
  explanation: This command retrieves information about pods in a specific namespace
    and context, then filters the results to show only pods that are not ready or
    have not completed, displaying their kind, name, and conditions in JSON format.
  multi_line_details: "\n# Set the context and namespace for the kubernetes command\n\
    CONTEXT=\"my-kube-context\"\nNAMESPACE=\"my-namespace\"\n\n# Get the existing\
    \ pods in JSON format using kubectl\nkubectl get pods --context ${CONTEXT} -n\
    \ ${NAMESPACE} -o json \\\n  # Use jq to filter out only the pods that meet specific\
    \ conditions\n  | jq -r '.items[] | select(.status.conditions[]? | select(.type\
    \ == \"Ready\" and .status == \"False\" and .reason != \"PodCompleted\")) \\\n\
    \  # Extract relevant information such as kind, name, and status conditions\n\
    \  | {kind: .kind, name: .metadata.name, conditions: .status.conditions}' \\\n\
    \  # Use jq with the -s option to treat the entire input as a single JSON array\n\
    \  | jq -s '.'\n\nThis multi-line command breaks down each step of the original\
    \ command with comments explaining what each part does. It's useful for newer\
    \ or less experienced devops engineers who may not be familiar with all the commands\
    \ used."
  name: troubleshoot_workload_status_conditions_in_namespace_namespace
- command: kubectl api-resources --verbs=list --namespaced -o name --context=${CONTEXT}
    | xargs -n 1 kubectl get --show-kind --ignore-not-found -n ${NAMESPACE} --context=${CONTEXT}
  doc_links: '

    - [Kubernetes API Concepts](https://kubernetes.io/docs/concepts/){:target="_blank"}

    - [Kubernetes Namespace](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubectl Command Reference](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [Kubernetes API Endpoints](https://kubernetes.io/docs/concepts/overview/kubernetes-api/){:target="_blank"}'
  explanation: This command retrieves a list of API resources for a specific context,
    and then gets the details of each resource in a specified namespace using that
    context. It's a way to gather information about the available resources within
    a Kubernetes environment.
  multi_line_details: '

    # This command retrieves a list of Kubernetes resources in a specific namespace
    and context


    # First, we use kubectl to list the available resources using the specified verbs
    and namespace

    # We output the resource names using the ''-o name'' flag and specify the context
    to use

    kubectl api-resources --verbs=list --namespaced -o name --context=${CONTEXT} |


    # Next, we use xargs to process each resource name and retrieve detailed information
    about each resource

    # We use the ''get'' command to show the kind of each resource, ignoring any resources
    that are not found

    # We also specify the namespace and context to use for each resource

    xargs -n 1 kubectl get --show-kind --ignore-not-found -n ${NAMESPACE} --context=${CONTEXT}

    '
  name: get_listing_of_resources_in_namespace_namespace
- command: kubectl api-resources --verbs=list --namespaced -o name --context=${CONTEXT}
    | xargs -n 1 kubectl get --show-kind --ignore-not-found -n ${NAMESPACE} --context=${CONTEXT}
  doc_links: '

    - [Kubernetes API Concepts](https://kubernetes.io/docs/concepts/){:target="_blank"}

    - [Kubernetes Namespace](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubectl Command Reference](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [Kubernetes API Endpoints](https://kubernetes.io/docs/concepts/overview/kubernetes-api/){:target="_blank"}'
  explanation: This command retrieves a list of API resources for a specific context,
    and then gets the details of each resource in a specified namespace using that
    context. It's a way to gather information about the available resources within
    a Kubernetes environment.
  multi_line_details: '

    # This command retrieves a list of Kubernetes resources in a specific namespace
    and context


    # First, we use kubectl to list the available resources using the specified verbs
    and namespace

    # We output the resource names using the ''-o name'' flag and specify the context
    to use

    kubectl api-resources --verbs=list --namespaced -o name --context=${CONTEXT} |


    # Next, we use xargs to process each resource name and retrieve detailed information
    about each resource

    # We use the ''get'' command to show the kind of each resource, ignoring any resources
    that are not found

    # We also specify the namespace and context to use for each resource

    xargs -n 1 kubectl get --show-kind --ignore-not-found -n ${NAMESPACE} --context=${CONTEXT}

    '
  name: get_listing_of_resources_in_namespace_namespace
- command: 'kubectl get events --field-selector type!=Warning --context ${CONTEXT}
    -n ${NAMESPACE} -o json > $HOME/events.json && cat $HOME/events.json | jq -r ''[.items[]
    | {namespace: .involvedObject.namespace, kind: .involvedObject.kind, name: ((if
    .involvedObject and .involvedObject.kind == "Pod" then (.involvedObject.name |
    split("-")[:-1] | join("-")) else .involvedObject.name end) // ""), count: .count,
    firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason,
    message: .message}] | group_by(.namespace, .kind, .name) | .[] | {(.[0].namespace
    + "/" + .[0].kind + "/" + .[0].name): {events: .}}'' | jq -r --argjson threshold
    "${ANOMALY_THRESHOLD}" ''to_entries[] | {object: .key, oldest_timestamp: ([.value.events[]
    | .firstTimestamp] | min), most_recent_timestamp: (reduce .value.events[] as $event
    (.value.firstTimestamp; if ($event.lastTimestamp > .) then $event.lastTimestamp
    else . end)), events_per_minute: (reduce .value.events[] as $event (0; . + ($event.count
    / (((($event.lastTimestamp | fromdateiso8601) - ($event.firstTimestamp | fromdateiso8601))
    / 60) | if . == 0 then 1 else . end))) | floor), total_events: (reduce .value.events[]
    as $event (0; . + $event.count)), summary_messages: [.value.events[] | .message]
    | unique | join("; ")} | select(.events_per_minute > $threshold)'' | jq -s ''.'''
  doc_links: '

    '
  explanation: This command gathers events from a Kubernetes cluster, filters out
    all non-Warning events, and then formats the data into a JSON file. It then uses
    a tool called `jq` to manipulate the JSON data further, grouping the events by
    namespace, kind, and name, then calculating various statistics such as event frequency
    and generating a summary of the events based on a given threshold.
  multi_line_details: " \n# Set the context and namespace for the kubectl command\n\
    CONTEXT=\"exampleContext\"\nNAMESPACE=\"exampleNamespace\"\n\n# Get events from\
    \ the specified context and namespace in JSON format, then save to file\nkubectl\
    \ get events --field-selector type!=Warning --context ${CONTEXT} -n ${NAMESPACE}\
    \ -o json > $HOME/events.json\n\n# Use jq to extract relevant information from\
    \ events JSON file and output as new formatted JSON\ncat $HOME/events.json | jq\
    \ -r '[.items[] | {namespace: .involvedObject.namespace, kind: .involvedObject.kind,\
    \ name: ((if .involvedObject and .involvedObject.kind == \"Pod\" then (.involvedObject.name\
    \ | split(\"-\")[:-1] | join(\"-\")) else .involvedObject.name end) // \"\"),\
    \ count: .count, firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp,\
    \ reason: .reason, message: .message}] | group_by(.namespace, .kind, .name) |\
    \ .[] | {(.[0].namespace + \"/\" + .[0].kind + \"/\" + .[0].name): {events: .}}'\n\
    \n# Use jq to aggregate event data, filtering for objects with events per minute\
    \ exceeding a specified threshold\njq -r --argjson threshold \"${ANOMALY_THRESHOLD}\"\
    \ 'to_entries[] | {object: .key, oldest_timestamp: ([.value.events[] | .firstTimestamp]\
    \ | min), most_recent_timestamp: (reduce .value.events[] as $event (.value.firstTimestamp;\
    \ if ($event.lastTimestamp > .) then $event.lastTimestamp else . end)), events_per_minute:\
    \ (reduce .value.events[] as $event (0; . + ($event.count / (((($event.lastTimestamp\
    \ | fromdateiso8601) - ($event.firstTimestamp | fromdateiso8601)) / 60) | if .\
    \ == 0 then 1 else . end))) | floor), total_events: (reduce .value.events[] as\
    \ $event (0; . + $event.count)), summary_messages: [.value.events[] | .message]\
    \ | unique | join(\"; \")} | select(.events_per_minute > $threshold)' \n\n# Combine\
    \ results into a single JSON array\njq -s '.'\n"
  name: check_event_anomalies_in_namespace_namespace
- command: 'kubectl get events --field-selector type!=Warning --context ${CONTEXT}
    -n ${NAMESPACE} -o json > $HOME/events.json && cat $HOME/events.json | jq -r ''[.items[]
    | {namespace: .involvedObject.namespace, kind: .involvedObject.kind, name: ((if
    .involvedObject and .involvedObject.kind == "Pod" then (.involvedObject.name |
    split("-")[:-1] | join("-")) else .involvedObject.name end) // ""), count: .count,
    firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason,
    message: .message}] | group_by(.namespace, .kind, .name) | .[] | {(.[0].namespace
    + "/" + .[0].kind + "/" + .[0].name): {events: .}}'' | jq -r --argjson threshold
    "${ANOMALY_THRESHOLD}" ''to_entries[] | {object: .key, oldest_timestamp: ([.value.events[]
    | .firstTimestamp] | min), most_recent_timestamp: (reduce .value.events[] as $event
    (.value.firstTimestamp; if ($event.lastTimestamp > .) then $event.lastTimestamp
    else . end)), events_per_minute: (reduce .value.events[] as $event (0; . + ($event.count
    / (((($event.lastTimestamp | fromdateiso8601) - ($event.firstTimestamp | fromdateiso8601))
    / 60) | if . == 0 then 1 else . end))) | floor), total_events: (reduce .value.events[]
    as $event (0; . + $event.count)), summary_messages: [.value.events[] | .message]
    | unique | join("; ")} | select(.events_per_minute > $threshold)'' | jq -s ''.'''
  doc_links: '

    '
  explanation: This command gathers events from a Kubernetes cluster, filters out
    all non-Warning events, and then formats the data into a JSON file. It then uses
    a tool called `jq` to manipulate the JSON data further, grouping the events by
    namespace, kind, and name, then calculating various statistics such as event frequency
    and generating a summary of the events based on a given threshold.
  multi_line_details: " \n# Set the context and namespace for the kubectl command\n\
    CONTEXT=\"exampleContext\"\nNAMESPACE=\"exampleNamespace\"\n\n# Get events from\
    \ the specified context and namespace in JSON format, then save to file\nkubectl\
    \ get events --field-selector type!=Warning --context ${CONTEXT} -n ${NAMESPACE}\
    \ -o json > $HOME/events.json\n\n# Use jq to extract relevant information from\
    \ events JSON file and output as new formatted JSON\ncat $HOME/events.json | jq\
    \ -r '[.items[] | {namespace: .involvedObject.namespace, kind: .involvedObject.kind,\
    \ name: ((if .involvedObject and .involvedObject.kind == \"Pod\" then (.involvedObject.name\
    \ | split(\"-\")[:-1] | join(\"-\")) else .involvedObject.name end) // \"\"),\
    \ count: .count, firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp,\
    \ reason: .reason, message: .message}] | group_by(.namespace, .kind, .name) |\
    \ .[] | {(.[0].namespace + \"/\" + .[0].kind + \"/\" + .[0].name): {events: .}}'\n\
    \n# Use jq to aggregate event data, filtering for objects with events per minute\
    \ exceeding a specified threshold\njq -r --argjson threshold \"${ANOMALY_THRESHOLD}\"\
    \ 'to_entries[] | {object: .key, oldest_timestamp: ([.value.events[] | .firstTimestamp]\
    \ | min), most_recent_timestamp: (reduce .value.events[] as $event (.value.firstTimestamp;\
    \ if ($event.lastTimestamp > .) then $event.lastTimestamp else . end)), events_per_minute:\
    \ (reduce .value.events[] as $event (0; . + ($event.count / (((($event.lastTimestamp\
    \ | fromdateiso8601) - ($event.firstTimestamp | fromdateiso8601)) / 60) | if .\
    \ == 0 then 1 else . end))) | floor), total_events: (reduce .value.events[] as\
    \ $event (0; . + $event.count)), summary_messages: [.value.events[] | .message]\
    \ | unique | join(\"; \")} | select(.events_per_minute > $threshold)' \n\n# Combine\
    \ results into a single JSON array\njq -s '.'\n"
  name: check_event_anomalies_in_namespace_namespace
- command: context="${CONTEXT}"; namespace="${NAMESPACE}"; check_health() { local
    type=$1; local name=$2; local replicas=$3; local selector=$4; local pdbs=$(kubectl
    --context "$context" --namespace "$namespace" get pdb -o json | jq -c --arg selector
    "$selector" '.items[] | select(.spec.selector.matchLabels | to_entries[] | .key
    + "=" + .value == $selector)'); if [[ $replicas -gt 1 && -z "$pdbs" ]]; then printf
    "%-30s %-30s %-10s\n" "$type/$name" "" "Missing"; else echo "$pdbs" | jq -c .
    | while IFS= read -r pdb; do local pdbName=$(echo "$pdb" | jq -r '.metadata.name');
    local minAvailable=$(echo "$pdb" | jq -r '.spec.minAvailable // ""'); local maxUnavailable=$(echo
    "$pdb" | jq -r '.spec.maxUnavailable // ""'); if [[ "$minAvailable" == "100%"
    || "$maxUnavailable" == "0" || "$maxUnavailable" == "0%" ]]; then printf "%-30s
    %-30s %-10s\n" "$type/$name" "$pdbName" "Risky"; elif [[ $replicas -gt 1 && ("$minAvailable"
    != "100%" || "$maxUnavailable" != "0" || "$maxUnavailable" != "0%") ]]; then printf
    "%-30s %-30s %-10s\n" "$type/$name" "$pdbName" "OK"; fi; done; fi; }; echo "Deployments:";
    echo "_______"; printf "%-30s %-30s %-10s\n" "NAME" "PDB" "STATUS"; kubectl --context
    "$context" --namespace "$namespace" get deployments -o json | jq -c '.items[]
    | "\(.metadata.name) \(.spec.replicas) \(.spec.selector.matchLabels | to_entries[]
    | .key + "=" + .value)"' | while read -r line; do check_health "Deployment" $(echo
    $line | tr -d '"'); done; echo ""; echo "Statefulsets:"; echo "_______"; printf
    "%-30s %-30s %-10s\n" "NAME" "PDB" "STATUS"; kubectl --context "$context" --namespace
    "$namespace" get statefulsets -o json | jq -c '.items[] | "\(.metadata.name) \(.spec.replicas)
    \(.spec.selector.matchLabels | to_entries[] | .key + "=" + .value)"' | while read
    -r line; do check_health "StatefulSet" $(echo $line | tr -d '"'); done
  doc_links: '

    - [Kubernetes Documentation: Overview of Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/){:target="_blank"}

    - [Kubernetes Documentation: StatefulSets Overview](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/){:target="_blank"}

    - [Kubernetes Documentation: PodDisruptionBudgets](https://kubernetes.io/docs/concepts/workloads/pods/disruptions/){:target="_blank"}'
  explanation: This command checks the health of deployments and statefulsets in a
    Kubernetes cluster by evaluating the corresponding PodDisruptionBudgets (PDBs)
    to determine if they are missing, risky, or OK based on certain criteria. It then
    prints the status of each deployment and statefulset along with their associated
    PDBs.
  multi_line_details: "\n# Set context and namespace variables for kubectl commands\n\
    context=\"${CONTEXT}\"\nnamespace=\"${NAMESPACE}\"\n\n# Function to check the\
    \ health of a resource\ncheck_health() {\n    local type=$1\n    local name=$2\n\
    \    local replicas=$3\n    local selector=$4\n    # Get relevant PodDisruptionBudgets\
    \ (pdb) using jq filtering\n    local pdbs=$(kubectl --context \"$context\" --namespace\
    \ \"$namespace\" get pdb -o json | jq -c --arg selector \"$selector\" '.items[]\
    \ | select(.spec.selector.matchLabels | to_entries[] | .key + \"=\" + .value ==\
    \ $selector)')\n  \n    # Check if replicas are greater than 1 and pdb is missing\n\
    \    if [[ $replicas -gt 1 && -z \"$pdbs\" ]]; then\n        printf \"%-30s %-30s\
    \ %-10s\\n\" \"$type/$name\" \"\" \"Missing\"\n    else\n        # Loop over each\
    \ pdb\n        echo \"$pdbs\" | jq -c . | while IFS= read -r pdb; do\n       \
    \     local pdbName=$(echo \"$pdb\" | jq -r '.metadata.name')\n            local\
    \ minAvailable=$(echo \"$pdb\" | jq -r '.spec.minAvailable // \"\"')\n       \
    \     local maxUnavailable=$(echo \"$pdb\" | jq -r '.spec.maxUnavailable // \"\
    \"')\n\n            # Check if minAvailable is 100% or maxUnavailable is 0 or\
    \ 0%\n            if [[ \"$minAvailable\" == \"100%\" || \"$maxUnavailable\" ==\
    \ \"0\" || \"$maxUnavailable\" == \"0%\" ]]; then\n                printf \"%-30s\
    \ %-30s %-10s\\n\" \"$type/$name\" \"$pdbName\" \"Risky\"\n            # Check\
    \ if replicas are greater than 1 and minAvailable or maxUnavailable are other\
    \ than risky values\n            elif [[ $replicas -gt 1 && (\"$minAvailable\"\
    \ != \"100%\" || \"$maxUnavailable\" != \"0\" || \"$maxUnavailable\" != \"0%\"\
    ) ]]; then\n                printf \"%-30s %-30s %-10s\\n\" \"$type/$name\" \"\
    $pdbName\" \"OK\"\n            fi\n        done\n    fi\n}\n\n# Get deployments\
    \ and check their health\necho \"Deployments:\"\necho \"_______\"\nprintf \"%-30s\
    \ %-30s %-10s\\n\" \"NAME\" \"PDB\" \"STATUS\"\nkubectl --context \"$context\"\
    \ --namespace \"$namespace\" get deployments -o json | jq -c '.items[] | \"\\\
    (.metadata.name) \\(.spec.replicas) \\(.spec.selector.matchLabels | to_entries[]\
    \ | .key + \"=\" + .value)\"' | while read -r line; do \n    check_health \"Deployment\"\
    \ $(echo $line | tr -d '\"'); \ndone\n\necho \"\"\n\n# Get statefulsets and check\
    \ their health\necho \"Statefulsets:\"\necho \"_______\"\nprintf \"%-30s %-30s\
    \ %-10s\\n\" \"NAME\" \"PDB\" \"STATUS\"\nkubectl --context \"$context\" --namespace\
    \ \"$namespace\" get statefulsets -o json | jq -c '.items[] | \"\\(.metadata.name)\
    \ \\(.spec.replicas) \\(.spec.selector.matchLabels | to_entries[] | .key + \"\
    =\" + .value)\"' | while read -r line; do \n    check_health \"StatefulSet\" $(echo\
    \ $line | tr -d '\"'); \ndone\n"
  name: check_missing_or_risky_poddisruptionbudget_policies_in_namepace_namespace
- command: context="${CONTEXT}"; namespace="${NAMESPACE}"; check_health() { local
    type=$1; local name=$2; local replicas=$3; local selector=$4; local pdbs=$(kubectl
    --context "$context" --namespace "$namespace" get pdb -o json | jq -c --arg selector
    "$selector" '.items[] | select(.spec.selector.matchLabels | to_entries[] | .key
    + "=" + .value == $selector)'); if [[ $replicas -gt 1 && -z "$pdbs" ]]; then printf
    "%-30s %-30s %-10s\n" "$type/$name" "" "Missing"; else echo "$pdbs" | jq -c .
    | while IFS= read -r pdb; do local pdbName=$(echo "$pdb" | jq -r '.metadata.name');
    local minAvailable=$(echo "$pdb" | jq -r '.spec.minAvailable // ""'); local maxUnavailable=$(echo
    "$pdb" | jq -r '.spec.maxUnavailable // ""'); if [[ "$minAvailable" == "100%"
    || "$maxUnavailable" == "0" || "$maxUnavailable" == "0%" ]]; then printf "%-30s
    %-30s %-10s\n" "$type/$name" "$pdbName" "Risky"; elif [[ $replicas -gt 1 && ("$minAvailable"
    != "100%" || "$maxUnavailable" != "0" || "$maxUnavailable" != "0%") ]]; then printf
    "%-30s %-30s %-10s\n" "$type/$name" "$pdbName" "OK"; fi; done; fi; }; echo "Deployments:";
    echo "_______"; printf "%-30s %-30s %-10s\n" "NAME" "PDB" "STATUS"; kubectl --context
    "$context" --namespace "$namespace" get deployments -o json | jq -c '.items[]
    | "\(.metadata.name) \(.spec.replicas) \(.spec.selector.matchLabels | to_entries[]
    | .key + "=" + .value)"' | while read -r line; do check_health "Deployment" $(echo
    $line | tr -d '"'); done; echo ""; echo "Statefulsets:"; echo "_______"; printf
    "%-30s %-30s %-10s\n" "NAME" "PDB" "STATUS"; kubectl --context "$context" --namespace
    "$namespace" get statefulsets -o json | jq -c '.items[] | "\(.metadata.name) \(.spec.replicas)
    \(.spec.selector.matchLabels | to_entries[] | .key + "=" + .value)"' | while read
    -r line; do check_health "StatefulSet" $(echo $line | tr -d '"'); done
  doc_links: '

    - [Kubernetes Documentation: Overview of Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/){:target="_blank"}

    - [Kubernetes Documentation: StatefulSets Overview](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/){:target="_blank"}

    - [Kubernetes Documentation: PodDisruptionBudgets](https://kubernetes.io/docs/concepts/workloads/pods/disruptions/){:target="_blank"}'
  explanation: This command checks the health of deployments and statefulsets in a
    Kubernetes cluster by evaluating the corresponding PodDisruptionBudgets (PDBs)
    to determine if they are missing, risky, or OK based on certain criteria. It then
    prints the status of each deployment and statefulset along with their associated
    PDBs.
  multi_line_details: "\n# Set context and namespace variables for kubectl commands\n\
    context=\"${CONTEXT}\"\nnamespace=\"${NAMESPACE}\"\n\n# Function to check the\
    \ health of a resource\ncheck_health() {\n    local type=$1\n    local name=$2\n\
    \    local replicas=$3\n    local selector=$4\n    # Get relevant PodDisruptionBudgets\
    \ (pdb) using jq filtering\n    local pdbs=$(kubectl --context \"$context\" --namespace\
    \ \"$namespace\" get pdb -o json | jq -c --arg selector \"$selector\" '.items[]\
    \ | select(.spec.selector.matchLabels | to_entries[] | .key + \"=\" + .value ==\
    \ $selector)')\n  \n    # Check if replicas are greater than 1 and pdb is missing\n\
    \    if [[ $replicas -gt 1 && -z \"$pdbs\" ]]; then\n        printf \"%-30s %-30s\
    \ %-10s\\n\" \"$type/$name\" \"\" \"Missing\"\n    else\n        # Loop over each\
    \ pdb\n        echo \"$pdbs\" | jq -c . | while IFS= read -r pdb; do\n       \
    \     local pdbName=$(echo \"$pdb\" | jq -r '.metadata.name')\n            local\
    \ minAvailable=$(echo \"$pdb\" | jq -r '.spec.minAvailable // \"\"')\n       \
    \     local maxUnavailable=$(echo \"$pdb\" | jq -r '.spec.maxUnavailable // \"\
    \"')\n\n            # Check if minAvailable is 100% or maxUnavailable is 0 or\
    \ 0%\n            if [[ \"$minAvailable\" == \"100%\" || \"$maxUnavailable\" ==\
    \ \"0\" || \"$maxUnavailable\" == \"0%\" ]]; then\n                printf \"%-30s\
    \ %-30s %-10s\\n\" \"$type/$name\" \"$pdbName\" \"Risky\"\n            # Check\
    \ if replicas are greater than 1 and minAvailable or maxUnavailable are other\
    \ than risky values\n            elif [[ $replicas -gt 1 && (\"$minAvailable\"\
    \ != \"100%\" || \"$maxUnavailable\" != \"0\" || \"$maxUnavailable\" != \"0%\"\
    ) ]]; then\n                printf \"%-30s %-30s %-10s\\n\" \"$type/$name\" \"\
    $pdbName\" \"OK\"\n            fi\n        done\n    fi\n}\n\n# Get deployments\
    \ and check their health\necho \"Deployments:\"\necho \"_______\"\nprintf \"%-30s\
    \ %-30s %-10s\\n\" \"NAME\" \"PDB\" \"STATUS\"\nkubectl --context \"$context\"\
    \ --namespace \"$namespace\" get deployments -o json | jq -c '.items[] | \"\\\
    (.metadata.name) \\(.spec.replicas) \\(.spec.selector.matchLabels | to_entries[]\
    \ | .key + \"=\" + .value)\"' | while read -r line; do \n    check_health \"Deployment\"\
    \ $(echo $line | tr -d '\"'); \ndone\n\necho \"\"\n\n# Get statefulsets and check\
    \ their health\necho \"Statefulsets:\"\necho \"_______\"\nprintf \"%-30s %-30s\
    \ %-10s\\n\" \"NAME\" \"PDB\" \"STATUS\"\nkubectl --context \"$context\" --namespace\
    \ \"$namespace\" get statefulsets -o json | jq -c '.items[] | \"\\(.metadata.name)\
    \ \\(.spec.replicas) \\(.spec.selector.matchLabels | to_entries[] | .key + \"\
    =\" + .value)\"' | while read -r line; do \n    check_health \"StatefulSet\" $(echo\
    \ $line | tr -d '\"'); \ndone\n"
  name: check_missing_or_risky_poddisruptionbudget_policies_in_namepace_namespace
- command: bash 'resource_quota_check.sh'
  doc_links: '

    - [Kubernetes Resource Quotas](https://kubernetes.io/docs/concepts/policy/resource-quotas/){:target="_blank"}

    - [Kubernetes Memory Units](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory){:target="_blank"}

    - [Kubernetes CPU Units](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu){:target="_blank"}'
  explanation: This is a Bash script that calculates resource usage and generates
    recommendations based on the usage of memory and CPU in a Kubernetes environment.
    It converts memory to Mi (mebibytes) and CPU to millicores, then checks the usage
    against set limits and generates corresponding recommendations for adjusting the
    resource quotas.
  multi_line_details: "\n#!/bin/bash\n\n# Initialize recommendations array\ndeclare\
    \ -a recommendations\n\n# Function to convert memory to Mi\nconvert_memory_to_mib()\
    \ {\n    local memory=$1\n\n    # Extract the number and unit separately\n   \
    \ local number=${memory//[!0-9]/}\n    local unit=${memory//[0-9]/}\n\n    case\
    \ $unit in\n        Gi)\n            echo $(( number * 1024 ))  # Convert Gi to\
    \ Mi\n            ;;\n        Mi)\n            echo $number  # Already in Mi\n\
    \            ;;\n        Ki)\n            echo $(( number / 1024 ))  # Convert\
    \ Ki to Mi\n            ;;\n        *)\n            echo $(( number / (1024 *\
    \ 1024) ))  # Convert bytes to Mi\n            ;;\n    esac\n}\n\n# Function to\
    \ convert CPU to millicores\nconvert_cpu_to_millicores() {\n    local cpu=$1\n\
    \    if [[ $cpu =~ ^[0-9]+m$ ]]; then\n        echo ${cpu%m}\n    else\n     \
    \   echo $(($cpu * 1000))  # Convert CPU cores to millicores\n    fi\n}\n\n# Function\
    \ to calculate and display resource usage status with recommendations\ncheck_usage()\
    \ {\n    local quota_name=$1\n    local resource=$2\n    local used=$3\n    local\
    \ hard=$4\n\n    # Convert memory and CPU to a common unit (Mi and millicores\
    \ respectively)\n    if [[ $resource == *memory* ]]; then\n        used=$(convert_memory_to_mib\
    \ $used)\n        hard=$(convert_memory_to_mib $hard)\n    elif [[ $resource ==\
    \ *cpu* ]]; then\n        used=$(convert_cpu_to_millicores $used)\n        hard=$(convert_cpu_to_millicores\
    \ $hard)\n    fi\n\n    # Calculating percentage\n    local percentage=0\n   \
    \ if [ $hard -ne 0 ]; then\n        percentage=$(( 100 * used / hard ))\n    fi\n\
    \n    # Generate recommendation based on usage\n    local recommendation=\"\"\n\
    \    local increase_percentage=0\n    local increased_value=0\n    if [ $percentage\
    \ -ge 100 ]; then\n        if [ $used -gt $hard ]; then\n            # If usage\
    \ is over 100%, match the current usage\n            echo \"$resource: OVER LIMIT\
    \ ($percentage%) - Adjust resource quota to match current usage with some headroom\
    \ for $resource in $NAMESPACE\"\n            increase_percentage=\"${CRITICAL_INCREASE_LEVEL:-40}\"\
    \n            increased_value=$(( used * increase_percentage / 100 ))\n      \
    \      suggested_value=$(( increased_value + used ))\n        else\n         \
    \   echo \"$resource: AT LIMIT ($percentage%) - Immediately increase the resource\
    \ quota for $resource in $NAMESPACE\"\n            increase_percentage=\"${CRITICAL_INCREASE_LEVEL:-40}\"\
    \n            increased_value=$(( hard * increase_percentage / 100 ))\n      \
    \      suggested_value=$(( increased_value + hard ))\n        fi\n        recommendation=\"\
    {\\\"remediation_type\\\":\\\"resourcequota_update\\\",\\\"increase_percentage\\\
    \":\\\"$increase_percentage\\\",\\\"limit_type\\\":\\\"hard\\\",\\\"current_value\\\
    \":\\\"$hard\\\",\\\"suggested_value\\\":\\\"$suggested_value\\\",\\\"quota_name\\\
    \": \\\"$quota_name\\\", \\\"resource\\\": \\\"$resource\\\", \\\"usage\\\": \\\
    \"at or above 100%\\\", \\\"severity\\\": \\\"1\\\", \\\"next_step\\\": \\\"Increase\
    \ the resource quota for $resource in \\`$NAMESPACE\\`\\\"}\"\n    #... (and so\
    \ on)\n\n# Fetching resource quota details\nquota_json=$(${KUBERNETES_DISTRIBUTION_BINARY}\
    \ get quota -n \"$NAMESPACE\" --context \"$CONTEXT\" -o json)\n\n# Processing\
    \ the quota JSON\necho \"Resource Quota and Usage for Namespace: $NAMESPACE in\
    \ Context: $CONTEXT\"\necho \"===========================================\"\n\n\
    # Parsing quota JSON\nwhile IFS= read -r item; do\n    quota_name=$(echo \"$item\"\
    \ | jq -r '.metadata.name')\n    echo \"Quota: $quota_name\"\n\n    # Create temporary\
    \ files\n    hard_file=$(mktemp)\n    used_file=$(mktemp)\n\n    echo \"$item\"\
    \ | jq -r '.status.hard | to_entries | .[] | \"\\(.key) \\(.value)\"' > \"$hard_file\"\
    \n    echo \"$item\" | jq -r '.status.used | to_entries | .[] | \"\\(.key) \\\
    (.value)\"' > \"$used_file\"\n\n    # Process 'hard' limits and 'used' resources\n\
    \    while read -r key value; do\n        hard=$(grep \"^$key \" \"$hard_file\"\
    \ | awk '{print $2}')\n        used=$(grep \"^$key \" \"$used_file\" | awk '{print\
    \ $2}')\n        check_usage \"$quota_name\" \"$key\" \"${used:-0}\" \"$hard\"\
    \n    done < \"$hard_file\"\n\n    echo \"-----------------------------------\"\
    \n\n    # Clean up temporary files\n    rm \"$hard_file\" \"$used_file\"\ndone\
    \ < <(echo \"$quota_json\" | jq -c '.items[]')\n\n# Outputting recommendations\
    \ as JSON\nif [ -n \"$recommendations\" ]; then\n    echo \"Recommended Next Steps:\"\
    \n    echo \"[$recommendations]\" | jq .\nelse\n    echo \"No recommendations.\"\
    \nfi\n"
  name: check_resource_quota_utilization_in_namepace_namespace
