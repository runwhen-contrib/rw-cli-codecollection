commands:
- command: 'kubectl get events --field-selector type=Warning --context ${CONTEXT}
    -n ${NAMESPACE} -o json > $HOME/warning_events.json && cat $HOME/warning_events.json
    | jq -r ''[.items[] | {namespace: .involvedObject.namespace, kind: .involvedObject.kind,
    baseName: ((if .involvedObject.kind == "Pod" then (.involvedObject.name | split("-")[:-1]
    | join("-")) else .involvedObject.name end) // ""), count: .count, firstTimestamp:
    .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason, message: .message}]
    | group_by(.namespace, .kind, .baseName) | map({object: (.[0].namespace + "/"
    + .[0].kind + "/" + .[0].baseName), total_events: (reduce .[] as $event (0; .
    + $event.count)), summary_messages: (map(.message) | unique | join("; ")), oldest_timestamp:
    (map(.firstTimestamp) | sort | first), most_recent_timestamp: (map(.lastTimestamp)
    | sort | last)}) | map(select((now - ((.most_recent_timestamp | fromdateiso8601)))/60
    <= 30))'''
  doc_links: '

    - [Kubernetes warning events](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-kubectl-get-events){:target="_blank"}

    - [Understanding Kubernetes contexts and namespaces](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}

    - [Formatting output in JSON file with kubectl](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#formatting-output){:target="_blank"}

    - [Filtering and organizing data with kubectl](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-kubectl-get){:target="_blank"}'
  explanation: This command gets warning events from a specific context and namespace
    in Kubernetes, then formats the output into a JSON file. It also filters and organizes
    the data to generate a summary of the events within the last 30 minutes.
  multi_line_details: "# Perform kubectl command to get events with field-selector\
    \ type=Warning\n# Store the output in a json file warning_events.json in home\
    \ directory\n# Using jq, parse the warning_events.json file to select and manipulate\
    \ data \n# The resulting output is filtered based on certain criteria and saved\
    \ in another format\nkubectl get events --field-selector type=Warning --context\
    \ ${CONTEXT} -n ${NAMESPACE} -o json > $HOME/warning_events.json \\\n&& cat $HOME/warning_events.json\
    \ | jq -r '[.items[] | {namespace: .involvedObject.namespace, kind: .involvedObject.kind,\
    \ baseName: ((if .involvedObject.kind == \"Pod\" then (.involvedObject.name |\
    \ split(\"-\")[:-1] | join(\"-\")) else .involvedObject.name end) // \"\"), count:\
    \ .count, firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp, reason:\
    \ .reason, message: .message}] | group_by(.namespace, .kind, .baseName) | map({object:\
    \ (.[0].namespace + \"/\" + .[0].kind + \"/\" + .[0].baseName), total_events:\
    \ (reduce .[] as $event (0; . + $event.count)), summary_messages: (map(.message)\
    \ | unique | join(\"; \")), oldest_timestamp: (map(.firstTimestamp) | sort | first),\
    \ most_recent_timestamp: (map(.lastTimestamp) | sort | last)}) | map(select((now\
    \ - ((.most_recent_timestamp | fromdateiso8601)))/60 <= 30))'"
  name: troubleshoot_warning_events_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} -o json | jq -r
    --argjson exit_code_explanations ''{"0": "Success", "1": "Error", "2": "Misconfiguration",
    "130": "Pod terminated by SIGINT", "134": "Abnormal Termination SIGABRT", "137":
    "Pod terminated by SIGKILL - Possible OOM", "143":"Graceful Termination SIGTERM"}''
    ''.items[] | select(.status.containerStatuses != null) | select(any(.status.containerStatuses[];
    .restartCount > 0)) | "---\npod_name: \(.metadata.name)\n" + (.status.containerStatuses[]
    | "containers: \(.name)\nrestart_count: \(.restartCount)\nmessage: \(.state.waiting.message
    // "N/A")\nterminated_reason: \(.lastState.terminated.reason // "N/A")\nterminated_finishedAt:
    \(.lastState.terminated.finishedAt // "N/A")\nterminated_exitCode: \(.lastState.terminated.exitCode
    // "N/A")\nexit_code_explanation: \($exit_code_explanations[.lastState.terminated.exitCode
    | tostring] // "Unknown exit code")") + "\n---\n"'''
  doc_links: '

    - [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [JSON output format in kubectl](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#formatting-output-using-jsonpath){:target="_blank"}

    - [jq tool documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command uses kubectl to get information about pods in a specific
    context and namespace in JSON format, then uses jq to format the output to include
    details about any containers that have been restarted, including the exit code
    and an explanation for each exit code based on a predefined set of codes.
  multi_line_details: "# Set the context and namespace for the kubectl command\nCONTEXT=$1\n\
    NAMESPACE=$2\n\n# Get the pods using kubectl in JSON format and use jq to format\
    \ the output\nkubectl get pods --context=${CONTEXT} -n ${NAMESPACE} -o json |\
    \ \\\n  jq -r --argjson exit_code_explanations '{\"0\": \"Success\", \"1\": \"\
    Error\", \"2\": \"Misconfiguration\", \"130\": \"Pod terminated by SIGINT\", \"\
    134\": \"Abnormal Termination SIGABRT\", \"137\": \"Pod terminated by SIGKILL\
    \ - Possible OOM\", \"143\":\"Graceful Termination SIGTERM\"}' \\\n  '.items[]\
    \ | select(.status.containerStatuses != null) | select(any(.status.containerStatuses[];\
    \ .restartCount > 0)) | \"---\\npod_name: \\(.metadata.name)\\n\" + (.status.containerStatuses[]\
    \ | \"containers: \\(.name)\\nrestart_count: \\(.restartCount)\\nmessage: \\(.state.waiting.message\
    \ // \"N/A\")\\nterminated_reason: \\(.lastState.terminated.reason // \"N/A\"\
    )\\nterminated_finishedAt: \\(.lastState.terminated.finishedAt // \"N/A\")\\nterminated_exitCode:\
    \ \\(.lastState.terminated.exitCode // \"N/A\")\\nexit_code_explanation: \\($exit_code_explanations[.lastState.terminated.exitCode\
    \ | tostring] // \"Unknown exit code\")\") + \"\\n---\\n\"'"
  name: troubleshoot_container_restarts_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Pending
    --no-headers -o json | jq -r ''.items[] | "pod_name: \(.metadata.name)\nstatus:
    \(.status.phase // "N/A")\nmessage: \(.status.conditions[0].message // "N/A")\nreason:
    \(.status.conditions[0].reason // "N/A")\ncontainerStatus: \((.status.containerStatuses[0].state
    // "N/A"))\ncontainerMessage: \(.status.containerStatuses[0].state.waiting?.message
    // "N/A")\ncontainerReason: \(.status.containerStatuses[0].state.waiting?.reason
    // "N/A")\n------------"'''
  doc_links: '

    - [Kubernetes Official Documentation](https://kubernetes.io/docs/home/){:target="_blank"}

    - [Kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Jq Documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command retrieves information about pods in a specific context
    and namespace that are in a pending state, and formats the output using jq to
    display details about each pod's name, status, message, reason, container status,
    container message, and container reason.
  multi_line_details: "# Set the context and namespace\nCONTEXT=${CONTEXT}\nNAMESPACE=${NAMESPACE}\n\
    \n# Use kubectl to get pods from the specified context and namespace with status.phase=Pending\n\
    # Pipe the output as JSON and use jq to display specific information about each\
    \ pod\nkubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Pending\
    \ --no-headers -o json | \n  jq -r '.items[] | \"pod_name: \\(.metadata.name)\\\
    nstatus: \\(.status.phase // \"N/A\")\\nmessage: \\(.status.conditions[0].message\
    \ // \"N/A\")\\nreason: \\(.status.conditions[0].reason // \"N/A\")\\ncontainerStatus:\
    \ \\((.status.containerStatuses[0].state // \"N/A\"))\\ncontainerMessage: \\(.status.containerStatuses[0].state.waiting?.message\
    \ // \"N/A\")\\ncontainerReason: \\(.status.containerStatuses[0].state.waiting?.reason\
    \ // \"N/A\")\\n------------\"'"
  name: troubleshoot_pending_pods_in_namespace_namespace
- command: 'kubectl get pods --context=${CONTEXT} -n ${NAMESPACE} --field-selector=status.phase=Failed
    --no-headers -o json | jq -r --argjson exit_code_explanations ''{"0": "Success",
    "1": "Error", "2": "Misconfiguration", "130": "Pod terminated by SIGINT", "134":
    "Abnormal Termination SIGABRT", "137": "Pod terminated by SIGKILL - Possible OOM",
    "143":"Graceful Termination SIGTERM"}'' ''.items[] | "pod_name: \(.metadata.name)\nrestart_count:
    \(.status.containerStatuses[0].restartCount // "N/A")\nmessage: \(.status.message
    // "N/A")\nterminated_finishedAt: \(.status.containerStatuses[0].state.terminated.finishedAt
    // "N/A")\nexit_code: \(.status.containerStatuses[0].state.terminated.exitCode
    // "N/A")\nexit_code_explanation: \($exit_code_explanations[.status.containerStatuses[0].state.terminated.exitCode
    | tostring] // "Unknown exit code")\n------------"'''
  doc_links: '

    Documentation links not available'
  explanation: This command uses kubectl to get information about pods in a specific
    context and namespace that have failed. It then formats the output using "jq"
    to provide details about each failed pod, including its name, restart count, message,
    termination time, exit code, and an explanation of the exit code.
  multi_line_details: Multi-line script not available
  name: troubleshoot_failed_pods_in_namespace_namespace
- command: 'kubectl get pods --context ${CONTEXT} -n ${NAMESPACE} -o json | jq -r
    ''.items[] | select(.status.conditions[]? | select(.type == "Ready" and .status
    == "False" and .reason != "PodCompleted")) | {kind: .kind, name: .metadata.name,
    conditions: .status.conditions}'' | jq -s ''.'''
  doc_links: '

    - [Kubernetes Concepts](https://kubernetes.io/docs/concepts/){:target="_blank"}

    - [Kubectl Command Documentation](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands){:target="_blank"}

    - [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [jq Tool Documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command retrieves information about pods in a Kubernetes cluster,
    within a specific context and namespace, and displays it in JSON format. It uses
    the `jq` tool to filter out specific conditions of the pods such as status not
    being ready or completed.
  multi_line_details: "# Set the kubectl context to the specified CONTEXT and \n#\
    \ get the pods in the specified NAMESPACE in JSON format\npods_json=$(kubectl\
    \ get pods --context ${CONTEXT} -n ${NAMESPACE} -o json | \n\n# Parse the JSON\
    \ using jq, filtering for pods that are not ready\njq -r '.items[] | select(.status.conditions[]?\
    \ | select(.type == \"Ready\" and .status == \"False\" and .reason != \"PodCompleted\"\
    )) | {kind: .kind, name: .metadata.name, conditions: .status.conditions}' | \n\
    \n# Convert the filtered results into an array\njq -s '.')\n\n# Print the parsed\
    \ JSON\necho $pods_json"
  name: troubleshoot_workload_status_conditions_in_namespace_namespace
- command: kubectl api-resources --verbs=list --namespaced -o name --context=${CONTEXT}
    | xargs -n 1 kubectl get --show-kind --ignore-not-found -n ${NAMESPACE} --context=${CONTEXT}
  doc_links: '

    - [kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [API Resources in Kubernetes](https://kubernetes.io/docs/reference/using-api/api-overview/){:target="_blank"}

    - [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}'
  explanation: This command uses kubectl to list all the API resources available in
    a given Kubernetes context, and then retrieves detailed information for each resource
    within a specific namespace. It is useful for quickly querying and understanding
    the resources available within a Kubernetes cluster.
  multi_line_details: "#!/bin/bash\n\n# Command to get resources for a specific namespace\
    \ using kubectl\n# Fetching API resources with specific verbs, namespaced and\
    \ output as name\n\nkubectl api-resources \\\n  --verbs=list \\\n  --namespaced\
    \ \\\n  -o name \\\n  --context=${CONTEXT} | xargs -n 1 kubectl get \\\n  --show-kind\
    \ \\\n  --ignore-not-found \\\n  -n ${NAMESPACE} \\\n  --context=${CONTEXT}"
  name: get_listing_of_resources_in_namespace_namespace
- command: 'kubectl get events --field-selector type!=Warning --context ${CONTEXT}
    -n ${NAMESPACE} -o json > $HOME/events.json && cat $HOME/events.json | jq -r ''[.items[]
    | {namespace: .involvedObject.namespace, kind: .involvedObject.kind, name: ((if
    .involvedObject and .involvedObject.kind == "Pod" then (.involvedObject.name |
    split("-")[:-1] | join("-")) else .involvedObject.name end) // ""), count: .count,
    firstTimestamp: .firstTimestamp, lastTimestamp: .lastTimestamp, reason: .reason,
    message: .message}] | group_by(.namespace, .kind, .name) | .[] | {(.[0].namespace
    + "/" + .[0].kind + "/" + .[0].name): {events: .}}'' | jq -r --argjson threshold
    "${ANOMALY_THRESHOLD}" ''to_entries[] | {object: .key, oldest_timestamp: ([.value.events[]
    | .firstTimestamp] | min), most_recent_timestamp: (reduce .value.events[] as $event
    (.value.firstTimestamp; if ($event.lastTimestamp > .) then $event.lastTimestamp
    else . end)), events_per_minute: (reduce .value.events[] as $event (0; . + ($event.count
    / (((($event.lastTimestamp | fromdateiso8601) - ($event.firstTimestamp | fromdateiso8601))
    / 60) | if . == 0 then 1 else . end))) | floor), total_events: (reduce .value.events[]
    as $event (0; . + $event.count)), summary_messages: [.value.events[] | .message]
    | unique | join("; ")} | select(.events_per_minute > $threshold)'' | jq -s ''.'''
  doc_links: '

    - [Using JQ to process JSON](https://stedolan.github.io/jq/manual/){:target="_blank"}

    - [Formatting Data with JQ](https://programminghistorian.org/en/lessons/json-and-jq){:target="_blank"}'
  explanation: This command retrieves events from a Kubernetes cluster that are not
    warnings, and then filters and formats the data using jq to extract specific information
    about the events and present it in a structured JSON format.
  multi_line_details: "# Fetch events from the kubernetes cluster with conditions.\n\
    kubectl get events --field-selector type!=Warning --context ${CONTEXT} -n ${NAMESPACE}\
    \ -o json > $HOME/events.json \\\n    # Use jq to extract specific fields and\
    \ manipulate the data\n    && cat $HOME/events.json | jq -r '[.items[] | {\n \
    \       # Extract involved object fields\n        namespace: .involvedObject.namespace,\n\
    \        kind: .involvedObject.kind,\n        name: (\n            (if .involvedObject\
    \ and .involvedObject.kind == \"Pod\" then\n                (.involvedObject.name\
    \ | split(\"-\")[:-1] | join(\"-\"))\n            else\n                .involvedObject.name\n\
    \            end) // \"\"\n        ),\n        count: .count,\n        firstTimestamp:\
    \ .firstTimestamp,\n        lastTimestamp: .lastTimestamp,\n        reason: .reason,\n\
    \        message: .message\n    }] |\n    # Group by namespace, kind, and name\n\
    \    group_by(.namespace, .kind, .name) |\n    .[] | {\n        (.[0].namespace\
    \ + \"/\" + .[0].kind + \"/\" + .[0].name): {events: .}\n    }' |\n    # Calculate\
    \ event anomaly based on custom threshold\n    jq -r --argjson threshold \"${ANOMALY_THRESHOLD}\"\
    \ 'to_entries[] | {\n        object: .key,\n        oldest_timestamp: ([.value.events[]\
    \ | .firstTimestamp] | min),\n        most_recent_timestamp: (reduce .value.events[]\
    \ as $event (.value.firstTimestamp;\n            if ($event.lastTimestamp > .)\
    \ then $event.lastTimestamp else . end)),\n        events_per_minute: (reduce\
    \ .value.events[] as $event (0;\n        . + ($event.count / (((($event.lastTimestamp\
    \ | fromdateiso8601) - ($event.firstTimestamp | fromdateiso8601)) / 60) | if .\
    \ == 0 then 1 else . end))) | floor),\n        total_events: (reduce .value.events[]\
    \ as $event (0; . + $event.count)),\n        summary_messages: [.value.events[]\
    \ | .message] | unique | join(\"; \")\n    } | select(.events_per_minute > $threshold)'\
    \ |\n    # Format output into an array of objects\n    jq -s '.'"
  name: check_event_anomalies_in_namespace_namespace
- command: 'services=($(kubectl get svc -o=name --context=${CONTEXT} -n ${NAMESPACE}))
    && [ \${#services[@]} -eq 0 ] && echo "No services found." || { > "logs.json";
    for service in "\${services[@]}"; do kubectl logs $service --limit-bytes=256000
    --since=2h --context=${CONTEXT} -n ${NAMESPACE} 2>/dev/null | grep -Ei "${SERVICE_ERROR_PATTERN}"
    | grep -Ev "${SERVICE_EXCLUDE_PATTERN}" | while read -r line; do service_name="\${service#*/}";
    message=$(echo "$line" | jq -aRs .); printf ''{"service": "%s", "message": %s}\n''
    "\${service_name}" "$message" >> "logs.json"; done; done; [ ! -s "logs.json" ]
    && echo "No log entries found." || cat "logs.json" | jq -s ''[ (group_by(.service)
    | map({service: .[0].service, total_logs: length})), (group_by(.service) | map({service:
    .[0].service, top_logs: (group_by(.message[0:200]) | map({message_start: .[0].message[0:200],
    count: length}) | sort_by(.count) | reverse | .[0:3])})) ] | add''; } > $HOME/output;
    cat $HOME/output'
  doc_links: '

    - [Kubernetes - Contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/){:target="_blank"}

    - [Kubernetes - Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubernetes - Logging](https://kubernetes.io/docs/concepts/cluster-administration/logging/){:target="_blank"}

    - [Regular Expressions Overview](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions){:target="_blank"}

    - [JSON File Format](https://www.json.org/json-en.html){:target="_blank"}'
  explanation: This command retrieves the logs for all services in a specified Kubernetes
    context and namespace, filters them based on error and exclude patterns, then
    outputs the results to a JSON file. If no logs are found for any service, it will
    return a message indicating so.
  multi_line_details: "# Assign the results of kubectl get svc to the services array\n\
    services=($(kubectl get svc -o=name --context=${CONTEXT} -n ${NAMESPACE})) &&\
    \ \n\n# If the array is empty, echo \"No services found.\"\n[ \\${#services[@]}\
    \ -eq 0 ] && echo \"No services found.\" || { \n\n# Create a new logs.json file\n\
    > \"logs.json\"; \n\n# For each service in the array, fetch logs and filter by\
    \ error pattern and exclude pattern\nfor service in \"\\${services[@]}\"; do \n\
    \    kubectl logs $service --limit-bytes=256000 --since=2h --context=${CONTEXT}\
    \ -n ${NAMESPACE} 2>/dev/null | grep -Ei \"${SERVICE_ERROR_PATTERN}\" | grep -Ev\
    \ \"${SERVICE_EXCLUDE_PATTERN}\" | while read -r line; do \n\n        # Extract\
    \ service name and message \n        service_name=\"\\${service#*/}\";\n     \
    \   message=$(echo \"$line\" | jq -aRs .); \n\n        # Append formatted log\
    \ entry to logs.json\n        printf '{\"service\": \"%s\", \"message\": %s}\\\
    n' \"\\${service_name}\" \"$message\" >> \"logs.json\"; \n    done; \ndone; \n\
    \n# If logs.json is empty, echo \"No log entries found.\"; otherwise, display\
    \ the content using jq formatting\n[ ! -s \"logs.json\" ] && echo \"No log entries\
    \ found.\" || cat \"logs.json\" | jq -s '[ (group_by(.service) | map({service:\
    \ .[0].service, total_logs: length})), (group_by(.service) | map({service: .[0].service,\
    \ top_logs: (group_by(.message[0:200]) | map({message_start: .[0].message[0:200],\
    \ count: length}) | sort_by(.count) | reverse | .[0:3])})) ] | add'; \n} > $HOME/output;\n\
    \n# Print the contents of the output file\ncat $HOME/output"
  name: troubleshoot_services_and_application_workloads_in_namespace_namespace
- command: context="${CONTEXT}"; namespace="${NAMESPACE}"; check_health() { local
    type=$1; local name=$2; local replicas=$3; local selector=$4; local pdbs=$(kubectl
    --context "$context" --namespace "$namespace" get pdb -o json | jq -c --arg selector
    "$selector" '.items[] | select(.spec.selector.matchLabels | to_entries[] | .key
    + "=" + .value == $selector)'); if [[ $replicas -gt 1 && -z "$pdbs" ]]; then printf
    "%-30s %-30s %-10s\n" "$type/$name" "" "Missing"; else echo "$pdbs" | jq -c .
    | while IFS= read -r pdb; do local pdbName=$(echo "$pdb" | jq -r '.metadata.name');
    local minAvailable=$(echo "$pdb" | jq -r '.spec.minAvailable // ""'); local maxUnavailable=$(echo
    "$pdb" | jq -r '.spec.maxUnavailable // ""'); if [[ "$minAvailable" == "100%"
    || "$maxUnavailable" == "0" || "$maxUnavailable" == "0%" ]]; then printf "%-30s
    %-30s %-10s\n" "$type/$name" "$pdbName" "Risky"; elif [[ $replicas -gt 1 && ("$minAvailable"
    != "100%" || "$maxUnavailable" != "0" || "$maxUnavailable" != "0%") ]]; then printf
    "%-30s %-30s %-10s\n" "$type/$name" "$pdbName" "OK"; fi; done; fi; }; echo "Deployments:";
    echo "-----------"; printf "%-30s %-30s %-10s\n" "NAME" "PDB" "STATUS"; kubectl
    --context "$context" --namespace "$namespace" get deployments -o json | jq -c
    '.items[] | "\(.metadata.name) \(.spec.replicas) \(.spec.selector.matchLabels
    | to_entries[] | .key + "=" + .value)"' | while read -r line; do check_health
    "Deployment" $(echo $line | tr -d '"'); done; echo ""; echo "Statefulsets:"; echo
    "-------------"; printf "%-30s %-30s %-10s\n" "NAME" "PDB" "STATUS"; kubectl --context
    "$context" --namespace "$namespace" get statefulsets -o json | jq -c '.items[]
    | "\(.metadata.name) \(.spec.replicas) \(.spec.selector.matchLabels | to_entries[]
    | .key + "=" + .value)"' | while read -r line; do check_health "StatefulSet" $(echo
    $line | tr -d '"'); done
  doc_links: '

    - [Kubernetes official documentation for deploying applications](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/){:target="_blank"}

    - [Understanding StatefulSets in Kubernetes](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/){:target="_blank"}

    - [Managing Pod Disruption Budgets](https://kubernetes.io/docs/tasks/run-application/configure-pdb/){:target="_blank"}'
  explanation: This command checks the health status of deployments and statefulsets
    in a Kubernetes cluster by looking at their corresponding Pod Disruption Budgets
    (PDBs) and prints the status of each one as OK, Risky, or Missing. It does this
    by querying the PDBs for each deployment and statefulset and comparing their minimum
    availability and maximum unavailability settings with the number of replicas specified
    in the deployment/statefulset.
  multi_line_details: "context=\"${CONTEXT}\"\nnamespace=\"${NAMESPACE}\"\n\n# Function\
    \ to check health\ncheck_health() { \n  local type=$1\n  local name=$2\n  local\
    \ replicas=$3\n  local selector=$4\n  # Get Pod Disruption Budgets (pdb) for the\
    \ given selector\n  local pdbs=$(kubectl --context \"$context\" --namespace \"\
    $namespace\" get pdb -o json | jq -c --arg selector \"$selector\" '.items[] |\
    \ select(.spec.selector.matchLabels | to_entries[] | .key + \"=\" + .value ==\
    \ $selector)')\n  \n  if [[ $replicas -gt 1 && -z \"$pdbs\" ]]; then\n    printf\
    \ \"%-30s %-30s %-10s\\n\" \"$type/$name\" \"\" \"Missing\"\n  else\n    echo\
    \ \"$pdbs\" | jq -c . | while IFS= read -r pdb; do\n      local pdbName=$(echo\
    \ \"$pdb\" | jq -r '.metadata.name')\n      local minAvailable=$(echo \"$pdb\"\
    \ | jq -r '.spec.minAvailable // \"\"')\n      local maxUnavailable=$(echo \"\
    $pdb\" | jq -r '.spec.maxUnavailable // \"\"')\n\n      if [[ \"$minAvailable\"\
    \ == \"100%\" || \"$maxUnavailable\" == \"0\" || \"$maxUnavailable\" == \"0%\"\
    \ ]]; then\n        printf \"%-30s %-30s %-10s\\n\" \"$type/$name\" \"$pdbName\"\
    \ \"Risky\"\n      elif [[ $replicas -gt 1 && (\"$minAvailable\" != \"100%\" ||\
    \ \"$maxUnavailable\" != \"0\" || \"$maxUnavailable\" != \"0%\") ]]; then\n  \
    \      printf \"%-30s %-30s %-10s\\n\" \"$type/$name\" \"$pdbName\" \"OK\"\n \
    \     fi\n    done\n  fi\n}\n\necho \"Deployments:\"\necho \"-----------\"\n\n\
    # Get deployments and check health\nprintf \"%-30s %-30s %-10s\\n\" \"NAME\" \"\
    PDB\" \"STATUS\"\nkubectl --context \"$context\" --namespace \"$namespace\" get\
    \ deployments -o json | jq -c '.items[] | \"\\(.metadata.name) \\(.spec.replicas)\
    \ \\(.spec.selector.matchLabels | to_entries[] | .key + \"=\" + .value)\"' | while\
    \ read -r line; do\n  check_health \"Deployment\" $(echo $line | tr -d '\"')\n\
    done\n\necho \"\"\necho \"Statefulsets:\"\necho \"-------------\"\n\n# Get statefulsets\
    \ and check health\nprintf \"%-30s %-30s %-10s\\n\" \"NAME\" \"PDB\" \"STATUS\"\
    \nkubectl --context \"$context\" --namespace \"$namespace\" get statefulsets -o\
    \ json | jq -c '.items[] | \"\\(.metadata.name) \\(.spec.replicas) \\(.spec.selector.matchLabels\
    \ | to_entries[] | .key + \"=\" + .value)\"' | while read -r line; do\n  check_health\
    \ \"StatefulSet\" $(echo $line | tr -d '\"')\ndone"
  name: check_missing_or_risky_poddisruptionbudget_policies_in_namepace_namespace
