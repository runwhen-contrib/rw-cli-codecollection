commands:
- command: 'for pvc in $(kubectl get pvc -n ${NAMESPACE} --context ${CONTEXT} -o json
    | jq -r ''.items[] | select(.status.phase != "Bound") | .metadata.name''); do
    kubectl get events -n ${NAMESPACE} --context ${CONTEXT} --field-selector involvedObject.name=$pvc
    -o json | jq ''.items[]| "Last Timestamp: " + .lastTimestamp + ", Name: " + .involvedObject.name
    + ", Message: " + .message''; done'
  doc_links: '

    '
  explanation: This command uses kubectl to check for any unbound PersistentVolumeClaims
    (PVC) in a specific namespace and context, and then retrieves events for each
    unbound PVC, including the last timestamp, name, and message associated with each
    event.
  multi_line_details: "# Iterate over each PVC in the specified namespace and context\n\
    for pvc in $(kubectl get pvc -n ${NAMESPACE} --context ${CONTEXT} -o json | jq\
    \ -r '.items[] | select(.status.phase != \"Bound\") | .metadata.name'); do \n\
    \  # Get events related to the current PVC\n  kubectl get events -n ${NAMESPACE}\
    \ --context ${CONTEXT} --field-selector involvedObject.name=$pvc -o json | \n\
    \  # Extract relevant information and format it\n  jq '.items[]| \"Last Timestamp:\
    \ \" + .lastTimestamp + \", Name: \" + .involvedObject.name + \", Message: \"\
    \ + .message'; \ndone"
  name: fetch_events_for_unhealthy_kubernetes_persistentvolumeclaims_in_namespace_namespace
  when_is_it_useful: '1. Troubleshooting server or application downtime in a Kubernetes
    environment.

    2. Investigating issues with persistent storage not being properly allocated to
    pods.

    3. Monitoring and resolving issues related to pod creation and termination.

    4. Identifying and addressing resource constraints leading to CrashLoopBackoff
    events for pods.

    5. Analyzing and troubleshooting problems related to pod scheduling and placement
    within a cluster.'
- command: 'for pvc in $(kubectl get pvc -n ${NAMESPACE} --context ${CONTEXT} -o json
    | jq -r ''.items[] | select(.status.phase != "Bound") | .metadata.name''); do
    kubectl get events -n ${NAMESPACE} --context ${CONTEXT} --field-selector involvedObject.name=$pvc
    -o json | jq ''.items[]| "Last Timestamp: " + .lastTimestamp + ", Name: " + .involvedObject.name
    + ", Message: " + .message''; done'
  doc_links: '

    '
  explanation: This command uses kubectl to check for any unbound PersistentVolumeClaims
    (PVC) in a specific namespace and context, and then retrieves events for each
    unbound PVC, including the last timestamp, name, and message associated with each
    event.
  multi_line_details: "# Iterate over each PVC in the specified namespace and context\n\
    for pvc in $(kubectl get pvc -n ${NAMESPACE} --context ${CONTEXT} -o json | jq\
    \ -r '.items[] | select(.status.phase != \"Bound\") | .metadata.name'); do \n\
    \  # Get events related to the current PVC\n  kubectl get events -n ${NAMESPACE}\
    \ --context ${CONTEXT} --field-selector involvedObject.name=$pvc -o json | \n\
    \  # Extract relevant information and format it\n  jq '.items[]| \"Last Timestamp:\
    \ \" + .lastTimestamp + \", Name: \" + .involvedObject.name + \", Message: \"\
    \ + .message'; \ndone"
  name: fetch_events_for_unhealthy_kubernetes_persistentvolumeclaims_in_namespace_namespace
  when_is_it_useful: '1. Troubleshooting server or application downtime in a Kubernetes
    environment.

    2. Investigating issues with persistent storage not being properly allocated to
    pods.

    3. Monitoring and resolving issues related to pod creation and termination.

    4. Identifying and addressing resource constraints leading to CrashLoopBackoff
    events for pods.

    5. Analyzing and troubleshooting problems related to pod scheduling and placement
    within a cluster.'
- command: 'namespace=${NAMESPACE}; context=${CONTEXT}; kubectl get pvc -n $namespace
    --context=$context -o json | jq -r ''.items[] | select(.metadata.deletionTimestamp
    != null) | .metadata.name as $name | .metadata.deletionTimestamp as $deletion_time
    | .metadata.finalizers as $finalizers | "\($name) is in Terminating state (Deletion
    started at: \($deletion_time)). Finalizers: \($finalizers)"'''
  doc_links: '

    - [Persistent Volume Claims](https://kubernetes.io/docs/concepts/storage/persistent-volumes/){:target="_blank"}

    - [Kubectl Command Line Tool](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [jq formatting tool](https://stedolan.github.io/jq/){:target="_blank"}'
  explanation: This command uses the Kubernetes command line tool (kubectl) to get
    information about persistent volume claims (pvc) in a specific namespace and context,
    displaying the ones that are in a "Terminating" state along with their deletion
    timestamp and finalizers. It also uses jq to format the output as human-readable
    text.
  multi_line_details: "\n# First, assign the values of NAMESPACE and CONTEXT to variables\n\
    namespace=${NAMESPACE}\ncontext=${CONTEXT}\n\n# Then use kubectl command to get\
    \ the list of PersistentVolumeClaims in the specified namespace and context in\
    \ JSON format\nkubectl get pvc -n $namespace --context=$context -o json |\n\n\
    # Next, use jq to filter the output and select only the items which have a deletionTimestamp\n\
    jq -r '.items[] | \n  select(.metadata.deletionTimestamp != null) | \n\n# For\
    \ each selected item, set the name, deletion time, and finalizers as variables\
    \ and create a custom message\n  .metadata.name as $name | \n  .metadata.deletionTimestamp\
    \ as $deletion_time | \n  .metadata.finalizers as $finalizers | \n  \"\\($name)\
    \ is in Terminating state (Deletion started at: \\($deletion_time)). Finalizers:\
    \ \\($finalizers)\"'\n"
  name: list_persistentvolumeclaims_in_terminating_state_in_namespace_namespace
  when_is_it_useful: '1. Investigating and troubleshooting persistent volume claim
    (pvc) issues in a Kubernetes cluster, such as identifying and resolving "Terminating"
    pvc states.

    2. Monitoring and managing the lifecycle of persistent volumes and claims, ensuring
    proper deletion and cleanup processes are followed.

    3. Troubleshooting application or pod failures due to issues with persistent storage,
    such as reclaim policies or finalizer conflicts.

    4. Performing maintenance tasks related to persistent volume claims, such as identifying
    and deleting orphaned or stuck pvc objects.

    5. Auditing and validating the status of persistent volume claims in a specific
    namespace to ensure proper resource utilization and management within the Kubernetes
    environment.'
- command: 'namespace=${NAMESPACE}; context=${CONTEXT}; kubectl get pvc -n $namespace
    --context=$context -o json | jq -r ''.items[] | select(.metadata.deletionTimestamp
    != null) | .metadata.name as $name | .metadata.deletionTimestamp as $deletion_time
    | .metadata.finalizers as $finalizers | "\($name) is in Terminating state (Deletion
    started at: \($deletion_time)). Finalizers: \($finalizers)"'''
  doc_links: '

    - [Persistent Volume Claims](https://kubernetes.io/docs/concepts/storage/persistent-volumes/){:target="_blank"}

    - [Kubectl Command Line Tool](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [jq formatting tool](https://stedolan.github.io/jq/){:target="_blank"}'
  explanation: This command uses the Kubernetes command line tool (kubectl) to get
    information about persistent volume claims (pvc) in a specific namespace and context,
    displaying the ones that are in a "Terminating" state along with their deletion
    timestamp and finalizers. It also uses jq to format the output as human-readable
    text.
  multi_line_details: "\n# First, assign the values of NAMESPACE and CONTEXT to variables\n\
    namespace=${NAMESPACE}\ncontext=${CONTEXT}\n\n# Then use kubectl command to get\
    \ the list of PersistentVolumeClaims in the specified namespace and context in\
    \ JSON format\nkubectl get pvc -n $namespace --context=$context -o json |\n\n\
    # Next, use jq to filter the output and select only the items which have a deletionTimestamp\n\
    jq -r '.items[] | \n  select(.metadata.deletionTimestamp != null) | \n\n# For\
    \ each selected item, set the name, deletion time, and finalizers as variables\
    \ and create a custom message\n  .metadata.name as $name | \n  .metadata.deletionTimestamp\
    \ as $deletion_time | \n  .metadata.finalizers as $finalizers | \n  \"\\($name)\
    \ is in Terminating state (Deletion started at: \\($deletion_time)). Finalizers:\
    \ \\($finalizers)\"'\n"
  name: list_persistentvolumeclaims_in_terminating_state_in_namespace_namespace
  when_is_it_useful: '1. Investigating and troubleshooting persistent volume claim
    (pvc) issues in a Kubernetes cluster, such as identifying and resolving "Terminating"
    pvc states.

    2. Monitoring and managing the lifecycle of persistent volumes and claims, ensuring
    proper deletion and cleanup processes are followed.

    3. Troubleshooting application or pod failures due to issues with persistent storage,
    such as reclaim policies or finalizer conflicts.

    4. Performing maintenance tasks related to persistent volume claims, such as identifying
    and deleting orphaned or stuck pvc objects.

    5. Auditing and validating the status of persistent volume claims in a specific
    namespace to ensure proper resource utilization and management within the Kubernetes
    environment.'
- command: 'for pv in $(kubectl get pv --context ${CONTEXT} -o json | jq -r ''.items[]
    | select(.status.phase == "Terminating") | .metadata.name''); do kubectl get events
    --all-namespaces --field-selector involvedObject.name=$pv --context ${CONTEXT}
    -o json | jq ''.items[]| "Last Timestamp: " + .lastTimestamp + " Name: " + .involvedObject.name
    + " Message: " + .message''; done'
  doc_links: '

    - [Terminating Persistent Volumes in Kubernetes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/){:target="_blank"}

    - [Kubernetes Cluster Querying](https://kubernetes.io/docs/tasks/debug/debug-cluster/){:target="_blank"}

    - [jq Documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command retrieves information about events associated with terminating
    persistent volumes in a Kubernetes cluster by querying the cluster for relevant
    data and outputting it in a readable format using jq.
  multi_line_details: "\n# Iterate through each Persistent Volume (pv) that is in\
    \ the \"Terminating\" phase\nfor pv in $(kubectl get pv --context ${CONTEXT} -o\
    \ json | jq -r '.items[] | select(.status.phase == \"Terminating\") | .metadata.name');\
    \ do \n    # Use kubectl to get events from all namespaces associated with the\
    \ current pv\n    kubectl get events --all-namespaces --field-selector involvedObject.name=$pv\
    \ --context ${CONTEXT} -o json | \n        # Use jq to format the output into\
    \ a more readable and informative format\n        jq '.items[]| \"Last Timestamp:\
    \ \" + .lastTimestamp + \" Name: \" + .involvedObject.name + \" Message: \" +\
    \ .message'; \n    # End of the loop for each pv\ndone\n"
  name: list_persistentvolumes_in_terminating_state_in_namespace_namespace
  when_is_it_useful: '1. Troubleshooting Kubernetes CrashLoopBackoff events: A DevOps
    or Site Reliability Engineer might use this command to investigate and retrieve
    information about events related to CrashLoopBackoff in a Kubernetes cluster,
    in order to identify the cause of the issue and take corrective actions.


    2. Investigating issues with persistent volumes: If there are issues with persistent
    volumes terminating unexpectedly in a Kubernetes cluster, a DevOps or Site Reliability
    Engineer might use this command to gather information about the events associated
    with these terminations and analyze the data to understand the underlying causes.


    3. Monitoring and debugging storage-related problems: When facing storage-related
    problems in a Kubernetes environment, such as unexpected terminations or errors
    with persistent volumes, a DevOps or Site Reliability Engineer could use this
    command to gather event data and troubleshoot the issues effectively.


    4. Revising and optimizing storage configurations: To assess and improve the configuration
    of persistent volumes and their interactions within a Kubernetes deployment, a
    DevOps or Site Reliability Engineer may use this command to collect relevant event
    information and identify areas for optimization.


    5. Auditing and compliance checks: In the context of compliance checks or auditing
    processes, where it is necessary to review events related to persistent volume
    terminations in a Kubernetes cluster, a DevOps or Site Reliability Engineer might
    rely on this command to extract event data and ensure that all activities are
    compliant with the required standards.'
- command: 'for pv in $(kubectl get pv --context ${CONTEXT} -o json | jq -r ''.items[]
    | select(.status.phase == "Terminating") | .metadata.name''); do kubectl get events
    --all-namespaces --field-selector involvedObject.name=$pv --context ${CONTEXT}
    -o json | jq ''.items[]| "Last Timestamp: " + .lastTimestamp + " Name: " + .involvedObject.name
    + " Message: " + .message''; done'
  doc_links: '

    - [Terminating Persistent Volumes in Kubernetes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/){:target="_blank"}

    - [Kubernetes Cluster Querying](https://kubernetes.io/docs/tasks/debug/debug-cluster/){:target="_blank"}

    - [jq Documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: This command retrieves information about events associated with terminating
    persistent volumes in a Kubernetes cluster by querying the cluster for relevant
    data and outputting it in a readable format using jq.
  multi_line_details: "\n# Iterate through each Persistent Volume (pv) that is in\
    \ the \"Terminating\" phase\nfor pv in $(kubectl get pv --context ${CONTEXT} -o\
    \ json | jq -r '.items[] | select(.status.phase == \"Terminating\") | .metadata.name');\
    \ do \n    # Use kubectl to get events from all namespaces associated with the\
    \ current pv\n    kubectl get events --all-namespaces --field-selector involvedObject.name=$pv\
    \ --context ${CONTEXT} -o json | \n        # Use jq to format the output into\
    \ a more readable and informative format\n        jq '.items[]| \"Last Timestamp:\
    \ \" + .lastTimestamp + \" Name: \" + .involvedObject.name + \" Message: \" +\
    \ .message'; \n    # End of the loop for each pv\ndone\n"
  name: list_persistentvolumes_in_terminating_state_in_namespace_namespace
  when_is_it_useful: '1. Troubleshooting Kubernetes CrashLoopBackoff events: A DevOps
    or Site Reliability Engineer might use this command to investigate and retrieve
    information about events related to CrashLoopBackoff in a Kubernetes cluster,
    in order to identify the cause of the issue and take corrective actions.


    2. Investigating issues with persistent volumes: If there are issues with persistent
    volumes terminating unexpectedly in a Kubernetes cluster, a DevOps or Site Reliability
    Engineer might use this command to gather information about the events associated
    with these terminations and analyze the data to understand the underlying causes.


    3. Monitoring and debugging storage-related problems: When facing storage-related
    problems in a Kubernetes environment, such as unexpected terminations or errors
    with persistent volumes, a DevOps or Site Reliability Engineer could use this
    command to gather event data and troubleshoot the issues effectively.


    4. Revising and optimizing storage configurations: To assess and improve the configuration
    of persistent volumes and their interactions within a Kubernetes deployment, a
    DevOps or Site Reliability Engineer may use this command to collect relevant event
    information and identify areas for optimization.


    5. Auditing and compliance checks: In the context of compliance checks or auditing
    processes, where it is necessary to review events related to persistent volume
    terminations in a Kubernetes cluster, a DevOps or Site Reliability Engineer might
    rely on this command to extract event data and ensure that all activities are
    compliant with the required standards.'
- command: 'for pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running
    --context ${CONTEXT} -o jsonpath=''{range .items[*]}{.metadata.name}{"\n"}{end}'');
    do for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context ${CONTEXT} -o
    jsonpath=''{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{"\n"}{end}'');
    do pv=$(kubectl get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath=''{.spec.volumeName}'')
    && status=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath=''{.status.phase}'')
    && node=$(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath=''{.spec.nodeName}'')
    && zone=$(kubectl get nodes $node --context ${CONTEXT} -o jsonpath=''{.metadata.labels.topology\.kubernetes\.io/zone}'')
    && ingressclass=$(kubectl get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT} -o
    jsonpath=''{.spec.storageClassName}'') && accessmode=$(kubectl get pvc $pvc -n
    ${NAMESPACE} --context ${CONTEXT} -o jsonpath=''{.status.accessModes[0]}'') &&
    reclaimpolicy=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath=''{.spec.persistentVolumeReclaimPolicy}'')
    && csidriver=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath=''{.spec.csi.driver}'')&&
    echo -e "\n------------\nPod: $pod\nPVC: $pvc\nPV: $pv\nStatus: $status\nNode:
    $node\nZone: $zone\nIngressClass: $ingressclass\nAccessModes: $accessmode\nReclaimPolicy:
    $reclaimpolicy\nCSIDriver: $csidriver\n"; done; done'
  doc_links: '

    - [Kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Persistent Volume Claims](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims){:target="_blank"}

    - [Storage Classes in Kubernetes](https://kubernetes.io/docs/concepts/storage/storage-classes/){:target="_blank"}'
  explanation: This command uses kubectl to retrieve information about running pods
    in a specific namespace, including details about the persistent volume claims
    (PVC) and their associated storage volumes. It then prints out various attributes
    of each PVC and its related resources, such as status, node location, storage
    class, access mode, reclaim policy, and CSI driver.
  multi_line_details: "\n# Iterate through each running pod in the specified namespace\
    \ and context\nfor pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running\
    \ --context ${CONTEXT} -o jsonpath='{range .items[*]}{.metadata.name}{\"\\n\"\
    }{end}');\ndo\n  # Iterate through each persistent volume claim associated with\
    \ the current pod\n  for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context\
    \ ${CONTEXT} -o jsonpath='{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{\"\
    \\n\"}{end}');\n  do\n    # Retrieve information about the persistent volume associated\
    \ with the current PVC\n    pv=$(kubectl get pvc $pvc -n ${NAMESPACE} --context\
    \ ${CONTEXT} -o jsonpath='{.spec.volumeName}') && \n    status=$(kubectl get pv\
    \ $pv --context ${CONTEXT} -o jsonpath='{.status.phase}') &&\n    node=$(kubectl\
    \ get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath='{.spec.nodeName}')\
    \ &&\n    zone=$(kubectl get nodes $node --context ${CONTEXT} -o jsonpath='{.metadata.labels.topology\\\
    .kubernetes\\.io/zone}') &&\n    ingressclass=$(kubectl get pvc $pvc -n ${NAMESPACE}\
    \ --context ${CONTEXT} -o jsonpath='{.spec.storageClassName}') &&\n    accessmode=$(kubectl\
    \ get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath='{.status.accessModes[0]}')\
    \ &&\n    reclaimpolicy=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath='{.spec.persistentVolumeReclaimPolicy}')\
    \ &&\n    csidriver=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath='{.spec.csi.driver}')&&\n\
    \    # Print out the gathered information in a formatted manner\n    echo -e \"\
    \\n------------\\nPod: $pod\\nPVC: $pvc\\nPV: $pv\\nStatus: $status\\nNode: $node\\\
    nZone: $zone\\nIngressClass: $ingressclass\\nAccessModes: $accessmode\\nReclaimPolicy:\
    \ $reclaimpolicy\\nCSIDriver: $csidriver\\n\"; \n  done;\ndone\n \n\nThis script\
    \ retrieves detailed information about all running pods in a specific Kubernetes\
    \ namespace, including details about their associated Persistent Volume Claims\
    \ (PVCs) and Persistent Volumes (PVs). This information can be useful for troubleshooting\
    \ storage-related issues and understanding the storage configuration of running\
    \ pods."
  name: list_pods_with_attached_volumes_and_related_persistentvolume_details_in_namespace_namespace
  when_is_it_useful: '1. Troubleshooting Kubernetes CrashLoopBackoff events: A DevOps
    or Site Reliability Engineer might use this command to gather information about
    the persistent volume claims and their associated storage volumes in order to
    identify any issues with storage or access that could be causing pods to repeatedly
    crash and restart.


    2. Diagnosing slow performance or high latency: In cases where applications running
    on Kubernetes are experiencing slow performance or high latency, a DevOps or SRE
    might use this command to inspect the attributes of PVCs and associated resources
    to determine if there are any storage-related bottlenecks contributing to the
    performance issues.


    3. Capacity planning and resource optimization: When planning for future resource
    needs or optimizing existing infrastructure, a DevOps or SRE might use this command
    to analyze the current status, location, access mode, and other attributes of
    PVCs to determine how storage resources are being utilized and if there are any
    opportunities to improve efficiency.


    4. Troubleshooting application errors related to storage: If an application running
    on Kubernetes is reporting errors related to storage access or availability, a
    DevOps or SRE might use this command to investigate the status and attributes
    of PVCs to identify any potential issues with the underlying storage infrastructure.


    5. Auditing and compliance: As part of routine auditing or compliance efforts,
    a DevOps or SRE might use this command to gather detailed information about PVCs
    and their associated resources to ensure that storage configurations align with
    security and compliance requirements, such as access control, data protection,
    and retention policies.'
- command: 'for pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running
    --context ${CONTEXT} -o jsonpath=''{range .items[*]}{.metadata.name}{"\n"}{end}'');
    do for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context ${CONTEXT} -o
    jsonpath=''{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{"\n"}{end}'');
    do pv=$(kubectl get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath=''{.spec.volumeName}'')
    && status=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath=''{.status.phase}'')
    && node=$(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath=''{.spec.nodeName}'')
    && zone=$(kubectl get nodes $node --context ${CONTEXT} -o jsonpath=''{.metadata.labels.topology\.kubernetes\.io/zone}'')
    && ingressclass=$(kubectl get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT} -o
    jsonpath=''{.spec.storageClassName}'') && accessmode=$(kubectl get pvc $pvc -n
    ${NAMESPACE} --context ${CONTEXT} -o jsonpath=''{.status.accessModes[0]}'') &&
    reclaimpolicy=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath=''{.spec.persistentVolumeReclaimPolicy}'')
    && csidriver=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath=''{.spec.csi.driver}'')&&
    echo -e "\n------------\nPod: $pod\nPVC: $pvc\nPV: $pv\nStatus: $status\nNode:
    $node\nZone: $zone\nIngressClass: $ingressclass\nAccessModes: $accessmode\nReclaimPolicy:
    $reclaimpolicy\nCSIDriver: $csidriver\n"; done; done'
  doc_links: '

    - [Kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Persistent Volume Claims](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims){:target="_blank"}

    - [Storage Classes in Kubernetes](https://kubernetes.io/docs/concepts/storage/storage-classes/){:target="_blank"}'
  explanation: This command uses kubectl to retrieve information about running pods
    in a specific namespace, including details about the persistent volume claims
    (PVC) and their associated storage volumes. It then prints out various attributes
    of each PVC and its related resources, such as status, node location, storage
    class, access mode, reclaim policy, and CSI driver.
  multi_line_details: "\n# Iterate through each running pod in the specified namespace\
    \ and context\nfor pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running\
    \ --context ${CONTEXT} -o jsonpath='{range .items[*]}{.metadata.name}{\"\\n\"\
    }{end}');\ndo\n  # Iterate through each persistent volume claim associated with\
    \ the current pod\n  for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context\
    \ ${CONTEXT} -o jsonpath='{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{\"\
    \\n\"}{end}');\n  do\n    # Retrieve information about the persistent volume associated\
    \ with the current PVC\n    pv=$(kubectl get pvc $pvc -n ${NAMESPACE} --context\
    \ ${CONTEXT} -o jsonpath='{.spec.volumeName}') && \n    status=$(kubectl get pv\
    \ $pv --context ${CONTEXT} -o jsonpath='{.status.phase}') &&\n    node=$(kubectl\
    \ get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath='{.spec.nodeName}')\
    \ &&\n    zone=$(kubectl get nodes $node --context ${CONTEXT} -o jsonpath='{.metadata.labels.topology\\\
    .kubernetes\\.io/zone}') &&\n    ingressclass=$(kubectl get pvc $pvc -n ${NAMESPACE}\
    \ --context ${CONTEXT} -o jsonpath='{.spec.storageClassName}') &&\n    accessmode=$(kubectl\
    \ get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath='{.status.accessModes[0]}')\
    \ &&\n    reclaimpolicy=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath='{.spec.persistentVolumeReclaimPolicy}')\
    \ &&\n    csidriver=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath='{.spec.csi.driver}')&&\n\
    \    # Print out the gathered information in a formatted manner\n    echo -e \"\
    \\n------------\\nPod: $pod\\nPVC: $pvc\\nPV: $pv\\nStatus: $status\\nNode: $node\\\
    nZone: $zone\\nIngressClass: $ingressclass\\nAccessModes: $accessmode\\nReclaimPolicy:\
    \ $reclaimpolicy\\nCSIDriver: $csidriver\\n\"; \n  done;\ndone\n \n\nThis script\
    \ retrieves detailed information about all running pods in a specific Kubernetes\
    \ namespace, including details about their associated Persistent Volume Claims\
    \ (PVCs) and Persistent Volumes (PVs). This information can be useful for troubleshooting\
    \ storage-related issues and understanding the storage configuration of running\
    \ pods."
  name: list_pods_with_attached_volumes_and_related_persistentvolume_details_in_namespace_namespace
  when_is_it_useful: '1. Troubleshooting Kubernetes CrashLoopBackoff events: A DevOps
    or Site Reliability Engineer might use this command to gather information about
    the persistent volume claims and their associated storage volumes in order to
    identify any issues with storage or access that could be causing pods to repeatedly
    crash and restart.


    2. Diagnosing slow performance or high latency: In cases where applications running
    on Kubernetes are experiencing slow performance or high latency, a DevOps or SRE
    might use this command to inspect the attributes of PVCs and associated resources
    to determine if there are any storage-related bottlenecks contributing to the
    performance issues.


    3. Capacity planning and resource optimization: When planning for future resource
    needs or optimizing existing infrastructure, a DevOps or SRE might use this command
    to analyze the current status, location, access mode, and other attributes of
    PVCs to determine how storage resources are being utilized and if there are any
    opportunities to improve efficiency.


    4. Troubleshooting application errors related to storage: If an application running
    on Kubernetes is reporting errors related to storage access or availability, a
    DevOps or SRE might use this command to investigate the status and attributes
    of PVCs to identify any potential issues with the underlying storage infrastructure.


    5. Auditing and compliance: As part of routine auditing or compliance efforts,
    a DevOps or SRE might use this command to gather detailed information about PVCs
    and their associated resources to ensure that storage configurations align with
    security and compliance requirements, such as access control, data protection,
    and retention policies.'
- command: 'for pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running
    --context ${CONTEXT} -o jsonpath=''{range .items[*]}{.metadata.name}{"\n"}{end}'');
    do for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context ${CONTEXT} -o
    jsonpath=''{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{"\n"}{end}'');
    do for volumeName in $(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT}
    -o json | jq -r ''.spec.volumes[] | select(has("persistentVolumeClaim")) | .name'');
    do mountPath=$(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o json
    | jq -r --arg vol "$volumeName" ''.spec.containers[].volumeMounts[] | select(.name
    == $vol) | .mountPath''); containerName=$(kubectl get pod $pod -n ${NAMESPACE}
    --context ${CONTEXT} -o json | jq -r --arg vol "$volumeName" ''.spec.containers[]
    | select(.volumeMounts[].name == $vol) | .name''); echo -e "\n------------\nPod:
    $pod, PVC: $pvc, volumeName: $volumeName, containerName: $containerName, mountPath:
    $mountPath"; kubectl exec $pod -n ${NAMESPACE} --context ${CONTEXT} -c $containerName
    -- df -h $mountPath; done; done; done;'
  doc_links: '

    - [Kubernetes Documentation](https://kubernetes.io/docs/home/){:target="_blank"}

    - [Kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Understanding Kubernetes Objects](https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/){:target="_blank"}

    - [Using Persistent Volumes in Kubernetes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/){:target="_blank"}

    - [Linux Disk Usage (du) Command](https://linux.die.net/man/1/du){:target="_blank"}'
  explanation: This command is a complex series of nested loops that uses the Kubernetes
    command line tool (kubectl) to gather information about running pods in a specific
    namespace and context. It then retrieves information about the persistent volume
    claims, volumes, container names, and mount paths associated with these pods and
    prints the information along with disk usage statistics for each mount path.
  multi_line_details: "\n# Start by iterating through each running pod in the specified\
    \ namespace and context\nfor pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running\
    \ --context ${CONTEXT} -o jsonpath='{range .items[*]}{.metadata.name}{\"\\n\"\
    }{end}');\ndo \n  # For each pod, iterate through the persistent volume claims\
    \ (PVCs) associated with it\n  for pvc in $(kubectl get pods $pod -n ${NAMESPACE}\
    \ --context ${CONTEXT} -o jsonpath='{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{\"\
    \\n\"}{end}');\n  do \n    # Then, for each PVC, iterate through the volumes to\
    \ find the mount path\n    for volumeName in $(kubectl get pod $pod -n ${NAMESPACE}\
    \ --context ${CONTEXT} -o json | jq -r '.spec.volumes[] | select(has(\"persistentVolumeClaim\"\
    )) | .name');\n    do \n      # Use JSONPath and jq to retrieve the mount path\
    \ and container name for the specific volume\n      mountPath=$(kubectl get pod\
    \ $pod -n ${NAMESPACE} --context ${CONTEXT} -o json | jq -r --arg vol \"$volumeName\"\
    \ '.spec.containers[].volumeMounts[] | select(.name == $vol) | .mountPath');\n\
    \      containerName=$(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT}\
    \ -o json | jq -r --arg vol \"$volumeName\" '.spec.containers[] | select(.volumeMounts[].name\
    \ == $vol) | .name');\n      \n      # Print out the details of the pod, PVC,\
    \ volume name, container name, and mount path\n     echo -e \"\\n------------\\\
    nPod: $pod, PVC: $pvc, volumeName: $volumeName, containerName: $containerName,\
    \ mountPath: $mountPath\"; \n\n      # Finally, execute a disk usage command within\
    \ the pod to check the storage consumption at that mount path\n      kubectl exec\
    \ $pod -n ${NAMESPACE} --context ${CONTEXT} -c $containerName -- df -h $mountPath;\
    \ \n    done;\n  done;\ndone;\n"
  name: fetch_the_storage_utilization_for_pvc_mounts_in_namespace_namespace
  when_is_it_useful: '1. Troubleshooting Kubernetes CrashLoopBackoff events: When
    a pod enters a CrashLoopBackoff state, it means that the container in the pod
    repeatedly crashed shortly after starting. DevOps or Site Reliability Engineers
    may use this command to gather information about the pods, persistent volume claims,
    and volumes associated with the crashing containers to identify any disk usage
    issues or misconfigurations causing the crashes.


    2. Investigating high disk usage in Kubernetes clusters: DevOps or Site Reliability
    Engineers may use this command to gather information about the disk usage of pods
    running in a specific namespace and context within a Kubernetes cluster. This
    can help them identify which pods are consuming a large amount of disk space and
    troubleshoot any potential storage-related issues.


    3. Monitoring and optimizing resource utilization: By using this command to collect
    information about mount paths, container names, and disk usage statistics for
    running pods, DevOps or Site Reliability Engineers can gain insights into how
    resources are being utilized within a Kubernetes cluster. They can then use this
    information to optimize resource allocation and ensure efficient usage of storage
    resources.


    4. Identifying performance bottlenecks: If there are performance issues within
    a Kubernetes cluster, DevOps or Site Reliability Engineers may use this command
    to analyze the disk usage statistics of pods and identify any mount paths with
    high resource consumption. This can help in pinpointing performance bottlenecks
    and optimizing the cluster''s configuration for better performance.


    5. Troubleshooting storage-related issues: In case of issues related to persistent
    volume claims, volumes, or mount paths within a Kubernetes cluster, DevOps or
    Site Reliability Engineers may use this command to gather comprehensive information
    about these storage components and diagnose any problems affecting the proper
    functioning of applications running in the cluster.'
- command: 'for pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running
    --context ${CONTEXT} -o jsonpath=''{range .items[*]}{.metadata.name}{"\n"}{end}'');
    do for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context ${CONTEXT} -o
    jsonpath=''{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{"\n"}{end}'');
    do for volumeName in $(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT}
    -o json | jq -r ''.spec.volumes[] | select(has("persistentVolumeClaim")) | .name'');
    do mountPath=$(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o json
    | jq -r --arg vol "$volumeName" ''.spec.containers[].volumeMounts[] | select(.name
    == $vol) | .mountPath''); containerName=$(kubectl get pod $pod -n ${NAMESPACE}
    --context ${CONTEXT} -o json | jq -r --arg vol "$volumeName" ''.spec.containers[]
    | select(.volumeMounts[].name == $vol) | .name''); echo -e "\n------------\nPod:
    $pod, PVC: $pvc, volumeName: $volumeName, containerName: $containerName, mountPath:
    $mountPath"; kubectl exec $pod -n ${NAMESPACE} --context ${CONTEXT} -c $containerName
    -- df -h $mountPath; done; done; done;'
  doc_links: '

    - [Kubernetes Documentation](https://kubernetes.io/docs/home/){:target="_blank"}

    - [Kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/){:target="_blank"}

    - [Understanding Kubernetes Objects](https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/){:target="_blank"}

    - [Using Persistent Volumes in Kubernetes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/){:target="_blank"}

    - [Linux Disk Usage (du) Command](https://linux.die.net/man/1/du){:target="_blank"}'
  explanation: This command is a complex series of nested loops that uses the Kubernetes
    command line tool (kubectl) to gather information about running pods in a specific
    namespace and context. It then retrieves information about the persistent volume
    claims, volumes, container names, and mount paths associated with these pods and
    prints the information along with disk usage statistics for each mount path.
  multi_line_details: "\n# Start by iterating through each running pod in the specified\
    \ namespace and context\nfor pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running\
    \ --context ${CONTEXT} -o jsonpath='{range .items[*]}{.metadata.name}{\"\\n\"\
    }{end}');\ndo \n  # For each pod, iterate through the persistent volume claims\
    \ (PVCs) associated with it\n  for pvc in $(kubectl get pods $pod -n ${NAMESPACE}\
    \ --context ${CONTEXT} -o jsonpath='{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{\"\
    \\n\"}{end}');\n  do \n    # Then, for each PVC, iterate through the volumes to\
    \ find the mount path\n    for volumeName in $(kubectl get pod $pod -n ${NAMESPACE}\
    \ --context ${CONTEXT} -o json | jq -r '.spec.volumes[] | select(has(\"persistentVolumeClaim\"\
    )) | .name');\n    do \n      # Use JSONPath and jq to retrieve the mount path\
    \ and container name for the specific volume\n      mountPath=$(kubectl get pod\
    \ $pod -n ${NAMESPACE} --context ${CONTEXT} -o json | jq -r --arg vol \"$volumeName\"\
    \ '.spec.containers[].volumeMounts[] | select(.name == $vol) | .mountPath');\n\
    \      containerName=$(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT}\
    \ -o json | jq -r --arg vol \"$volumeName\" '.spec.containers[] | select(.volumeMounts[].name\
    \ == $vol) | .name');\n      \n      # Print out the details of the pod, PVC,\
    \ volume name, container name, and mount path\n     echo -e \"\\n------------\\\
    nPod: $pod, PVC: $pvc, volumeName: $volumeName, containerName: $containerName,\
    \ mountPath: $mountPath\"; \n\n      # Finally, execute a disk usage command within\
    \ the pod to check the storage consumption at that mount path\n      kubectl exec\
    \ $pod -n ${NAMESPACE} --context ${CONTEXT} -c $containerName -- df -h $mountPath;\
    \ \n    done;\n  done;\ndone;\n"
  name: fetch_the_storage_utilization_for_pvc_mounts_in_namespace_namespace
  when_is_it_useful: '1. Troubleshooting Kubernetes CrashLoopBackoff events: When
    a pod enters a CrashLoopBackoff state, it means that the container in the pod
    repeatedly crashed shortly after starting. DevOps or Site Reliability Engineers
    may use this command to gather information about the pods, persistent volume claims,
    and volumes associated with the crashing containers to identify any disk usage
    issues or misconfigurations causing the crashes.


    2. Investigating high disk usage in Kubernetes clusters: DevOps or Site Reliability
    Engineers may use this command to gather information about the disk usage of pods
    running in a specific namespace and context within a Kubernetes cluster. This
    can help them identify which pods are consuming a large amount of disk space and
    troubleshoot any potential storage-related issues.


    3. Monitoring and optimizing resource utilization: By using this command to collect
    information about mount paths, container names, and disk usage statistics for
    running pods, DevOps or Site Reliability Engineers can gain insights into how
    resources are being utilized within a Kubernetes cluster. They can then use this
    information to optimize resource allocation and ensure efficient usage of storage
    resources.


    4. Identifying performance bottlenecks: If there are performance issues within
    a Kubernetes cluster, DevOps or Site Reliability Engineers may use this command
    to analyze the disk usage statistics of pods and identify any mount paths with
    high resource consumption. This can help in pinpointing performance bottlenecks
    and optimizing the cluster''s configuration for better performance.


    5. Troubleshooting storage-related issues: In case of issues related to persistent
    volume claims, volumes, or mount paths within a Kubernetes cluster, DevOps or
    Site Reliability Engineers may use this command to gather comprehensive information
    about these storage components and diagnose any problems affecting the proper
    functioning of applications running in the cluster.'
- command: 'NAMESPACE="${NAMESPACE}"; CONTEXT="${CONTEXT}"; PODS=$(kubectl get pods
    -n $NAMESPACE --context=$CONTEXT -o json); for pod in $(jq -r ''.items[] | @base64''
    <<< "$PODS"); do _jq() { jq -r \${1} <<< "$(base64 --decode <<< \${pod})"; };
    POD_NAME=$(_jq ''.metadata.name''); POD_NODE_NAME=$(kubectl get pod $POD_NAME
    -n $NAMESPACE --context=$CONTEXT -o custom-columns=:.spec.nodeName --no-headers);
    PVC_NAMES=$(kubectl get pod $POD_NAME -n $NAMESPACE --context=$CONTEXT -o jsonpath=''{.spec.volumes[*].persistentVolumeClaim.claimName}'');
    for pvc_name in $PVC_NAMES; do PVC=$(kubectl get pvc $pvc_name -n $NAMESPACE --context=$CONTEXT
    -o json); ACCESS_MODE=$(jq -r ''.spec.accessModes[0]'' <<< "$PVC"); if [[ "$ACCESS_MODE"
    == "ReadWriteOnce" ]]; then PV_NAME=$(jq -r ''.spec.volumeName'' <<< "$PVC");
    STORAGE_NODE_NAME=$(jq -r --arg pv "$PV_NAME" ''.items[] | select(.status.volumesAttached
    != null) | select(.status.volumesInUse[] | contains($pv)) | .metadata.name'' <<<
    "$(kubectl get nodes --context=$CONTEXT -o json)"); echo "------------"; if [[
    "$POD_NODE_NAME" == "$STORAGE_NODE_NAME" ]]; then echo "OK: Pod and Storage Node
    Matched"; else echo "Error: Pod and Storage Node Mismatched - If the issue persists,
    the node requires attention."; fi; echo "Pod: $POD_NAME"; echo "PVC: $pvc_name";
    echo "PV: $PV_NAME"; echo "Node with Pod: $POD_NODE_NAME"; echo "Node with Storage:
    $STORAGE_NODE_NAME"; echo; fi; done; done'
  doc_links: '

    - [Bash scripting tutorial](https://www.tutorialspoint.com/unix/shell_scripting.htm){:target="_blank"}

    - [Kubectl documentation](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [Understanding Kubernetes Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod/){:target="_blank"}

    - [Understanding Kubernetes Persistent Volume Claims](https://kubernetes.io/docs/concepts/storage/persistent-volumes/){:target="_blank"}'
  explanation: This command is a bash script that uses the kubectl command to retrieve
    information about pods and their associated persistent volume claims and check
    if the storage node matches the pod node. If there is a mismatch, it will display
    an error message.
  multi_line_details: "\n# Set the namespace and context variables\nNAMESPACE=\"${NAMESPACE}\"\
    \nCONTEXT=\"${CONTEXT}\"\n\n# Retrieve pods on the given namespace and context\
    \ in JSON format\nPODS=$(kubectl get pods -n $NAMESPACE --context=$CONTEXT -o\
    \ json)\n\n# Loop through each pod and gather relevant information\nfor pod in\
    \ $(jq -r '.items[] | @base64' <<< \"$PODS\"); do\n    _jq() { jq -r \\${1} <<<\
    \ \"$(base64 --decode <<< \\${pod})\"; }\n    POD_NAME=$(_jq '.metadata.name')\n\
    \    \n    # Get the node where the pod is running\n    POD_NODE_NAME=$(kubectl\
    \ get pod $POD_NAME -n $NAMESPACE --context=$CONTEXT -o custom-columns=:.spec.nodeName\
    \ --no-headers)\n    \n    # Get the PVC names associated with the pod\n    PVC_NAMES=$(kubectl\
    \ get pod $POD_NAME -n $NAMESPACE --context=$CONTEXT -o jsonpath='{.spec.volumes[*].persistentVolumeClaim.claimName}')\n\
    \    \n    # Loop through each PVC name and gather relevant information\n    for\
    \ pvc_name in $PVC_NAMES; do\n        PVC=$(kubectl get pvc $pvc_name -n $NAMESPACE\
    \ --context=$CONTEXT -o json)\n        ACCESS_MODE=$(jq -r '.spec.accessModes[0]'\
    \ <<< \"$PVC\")\n        \n        # Check if the PVC access mode is ReadWriteOnce\n\
    \        if [[ \"$ACCESS_MODE\" == \"ReadWriteOnce\" ]]; then\n            PV_NAME=$(jq\
    \ -r '.spec.volumeName' <<< \"$PVC\")\n            \n            # Get the node\
    \ where the storage belonging to the PVC is attached\n            STORAGE_NODE_NAME=$(jq\
    \ -r --arg pv \"$PV_NAME\" '.items[] | select(.status.volumesAttached != null)\
    \ | select(.status.volumesInUse[] | contains($pv)) | .metadata.name' <<< \"$(kubectl\
    \ get nodes --context=$CONTEXT -o json)\")\n            \n            # Print\
    \ the corresponding information based on the comparison between the pod node and\
    \ storage node\n            echo \"------------\"\n            \n            if\
    \ [[ \"$POD_NODE_NAME\" == \"$STORAGE_NODE_NAME\" ]]; then\n                echo\
    \ \"OK: Pod and Storage Node Matched\"\n            else\n                echo\
    \ \"Error: Pod and Storage Node Mismatched - If the issue persists, the node requires\
    \ attention.\"\n            fi\n            \n            echo \"Pod: $POD_NAME\"\
    \n            echo \"PVC: $pvc_name\"\n            echo \"PV: $PV_NAME\"\n   \
    \         echo \"Node with Pod: $POD_NODE_NAME\"\n            echo \"Node with\
    \ Storage: $STORAGE_NODE_NAME\"\n            echo\n        fi\n    done\ndone\n"
  name: check_for_rwo_persistent_volume_node_attachment_issues_in_namespace_namespace
  when_is_it_useful: '1. Troubleshooting Kubernetes CrashLoopBackoff events: A DevOps
    or Site Reliability Engineer may need to use this command to check for any mismatch
    between storage nodes and pod nodes, which could be causing the CrashLoopBackoff
    events.


    2. Investigating storage-related issues: If there are issues with persistent volume
    claims not being properly mounted or accessed by pods, the engineer may use this
    command to identify any mismatches between the storage and pod nodes.


    3. Resolving performance problems: When experiencing poor performance in a Kubernetes
    environment, checking for mismatches between storage and pod nodes can help identify
    potential bottlenecks and aid in optimizing performance.


    4. Debugging unexpected errors: In case of unexpected errors related to storage
    operations in Kubernetes, such as file system errors or mount failures, using
    this command can help pinpoint any discrepancies between storage and pod nodes.


    5. Ensuring data consistency: To ensure data consistency and integrity within
    a Kubernetes cluster, DevOps or SREs may use this command to verify that persistent
    volume claims are correctly linked to their respective pods.'
- command: 'NAMESPACE="${NAMESPACE}"; CONTEXT="${CONTEXT}"; PODS=$(kubectl get pods
    -n $NAMESPACE --context=$CONTEXT -o json); for pod in $(jq -r ''.items[] | @base64''
    <<< "$PODS"); do _jq() { jq -r \${1} <<< "$(base64 --decode <<< \${pod})"; };
    POD_NAME=$(_jq ''.metadata.name''); POD_NODE_NAME=$(kubectl get pod $POD_NAME
    -n $NAMESPACE --context=$CONTEXT -o custom-columns=:.spec.nodeName --no-headers);
    PVC_NAMES=$(kubectl get pod $POD_NAME -n $NAMESPACE --context=$CONTEXT -o jsonpath=''{.spec.volumes[*].persistentVolumeClaim.claimName}'');
    for pvc_name in $PVC_NAMES; do PVC=$(kubectl get pvc $pvc_name -n $NAMESPACE --context=$CONTEXT
    -o json); ACCESS_MODE=$(jq -r ''.spec.accessModes[0]'' <<< "$PVC"); if [[ "$ACCESS_MODE"
    == "ReadWriteOnce" ]]; then PV_NAME=$(jq -r ''.spec.volumeName'' <<< "$PVC");
    STORAGE_NODE_NAME=$(jq -r --arg pv "$PV_NAME" ''.items[] | select(.status.volumesAttached
    != null) | select(.status.volumesInUse[] | contains($pv)) | .metadata.name'' <<<
    "$(kubectl get nodes --context=$CONTEXT -o json)"); echo "------------"; if [[
    "$POD_NODE_NAME" == "$STORAGE_NODE_NAME" ]]; then echo "OK: Pod and Storage Node
    Matched"; else echo "Error: Pod and Storage Node Mismatched - If the issue persists,
    the node requires attention."; fi; echo "Pod: $POD_NAME"; echo "PVC: $pvc_name";
    echo "PV: $PV_NAME"; echo "Node with Pod: $POD_NODE_NAME"; echo "Node with Storage:
    $STORAGE_NODE_NAME"; echo; fi; done; done'
  doc_links: '

    - [Bash scripting tutorial](https://www.tutorialspoint.com/unix/shell_scripting.htm){:target="_blank"}

    - [Kubectl documentation](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [Understanding Kubernetes Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod/){:target="_blank"}

    - [Understanding Kubernetes Persistent Volume Claims](https://kubernetes.io/docs/concepts/storage/persistent-volumes/){:target="_blank"}'
  explanation: This command is a bash script that uses the kubectl command to retrieve
    information about pods and their associated persistent volume claims and check
    if the storage node matches the pod node. If there is a mismatch, it will display
    an error message.
  multi_line_details: "\n# Set the namespace and context variables\nNAMESPACE=\"${NAMESPACE}\"\
    \nCONTEXT=\"${CONTEXT}\"\n\n# Retrieve pods on the given namespace and context\
    \ in JSON format\nPODS=$(kubectl get pods -n $NAMESPACE --context=$CONTEXT -o\
    \ json)\n\n# Loop through each pod and gather relevant information\nfor pod in\
    \ $(jq -r '.items[] | @base64' <<< \"$PODS\"); do\n    _jq() { jq -r \\${1} <<<\
    \ \"$(base64 --decode <<< \\${pod})\"; }\n    POD_NAME=$(_jq '.metadata.name')\n\
    \    \n    # Get the node where the pod is running\n    POD_NODE_NAME=$(kubectl\
    \ get pod $POD_NAME -n $NAMESPACE --context=$CONTEXT -o custom-columns=:.spec.nodeName\
    \ --no-headers)\n    \n    # Get the PVC names associated with the pod\n    PVC_NAMES=$(kubectl\
    \ get pod $POD_NAME -n $NAMESPACE --context=$CONTEXT -o jsonpath='{.spec.volumes[*].persistentVolumeClaim.claimName}')\n\
    \    \n    # Loop through each PVC name and gather relevant information\n    for\
    \ pvc_name in $PVC_NAMES; do\n        PVC=$(kubectl get pvc $pvc_name -n $NAMESPACE\
    \ --context=$CONTEXT -o json)\n        ACCESS_MODE=$(jq -r '.spec.accessModes[0]'\
    \ <<< \"$PVC\")\n        \n        # Check if the PVC access mode is ReadWriteOnce\n\
    \        if [[ \"$ACCESS_MODE\" == \"ReadWriteOnce\" ]]; then\n            PV_NAME=$(jq\
    \ -r '.spec.volumeName' <<< \"$PVC\")\n            \n            # Get the node\
    \ where the storage belonging to the PVC is attached\n            STORAGE_NODE_NAME=$(jq\
    \ -r --arg pv \"$PV_NAME\" '.items[] | select(.status.volumesAttached != null)\
    \ | select(.status.volumesInUse[] | contains($pv)) | .metadata.name' <<< \"$(kubectl\
    \ get nodes --context=$CONTEXT -o json)\")\n            \n            # Print\
    \ the corresponding information based on the comparison between the pod node and\
    \ storage node\n            echo \"------------\"\n            \n            if\
    \ [[ \"$POD_NODE_NAME\" == \"$STORAGE_NODE_NAME\" ]]; then\n                echo\
    \ \"OK: Pod and Storage Node Matched\"\n            else\n                echo\
    \ \"Error: Pod and Storage Node Mismatched - If the issue persists, the node requires\
    \ attention.\"\n            fi\n            \n            echo \"Pod: $POD_NAME\"\
    \n            echo \"PVC: $pvc_name\"\n            echo \"PV: $PV_NAME\"\n   \
    \         echo \"Node with Pod: $POD_NODE_NAME\"\n            echo \"Node with\
    \ Storage: $STORAGE_NODE_NAME\"\n            echo\n        fi\n    done\ndone\n"
  name: check_for_rwo_persistent_volume_node_attachment_issues_in_namespace_namespace
  when_is_it_useful: '1. Troubleshooting Kubernetes CrashLoopBackoff events: A DevOps
    or Site Reliability Engineer may need to use this command to check for any mismatch
    between storage nodes and pod nodes, which could be causing the CrashLoopBackoff
    events.


    2. Investigating storage-related issues: If there are issues with persistent volume
    claims not being properly mounted or accessed by pods, the engineer may use this
    command to identify any mismatches between the storage and pod nodes.


    3. Resolving performance problems: When experiencing poor performance in a Kubernetes
    environment, checking for mismatches between storage and pod nodes can help identify
    potential bottlenecks and aid in optimizing performance.


    4. Debugging unexpected errors: In case of unexpected errors related to storage
    operations in Kubernetes, such as file system errors or mount failures, using
    this command can help pinpoint any discrepancies between storage and pod nodes.


    5. Ensuring data consistency: To ensure data consistency and integrity within
    a Kubernetes cluster, DevOps or SREs may use this command to verify that persistent
    volume claims are correctly linked to their respective pods.'
