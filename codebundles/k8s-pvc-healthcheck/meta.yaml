commands:
- command: 'for pvc in $(kubectl get pvc -n ${NAMESPACE} --context ${CONTEXT} -o json
    | jq -r ''.items[] | select(.status.phase != "Bound") | .metadata.name''); do
    kubectl get events -n ${NAMESPACE} --context ${CONTEXT} --field-selector involvedObject.name=$pvc
    -o json | jq ''.items[]| "Last Timestamp: " + .lastTimestamp + ", Name: " + .involvedObject.name
    + ", Message: " + .message''; done'
  doc_links: '

    - [Persistent Volume Claims in Kubernetes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims){:target="_blank"}'
  explanation: This command is a shell command used in Kubernetes to monitor the status
    of persistent volume claims (pvc). It retrieves events related to PVCs that are
    not yet bound and displays information such as last timestamp, name, and message.
  multi_line_details: "# Set the namespace and context\nNAMESPACE=\"your_namespace\"\
    \nCONTEXT=\"your_context\"\n\n# Loop through each PVC in the specified namespace\
    \ and context\nfor pvc in $(kubectl get pvc -n ${NAMESPACE} --context ${CONTEXT}\
    \ -o json | jq -r '.items[] | select(.status.phase != \"Bound\") | .metadata.name');\
    \ do \n    # Get events for each PVC\n    kubectl get events -n ${NAMESPACE} --context\
    \ ${CONTEXT} --field-selector involvedObject.name=$pvc -o json | jq '.items[]|\
    \ \"Last Timestamp: \" + .lastTimestamp + \", Name: \" + .involvedObject.name\
    \ + \", Message: \" + .message'; \ndone"
  name: fetch_events_for_unhealthy_kubernetes_persistentvolumeclaims_in_namespace_namespace
- command: 'namespace=${NAMESPACE}; context=${CONTEXT}; kubectl get pvc -n $namespace
    --context=$context -o json | jq -r ''.items[] | select(.metadata.deletionTimestamp
    != null) | .metadata.name as $name | .metadata.deletionTimestamp as $deletion_time
    | .metadata.finalizers as $finalizers | "\($name) is in Terminating state (Deletion
    started at: \($deletion_time)). Finalizers: \($finalizers)"'''
  doc_links: '

    - [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [Kubernetes Contexts](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/){:target="_blank"}

    - [Kubectl Get PersistentVolumeClaims](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [Jq Command Line JSON Processor](https://stedolan.github.io/jq/){:target="_blank"}'
  explanation: This command sets the namespace and context, then uses kubectl to get
    information about persistent volume claims in the specified namespace and context,
    and formats the output using the jq tool to display PV names that are in the process
    of being deleted, along with their deletion timestamp and finalizers.
  multi_line_details: "#!/bin/bash\n\n# Set the namespace to a specific value\nnamespace=${NAMESPACE}\n\
    \n# Set the context to a specific value\ncontext=${CONTEXT}\n\n# Use kubectl to\
    \ get PVC in the specified namespace and context in JSON format\nkubectl get pvc\
    \ -n $namespace --context=$context -o json |\n  \n  # Use jq to filter PVCs that\
    \ have a deletionTimestamp\n  jq -r '.items[] | select(.metadata.deletionTimestamp\
    \ != null) |\n    \n    # Map the PVC metadata to specific variables and create\
    \ a custom output message\n    .metadata.name as $name | \n    .metadata.deletionTimestamp\
    \ as $deletion_time | \n    .metadata.finalizers as $finalizers | \n    \"\\($name)\
    \ is in Terminating state (Deletion started at: \\($deletion_time)). Finalizers:\
    \ \\($finalizers)\"'"
  name: list_persistentvolumeclaims_in_terminating_state_in_namespace_namespace
- command: 'for pv in $(kubectl get pv --context ${CONTEXT} -o json | jq -r ''.items[]
    | select(.status.phase == "Terminating") | .metadata.name''); do kubectl get events
    --all-namespaces --field-selector involvedObject.name=$pv --context ${CONTEXT}
    -o json | jq ''.items[]| "Last Timestamp: " + .lastTimestamp + " Name: " + .involvedObject.name
    + " Message: " + .message''; done'
  doc_links: '

    - [kubectl overview](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#overview){:target="_blank"}

    - [persistent volumes in Kubernetes](https://kubernetes.io/docs/concepts/storage/persistent-volumes){:target="_blank"}

    - [Terminating phase in Kubernetes](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase){:target="_blank"}

    - [kubectl get events](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get-event){:target="_blank"}'
  explanation: This command uses kubectl to retrieve information about persistent
    volumes in a Kubernetes cluster, specifically those in the "Terminating" phase,
    and then retrieves events related to these volumes in a specific context. It uses
    jq to parse and format the output into a more readable form.
  multi_line_details: "# Multi-line command with docstrings/comments\nfor pv in $(kubectl\
    \ get pv --context ${CONTEXT} -o json | jq -r '.items[] | select(.status.phase\
    \ == \"Terminating\") | .metadata.name'); \ndo\n    # Fetch events for the current\
    \ persistent volume\n    kubectl get events --all-namespaces --field-selector\
    \ involvedObject.name=$pv --context ${CONTEXT} -o json | \n    # Select and format\
    \ relevant event information\n    jq '.items[]| \"Last Timestamp: \" + .lastTimestamp\
    \ + \" Name: \" + .involvedObject.name + \" Message: \" + .message'; \ndone"
  name: list_persistentvolumes_in_terminating_state_in_namespace_namespace
- command: 'for pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running
    --context ${CONTEXT} -o jsonpath=''{range .items[*]}{.metadata.name}{"\n"}{end}'');
    do for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context ${CONTEXT} -o
    jsonpath=''{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{"\n"}{end}'');
    do pv=$(kubectl get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath=''{.spec.volumeName}'')
    && status=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath=''{.status.phase}'')
    && node=$(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath=''{.spec.nodeName}'')
    && zone=$(kubectl get nodes $node --context ${CONTEXT} -o jsonpath=''{.metadata.labels.topology\.kubernetes\.io/zone}'')
    && ingressclass=$(kubectl get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT} -o
    jsonpath=''{.spec.storageClassName}'') && accessmode=$(kubectl get pvc $pvc -n
    ${NAMESPACE} --context ${CONTEXT} -o jsonpath=''{.status.accessModes[0]}'') &&
    reclaimpolicy=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath=''{.spec.persistentVolumeReclaimPolicy}'')
    && csidriver=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath=''{.spec.csi.driver}'')&&
    echo -e "\n------------\nPod: $pod\nPVC: $pvc\nPV: $pv\nStatus: $status\nNode:
    $node\nZone: $zone\nIngressClass: $ingressclass\nAccessModes: $accessmode\nReclaimPolicy:
    $reclaimpolicy\nCSIDriver: $csidriver\n"; done; done'
  doc_links: '

    - [Kubernetes API Overview](https://kubernetes.io/docs/concepts/overview/kubernetes-api/){:target="_blank"}

    - [Persistent Volumes in Kubernetes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/){:target="_blank"}

    - [Storage Classes in Kubernetes](https://kubernetes.io/docs/concepts/storage/storage-classes/){:target="_blank"}

    - [CSI (Container Storage Interface)](https://kubernetes-csi.github.io/docs/){:target="_blank"}'
  explanation: This command retrieves information about running pods and their associated
    persistent volume claims in a Kubernetes cluster, including details like the status
    of the persistent volume, the node it's located on, the storage class, access
    mode, reclaim policy, and CSI driver being used. It then outputs this information
    in a formatted way for easy viewing and analysis.
  multi_line_details: "for pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running\
    \ --context ${CONTEXT} -o jsonpath='{range .items[*]}{.metadata.name}{\"\\n\"\
    }{end}')\ndo \n  for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context\
    \ ${CONTEXT} -o jsonpath='{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{\"\
    \\n\"}{end}')\n  do\n    pv=$(kubectl get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT}\
    \ -o jsonpath='{.spec.volumeName}')\n    status=$(kubectl get pv $pv --context\
    \ ${CONTEXT} -o jsonpath='{.status.phase}')\n    node=$(kubectl get pod $pod -n\
    \ ${NAMESPACE} --context ${CONTEXT} -o jsonpath='{.spec.nodeName}')\n    zone=$(kubectl\
    \ get nodes $node --context ${CONTEXT} -o jsonpath='{.metadata.labels.topology\\\
    .kubernetes\\.io/zone}')\n    ingressclass=$(kubectl get pvc $pvc -n ${NAMESPACE}\
    \ --context ${CONTEXT} -o jsonpath='{.spec.storageClassName}')\n    accessmode=$(kubectl\
    \ get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath='{.status.accessModes[0]}')\n\
    \    reclaimpolicy=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath='{.spec.persistentVolumeReclaimPolicy}')\n\
    \    csidriver=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath='{.spec.csi.driver}')\n\
    \    echo -e \"\\n------------\\nPod: $pod\\nPVC: $pvc\\nPV: $pv\\nStatus: $status\\\
    nNode: $node\\nZone: $zone\\nIngressClass: $ingressclass\\nAccessModes: $accessmode\\\
    nReclaimPolicy: $reclaimpolicy\\nCSIDriver: $csidriver\\n\"\n  done\ndone\n\n\
    # This script fetches various details such as pod names, persistent volume claim\
    \ names, statuses, nodes, zones, ingress class, access modes, reclaim policy,\
    \ and CSI driver from the Kubernetes cluster using kubectl commands."
  name: list_pods_with_attached_volumes_and_related_persistentvolume_details_in_namespace_namespace
- command: 'for pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running
    --context ${CONTEXT} -o jsonpath=''{range .items[*]}{.metadata.name}{"\n"}{end}'');
    do for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context ${CONTEXT} -o
    jsonpath=''{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{"\n"}{end}'');
    do for volumeName in $(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT}
    -o json | jq -r ''.spec.volumes[] | select(has("persistentVolumeClaim")) | .name'');
    do mountPath=$(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o json
    | jq -r --arg vol "$volumeName" ''.spec.containers[].volumeMounts[] | select(.name
    == $vol) | .mountPath''); containerName=$(kubectl get pod $pod -n ${NAMESPACE}
    --context ${CONTEXT} -o json | jq -r --arg vol "$volumeName" ''.spec.containers[]
    | select(.volumeMounts[].name == $vol) | .name''); echo -e "\n------------\nPod:
    $pod, PVC: $pvc, volumeName: $volumeName, containerName: $containerName, mountPath:
    $mountPath"; kubectl exec $pod -n ${NAMESPACE} --context ${CONTEXT} -c $containerName
    -- df -h $mountPath; done; done; done;'
  doc_links: '

    - [Kubernetes Pods](https://kubernetes.io/docs/concepts/workloads/pods/){:target="_blank"}

    - [Persistent Volume Claims (PVC)](https://kubernetes.io/docs/concepts/storage/persistent-volumes/){:target="_blank"}

    - [Volumes in Kubernetes](https://kubernetes.io/docs/concepts/storage/volumes/){:target="_blank"}

    - [Container Names in Kubernetes](https://kubernetes.io/docs/concepts/workloads/pods/pod/){:target="_blank"}

    - [`df -h` command explanation](https://linuxize.com/post/check-disk-space-linux/){:target="_blank"}'
  explanation: This command is used to iterate through each pod in a Kubernetes namespace
    that is in a running state and retrieve information about its persistent volume
    claims, volumes, container names, and mount paths. It then executes a `df -h`
    command on each mount path to check the disk space usage within the container.
  multi_line_details: "for pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running\
    \ --context ${CONTEXT} -o jsonpath='{range .items[*]}{.metadata.name}{\"\\n\"\
    }{end}');\n    do \n        for pvc in $(kubectl get pods $pod -n ${NAMESPACE}\
    \ --context ${CONTEXT} -o jsonpath='{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{\"\
    \\n\"}{end}');\n            do \n                for volumeName in $(kubectl get\
    \ pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o json | jq -r '.spec.volumes[]\
    \ | select(has(\"persistentVolumeClaim\")) | .name');\n                    do\
    \ \n                        mountPath=$(kubectl get pod $pod -n ${NAMESPACE} --context\
    \ ${CONTEXT} -o json | jq -r --arg vol \"$volumeName\" '.spec.containers[].volumeMounts[]\
    \ | select(.name == $vol) | .mountPath');\n                        containerName=$(kubectl\
    \ get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o json | jq -r --arg vol\
    \ \"$volumeName\" '.spec.containers[] | select(.volumeMounts[].name == $vol) |\
    \ .name');\n                        echo -e \"\\n------------\\nPod: $pod, PVC:\
    \ $pvc, volumeName: $volumeName, containerName: $containerName, mountPath: $mountPath\"\
    ;\n                        kubectl exec $pod -n ${NAMESPACE} --context ${CONTEXT}\
    \ -c $containerName -- df -h $mountPath;\n                    done;\n        \
    \    done;\n    done;"
  name: fetch_the_storage_utilization_for_pvc_mounts_in_namespace_namespace
- command: 'NAMESPACE="${NAMESPACE}"; CONTEXT="${CONTEXT}"; PODS=$(kubectl get pods
    -n $NAMESPACE --context=$CONTEXT -o json); for pod in $(jq -r ''.items[] | @base64''
    <<< "$PODS"); do _jq() { jq -r \${1} <<< "$(base64 --decode <<< \${pod})"; };
    POD_NAME=$(_jq ''.metadata.name''); POD_NODE_NAME=$(kubectl get pod $POD_NAME
    -n $NAMESPACE --context=$CONTEXT -o custom-columns=:.spec.nodeName --no-headers);
    PVC_NAMES=$(kubectl get pod $POD_NAME -n $NAMESPACE --context=$CONTEXT -o jsonpath=''{.spec.volumes[*].persistentVolumeClaim.claimName}'');
    for pvc_name in $PVC_NAMES; do PVC=$(kubectl get pvc $pvc_name -n $NAMESPACE --context=$CONTEXT
    -o json); ACCESS_MODE=$(jq -r ''.spec.accessModes[0]'' <<< "$PVC"); if [[ "$ACCESS_MODE"
    == "ReadWriteOnce" ]]; then PV_NAME=$(jq -r ''.spec.volumeName'' <<< "$PVC");
    STORAGE_NODE_NAME=$(jq -r --arg pv "$PV_NAME" ''.items[] | select(.status.volumesAttached
    != null) | select(.status.volumesInUse[] | contains($pv)) | .metadata.name'' <<<
    "$(kubectl get nodes --context=$CONTEXT -o json)"); echo "------------"; if [[
    "$POD_NODE_NAME" == "$STORAGE_NODE_NAME" ]]; then echo "OK: Pod and Storage Node
    Matched"; else echo "Error: Pod and Storage Node Mismatched - If the issue persists,
    the node requires attention."; fi; echo "Pod: $POD_NAME"; echo "PVC: $pvc_name";
    echo "PV: $PV_NAME"; echo "Node with Pod: $POD_NODE_NAME"; echo "Node with Storage:
    $STORAGE_NODE_NAME"; echo; fi; done; done'
  doc_links: '

    '
  explanation: This command is a script that uses kubectl to get information about
    pods and their associated persistent volume claims (PVCs) in a Kubernetes cluster.
    It checks if the pod and storage node match and outputs any errors if there are
    mismatches.
  multi_line_details: "NAMESPACE=\"${NAMESPACE}\"\nCONTEXT=\"${CONTEXT}\"\n# Getting\
    \ the pods in the specified namespace and context in JSON format\nPODS=$(kubectl\
    \ get pods -n $NAMESPACE --context=$CONTEXT -o json)\n\n# Iterating through each\
    \ pod in the JSON output\nfor pod in $(jq -r '.items[] | @base64' <<< \"$PODS\"\
    ); do\n    # Function to decode the base64 value and extract the pod name\n  \
    \  _jq() { jq -r ${1} <<< \"$(base64 --decode <<< ${pod})\"; }\n    POD_NAME=$(_jq\
    \ '.metadata.name')\n    # Getting the node on which the pod is running\n    POD_NODE_NAME=$(kubectl\
    \ get pod $POD_NAME -n $NAMESPACE --context=$CONTEXT -o custom-columns=:.spec.nodeName\
    \ --no-headers)\n    \n    # Getting the names of PVCs attached to the pod\n \
    \   PVC_NAMES=$(kubectl get pod $POD_NAME -n $NAMESPACE --context=$CONTEXT -o\
    \ jsonpath='{.spec.volumes[*].persistentVolumeClaim.claimName}')\n    for pvc_name\
    \ in $PVC_NAMES; do\n        # Getting details of the PVC\n        PVC=$(kubectl\
    \ get pvc $pvc_name -n $NAMESPACE --context=$CONTEXT -o json)\n        ACCESS_MODE=$(jq\
    \ -r '.spec.accessModes[0]' <<< \"$PVC\")\n\n        # Checking if the access\
    \ mode is ReadWriteOnce\n        if [[ \"$ACCESS_MODE\" == \"ReadWriteOnce\" ]];\
    \ then\n            PV_NAME=$(jq -r '.spec.volumeName' <<< \"$PVC\")\n       \
    \     # Finding the node where the storage of the PVC is located\n           \
    \ STORAGE_NODE_NAME=$(jq -r --arg pv \"$PV_NAME\" '.items[] | select(.status.volumesAttached\
    \ != null) | select(.status.volumesInUse[] | contains($pv)) | .metadata.name'\
    \ <<< \"$(kubectl get nodes --context=$CONTEXT -o json)\")\n            echo \"\
    ------------\"\n            # Comparing the pod node and storage node\n      \
    \      if [[ \"$POD_NODE_NAME\" == \"$STORAGE_NODE_NAME\" ]]; then\n         \
    \       echo \"OK: Pod and Storage Node Matched\"\n            else\n        \
    \        echo \"Error: Pod and Storage Node Mismatched - If the issue persists,\
    \ the node requires attention.\"\n            fi\n            echo \"Pod: $POD_NAME\"\
    \n            echo \"PVC: $pvc_name\"\n            echo \"PV: $PV_NAME\"\n   \
    \         echo \"Node with Pod: $POD_NODE_NAME\"\n            echo \"Node with\
    \ Storage: $STORAGE_NODE_NAME\"\n            echo\n        fi\n    done\ndone"
  name: check_for_rwo_persistent_volume_node_attachment_issues_in_namespace_namespace
