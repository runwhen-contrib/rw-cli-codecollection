commands:
- command: 'for pvc in $(kubectl get pvc -n ${NAMESPACE} --context ${CONTEXT} -o json
    | jq -r ''.items[] | select(.status.phase != "Bound") | .metadata.name''); do
    kubectl get events -n ${NAMESPACE} --context ${CONTEXT} --field-selector involvedObject.name=$pvc
    -o json | jq ''.items[]| "Last Timestamp: " + .lastTimestamp + ", Name: " + .involvedObject.name
    + ", Message: " + .message''; done'
  doc_links: '

    '
  explanation: 'This command is used to retrieve information about Persistent Volume
    Claims (PVC) in a Kubernetes cluster. Let''s break it down step by step:


    1. `for pvc in $(...)`: This part of the command sets up a loop, where it will
    perform the commands inside the loop for each PVC that meets the specified condition.


    2. `kubectl get pvc -n ${NAMESPACE} --context ${CONTEXT} -o json | jq -r ''.items[]
    | select(.status.phase != "Bound") | .metadata.name''`: This part of the command
    retrieves a list of PVCs in the specified namespace and context in JSON format,
    and then uses `jq` to filter out only the PVCs whose status phase is not "Bound".
    The resulting list contains the names of these PVCs.


    3. `do kubectl get events -n ${NAMESPACE} --context ${CONTEXT} --field-selector
    involvedObject.name=$pvc -o json | jq ''.items[]| "Last Timestamp: " + .lastTimestamp
    + ", Name: " + .involvedObject.name + ", Message: " + .message''`: This part of
    the command retrieves events related to each PVC found in the previous step. It
    uses the PVC name as a filter to only retrieve events related to that specific
    PVC. The resulting events are then formatted using `jq` to display the last timestamp,
    name, and message of each event.


    4. `done`: This marks the end of the loop, indicating that the commands inside
    the loop should be executed for each PVC found.


    In summary, this command loops through all PVCs in a specific namespace and context,
    checks for any unbound PVCs, and then retrieves and displays related events for
    each unbound PVC. It can be useful for troubleshooting or monitoring PVCs in a
    Kubernetes cluster.'
  multi_line_details: "# Get a list of PVCs in the specified namespace and context\n\
    pvc_list=$(kubectl get pvc -n ${NAMESPACE} --context ${CONTEXT} -o json | jq -r\
    \ '.items[] | select(.status.phase != \"Bound\") | .metadata.name')\n\n# Loop\
    \ through each PVC in the list\nfor pvc in $pvc_list; do \n  # Get events related\
    \ to the current PVC\n  events=$(kubectl get events -n ${NAMESPACE} --context\
    \ ${CONTEXT} --field-selector involvedObject.name=$pvc -o json | jq '.items[]|\
    \ \"Last Timestamp: \" + .lastTimestamp + \", Name: \" + .involvedObject.name\
    \ + \", Message: \" + .message')\n\n  # Print out the last event timestamp, PVC\
    \ name, and event message\n  echo $events\ndone"
  name: fetch_events_for_unhealthy_kubernetes_persistentvolumeclaims_in_namespace_namespace
- command: 'namespace=${NAMESPACE}; context=${CONTEXT}; kubectl get pvc -n $namespace
    --context=$context -o json | jq -r ''.items[] | select(.metadata.deletionTimestamp
    != null) | .metadata.name as $name | .metadata.deletionTimestamp as $deletion_time
    | .metadata.finalizers as $finalizers | "\($name) is in Terminating state (Deletion
    started at: \($deletion_time)). Finalizers: \($finalizers)"'''
  doc_links: '

    - [kubectl get](https://kubernetes.io/docs/reference/kubectl/overview/){:target="_blank"}

    - [pvc - PersistentVolumeClaim](https://kubernetes.io/docs/concepts/storage/persistent-volumes/){:target="_blank"}

    - [jq command](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: 'This command is used to retrieve information about Persistent Volume
    Claims (PVCs) in a Kubernetes cluster. Let''s break it down step by step.


    1. `namespace=${NAMESPACE}; context=${CONTEXT};`: This line sets the variables
    `namespace` and `context` to the values of `${NAMESPACE}` and `${CONTEXT}` respectively.
    These variables may have been defined earlier in a configuration file or as environment
    variables.


    2. `kubectl get pvc -n $namespace --context=$context -o json`: This part of the
    command uses `kubectl` to access the Kubernetes cluster, retrieve information
    about PVCs, and output the result in JSON format. The `-n $namespace` flag specifies
    the namespace to look for PVCs in, while the `--context=$context` flag specifies
    which context or specific cluster configuration to use.


    3. `| jq -r ''.items[] | select(.metadata.deletionTimestamp != null) | .metadata.name
    as $name | .metadata.deletionTimestamp as $deletion_time | .metadata.finalizers
    as $finalizers | "\($name) is in Terminating state (Deletion started at: \($deletion_time)).
    Finalizers: \($finalizers)"''`: This part of the command pipes the JSON output
    into the `jq` tool, which is used to parse and manipulate JSON data. In this case,
    it filters the PVCs with a `deletionTimestamp` set (indicating that they are being
    deleted), extracts the name, deletion time, and finalizers, and then formats the
    output into a human-readable message.


    As an engineer learning to use Kubernetes, this command would be helpful for monitoring
    and troubleshooting PVCs that are being deleted in the cluster. It provides detailed
    information about PVCs in a terminating state, including their name, deletion
    start time, and finalizers. By understanding and utilizing this command, you can
    efficiently manage and maintain PVCs within your Kubernetes environment.'
  multi_line_details: "```bash\n# Set the namespace to be used for the kubectl command\n\
    namespace=${NAMESPACE}\n\n# Set the context to be used for the kubectl command\n\
    context=${CONTEXT}\n\n# Use kubectl to get the PersistentVolumeClaims in the specified\
    \ namespace and output the result in JSON format\nkubectl get pvc -n $namespace\
    \ --context=$context -o json |\n\n# Use jq to process the JSON output\njq -r '.items[]\
    \ | select(.metadata.deletionTimestamp != null) | \n.metadata.name as $name |\
    \ .metadata.deletionTimestamp as $deletion_time | \n.metadata.finalizers as $finalizers\
    \ | \n\"\\($name) is in Terminating state (Deletion started at: \\($deletion_time)).\
    \ Finalizers: \\($finalizers)\"'\n```"
  name: list_persistentvolumeclaims_in_terminating_state_in_namespace_namespace
- command: 'for pv in $(kubectl get pv --context ${CONTEXT} -o json | jq -r ''.items[]
    | select(.status.phase == "Terminating") | .metadata.name''); do kubectl get events
    --all-namespaces --field-selector involvedObject.name=$pv --context ${CONTEXT}
    -o json | jq ''.items[]| "Last Timestamp: " + .lastTimestamp + " Name: " + .involvedObject.name
    + " Message: " + .message''; done'
  doc_links: '

    - [kubectl get pv documentation](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [jq documentation](https://stedolan.github.io/jq/manual/){:target="_blank"}

    - [kubectl get events documentation](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get-events){:target="_blank"}

    - [Kubernetes Contexts documentation](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#kubectl-context-and-configuration){:target="_blank"}'
  explanation: 'Sure, here''s a breakdown of the command:


    1. `for pv in $(...)`: This part of the command is using a for loop to iterate
    over each Persistent Volume (pv) listed in the output of the command enclosed
    in `$()`. The output of the command inside the parentheses will be used as the
    list of items to iterate through.


    2. `kubectl get pv --context ${CONTEXT} -o json`: This part of the command is
    using `kubectl` to get information about Persistent Volumes. Specifically, it''s
    using the `-o json` flag to output the information in JSON format and `--context`
    to specify the Kubernetes context to use.


    3. `jq -r ''.items[] | select(.status.phase == "Terminating") | .metadata.name''`:
    This part of the command is using `jq` to parse the JSON output from the previous
    command. It''s filtering the items to only include those with a status phase of
    "Terminating" and extracting their names.


    4. `do kubectl get events --all-namespaces --field-selector involvedObject.name=$pv
    --context ${CONTEXT} -o json`: Inside the loop, this part of the command is getting
    events related to the current Persistent Volume (pv) being iterated over. It''s
    using `--all-namespaces` to get events from all namespaces, `--field-selector`
    to filter events based on the name of the involved object, and `--context` to
    specify the Kubernetes context to use.


    5. `jq ''.items[]| "Last Timestamp: " + .lastTimestamp + " Name: " + .involvedObject.name
    + " Message: " + .message''`: Still inside the loop, this part of the command
    is using `jq` to format the JSON output of the events. It''s creating a string
    for each event that includes the last timestamp, involved object name, and message.


    So, when you run this command, it will iterate over each Persistent Volume that
    is in the "Terminating" phase and fetch the events associated with each one, formatting
    the event information in a specific way. This can help you troubleshoot issues
    related to terminating Persistent Volumes in your Kubernetes cluster.'
  multi_line_details: "```bash\n# Use kubectl to get a list of persistent volumes\
    \ (pv) in a specific context and output the result as JSON\npvs=$(kubectl get\
    \ pv --context ${CONTEXT} -o json)\n\n# Parse through the JSON output and filter\
    \ for pv items that are currently in the \"Terminating\" phase\nfor pv in $(echo\
    \ $pvs | jq -r '.items[] | select(.status.phase == \"Terminating\") | .metadata.name');\
    \ do\n\n    # Use kubectl to get events from all namespaces where the involvedObject\
    \ name matches the previously selected pv\n    events=$(kubectl get events --all-namespaces\
    \ --field-selector involvedObject.name=$pv --context ${CONTEXT} -o json)\n\n \
    \   # Parse through the events JSON output and format the relevant information\n\
    \    echo $(echo $events | jq '.items[]| \"Last Timestamp: \" + .lastTimestamp\
    \ + \" Name: \" + .involvedObject.name + \" Message: \" + .message')\n\ndone\n\
    ```"
  name: list_persistentvolumes_in_terminating_state_in_namespace_namespace
- command: 'for pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running
    --context ${CONTEXT} -o jsonpath=''{range .items[*]}{.metadata.name}{"\n"}{end}'');
    do for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context ${CONTEXT} -o
    jsonpath=''{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{"\n"}{end}'');
    do pv=$(kubectl get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath=''{.spec.volumeName}'')
    && status=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath=''{.status.phase}'')
    && node=$(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath=''{.spec.nodeName}'')
    && zone=$(kubectl get nodes $node --context ${CONTEXT} -o jsonpath=''{.metadata.labels.topology\.kubernetes\.io/zone}'')
    && ingressclass=$(kubectl get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT} -o
    jsonpath=''{.spec.storageClassName}'') && accessmode=$(kubectl get pvc $pvc -n
    ${NAMESPACE} --context ${CONTEXT} -o jsonpath=''{.status.accessModes[0]}'') &&
    reclaimpolicy=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath=''{.spec.persistentVolumeReclaimPolicy}'')
    && csidriver=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath=''{.spec.csi.driver}'')&&
    echo -e "\n------------\nPod: $pod\nPVC: $pvc\nPV: $pv\nStatus: $status\nNode:
    $node\nZone: $zone\nIngressClass: $ingressclass\nAccessModes: $accessmode\nReclaimPolicy:
    $reclaimpolicy\nCSIDriver: $csidriver\n"; done; done'
  doc_links: '

    '
  explanation: 'This command is a complex one that is used to gather specific information
    about running pods and their associated persistent volumes in a Kubernetes cluster.
    Let''s break it down step by step.


    1. The first part of the command iterates through all the running pods in a specified
    namespace using the `kubectl get pods` command. It filters the pods based on their
    running status and retrieves their names using JSON output formatting.


    2. Next, for each running pod, the command examines the volumes attached to the
    pod using the `kubectl get pods` command again. It extracts the names of the persistent
    volume claims (PVCs) associated with the pod using JSON output formatting.


    3. For each PVC, the command retrieves additional details such as the associated
    persistent volume (PV), its status, the node where the pod is running, the zone
    of the node, the storage class, access modes, reclaim policy, and the CSI driver
    using various kubectl commands and JSON output formatting.


    4. Finally, the gathered information for each PVC and PV is displayed using the
    `echo` command in a formatted manner, including details such as pod name, PVC
    name, PV name, status, node, zone, storage class, access modes, reclaim policy,
    and CSI driver.


    In summary, this complex command is used to automate the gathering of detailed
    information about running pods and their associated persistent volumes in a Kubernetes
    cluster. As a new engineer learning Kubernetes, understanding and practicing this
    command will help you gain insights into the interactions between pods and persistent
    volumes in a cluster.'
  multi_line_details: "```bash\n# Get the list of pods running in a specific namespace\
    \ and context\nfor pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running\
    \ --context ${CONTEXT} -o jsonpath='{range .items[*]}{.metadata.name}{\"\\n\"\
    }{end}');\ndo\n  # Get the list of persistent volume claims associated with each\
    \ pod\n  for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context ${CONTEXT}\
    \ -o jsonpath='{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{\"\\\
    n\"}{end}');\n  do\n    # Retrieve information about the persistent volume associated\
    \ with the persistent volume claim\n    pv=$(kubectl get pvc $pvc -n ${NAMESPACE}\
    \ --context ${CONTEXT} -o jsonpath='{.spec.volumeName}') &&\n    status=$(kubectl\
    \ get pv $pv --context ${CONTEXT} -o jsonpath='{.status.phase}') &&\n    node=$(kubectl\
    \ get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath='{.spec.nodeName}')\
    \ &&\n    zone=$(kubectl get nodes $node --context ${CONTEXT} -o jsonpath='{.metadata.labels.topology\\\
    .kubernetes\\.io/zone}') &&\n    ingressclass=$(kubectl get pvc $pvc -n ${NAMESPACE}\
    \ --context ${CONTEXT} -o jsonpath='{.spec.storageClassName}') &&\n    accessmode=$(kubectl\
    \ get pvc $pvc -n ${NAMESPACE} --context ${CONTEXT} -o jsonpath='{.status.accessModes[0]}')\
    \ &&\n    reclaimpolicy=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath='{.spec.persistentVolumeReclaimPolicy}')\
    \ &&\n    csidriver=$(kubectl get pv $pv --context ${CONTEXT} -o jsonpath='{.spec.csi.driver}')\
    \ &&\n    # Print out the collected information in a formatted manner\n    echo\
    \ -e \"\\n------------\\nPod: $pod\\nPVC: $pvc\\nPV: $pv\\nStatus: $status\\nNode:\
    \ $node\\nZone: $zone\\nIngressClass: $ingressclass\\nAccessModes: $accessmode\\\
    nReclaimPolicy: $reclaimpolicy\\nCSIDriver: $csidriver\\n\";\n  done;\ndone\n\
    ```"
  name: list_pods_with_attached_volumes_and_related_persistentvolume_details_in_namespace_namespace
- command: 'for pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running
    --context ${CONTEXT} -o jsonpath=''{range .items[*]}{.metadata.name}{"\n"}{end}'');
    do for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context ${CONTEXT} -o
    jsonpath=''{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{"\n"}{end}'');
    do for volumeName in $(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT}
    -o json | jq -r ''.spec.volumes[] | select(has("persistentVolumeClaim")) | .name'');
    do mountPath=$(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o json
    | jq -r --arg vol "$volumeName" ''.spec.containers[].volumeMounts[] | select(.name
    == $vol) | .mountPath''); containerName=$(kubectl get pod $pod -n ${NAMESPACE}
    --context ${CONTEXT} -o json | jq -r --arg vol "$volumeName" ''.spec.containers[]
    | select(.volumeMounts[].name == $vol) | .name''); echo -e "\n------------\nPod:
    $pod, PVC: $pvc, volumeName: $volumeName, containerName: $containerName, mountPath:
    $mountPath"; kubectl exec $pod -n ${NAMESPACE} --context ${CONTEXT} -c $containerName
    -- df -h $mountPath; done; done; done;'
  doc_links: '

    - [Kubernetes Get Pods](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get){:target="_blank"}

    - [Kubernetes Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/){:target="_blank"}

    - [kubectl Field Selectors](https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/){:target="_blank"}

    - [kubectl Contexts](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#context){:target="_blank"}

    - [kubectl JSONPath](https://kubernetes.io/docs/reference/kubectl/jsonpath/){:target="_blank"}

    - [jq Manual](https://stedolan.github.io/jq/manual/){:target="_blank"}'
  explanation: 'This command is a nested loop that retrieves information about running
    pods in a specific Kubernetes namespace. It then takes the names of the pods and
    uses them to get information about their associated persistent volume claims (PVCs).
    Finally, it fetches information about the volumes within the pods and prints out
    details such as the pod name, PVC name, volume name, container name, and mount
    path. It also runs the "df -h" command within each pod to display disk usage information
    for the specified mount path.


    As an engineer using Kubernetes daily, you may encounter scenarios where you need
    to gather detailed information about running pods and their associated resources.
    This command can be helpful in that regard, especially when troubleshooting or
    monitoring storage-related issues within your Kubernetes cluster. It demonstrates
    how you can leverage Kubernetes commands to extract and display relevant data
    about your pod environment, helping you better understand and manage your infrastructure.'
  multi_line_details: "```bash\n# Get list of running pods in the specified namespace\
    \ and context\nfor pod in $(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase=Running\
    \ --context ${CONTEXT} -o jsonpath='{range .items[*]}{.metadata.name}{\"\\n\"\
    }{end}'); do \n  # For each pod, get the list of associated persistentVolumeClaim\
    \ (PVC) names\n  for pvc in $(kubectl get pods $pod -n ${NAMESPACE} --context\
    \ ${CONTEXT} -o jsonpath='{range .spec.volumes[*]}{.persistentVolumeClaim.claimName}{\"\
    \\n\"}{end}'); do \n    # For each PVC, get the volume name from the pod's spec\n\
    \    for volumeName in $(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT}\
    \ -o json | jq -r '.spec.volumes[] | select(has(\"persistentVolumeClaim\")) |\
    \ .name'); do \n      # Get the mount path for the volume in the container\n \
    \     mountPath=$(kubectl get pod $pod -n ${NAMESPACE} --context ${CONTEXT} -o\
    \ json | jq -r --arg vol \"$volumeName\" '.spec.containers[].volumeMounts[] |\
    \ select(.name == $vol) | .mountPath'); \n      # Get the container name for the\
    \ volume\n      containerName=$(kubectl get pod $pod -n ${NAMESPACE} --context\
    \ ${CONTEXT} -o json | jq -r --arg vol \"$volumeName\" '.spec.containers[] | select(.volumeMounts[].name\
    \ == $vol) | .name'); \n      # Output the pod, PVC, volume name, container name,\
    \ and mount path\n      echo -e \"\\n------------\\nPod: $pod, PVC: $pvc, volumeName:\
    \ $volumeName, containerName: $containerName, mountPath: $mountPath\"; \n    \
    \  # Execute the \"df\" command inside the container to show disk usage for the\
    \ mount path\n      kubectl exec $pod -n ${NAMESPACE} --context ${CONTEXT} -c\
    \ $containerName -- df -h $mountPath; \n    done; \n  done; \ndone;\n```"
  name: fetch_the_storage_utilization_for_pvc_mounts_in_namespace_namespace
- command: 'NAMESPACE="${NAMESPACE}"; CONTEXT="${CONTEXT}"; PODS=$(kubectl get pods
    -n $NAMESPACE --context=$CONTEXT -o json); for pod in $(jq -r ''.items[] | @base64''
    <<< "$PODS"); do _jq() { jq -r \${1} <<< "$(base64 --decode <<< \${pod})"; };
    POD_NAME=$(_jq ''.metadata.name''); POD_NODE_NAME=$(kubectl get pod $POD_NAME
    -n $NAMESPACE --context=$CONTEXT -o custom-columns=:.spec.nodeName --no-headers);
    PVC_NAMES=$(kubectl get pod $POD_NAME -n $NAMESPACE --context=$CONTEXT -o jsonpath=''{.spec.volumes[*].persistentVolumeClaim.claimName}'');
    for pvc_name in $PVC_NAMES; do PVC=$(kubectl get pvc $pvc_name -n $NAMESPACE --context=$CONTEXT
    -o json); ACCESS_MODE=$(jq -r ''.spec.accessModes[0]'' <<< "$PVC"); if [[ "$ACCESS_MODE"
    == "ReadWriteOnce" ]]; then PV_NAME=$(jq -r ''.spec.volumeName'' <<< "$PVC");
    STORAGE_NODE_NAME=$(jq -r --arg pv "$PV_NAME" ''.items[] | select(.status.volumesAttached
    != null) | select(.status.volumesInUse[] | contains($pv)) | .metadata.name'' <<<
    "$(kubectl get nodes --context=$CONTEXT -o json)"); echo "------------"; if [[
    "$POD_NODE_NAME" == "$STORAGE_NODE_NAME" ]]; then echo "OK: Pod and Storage Node
    Matched"; else echo "Error: Pod and Storage Node Mismatched - If the issue persists,
    the node requires attention."; fi; echo "Pod: $POD_NAME"; echo "PVC: $pvc_name";
    echo "PV: $PV_NAME"; echo "Node with Pod: $POD_NODE_NAME"; echo "Node with Storage:
    $STORAGE_NODE_NAME"; echo; fi; done; done'
  doc_links: '

    '
  explanation: 'Sure! This command is a shell script that uses the `kubectl` command-line
    tool to interact with a Kubernetes cluster. Let''s break it down step by step.


    First, the command sets the variables NAMESPACE and CONTEXT, which specify the
    namespace and context (i.e., the cluster) in which the subsequent operations will
    be performed.


    Next, the command retrieves a list of pods from the specified namespace and context
    using the `kubectl get pods` command. The output is in JSON format and is stored
    in the variable PODS.


    Then, the command loops through each pod in the list using jq, a command-line
    JSON processor, to decode the base64-encoded representation of each pod. It then
    extracts information such as the pod name, node name, and persistent volume claim
    (PVC) names associated with the pod.


    For each PVC associated with the pod, the command retrieves detailed information
    about the PVC using `kubectl get pvc`. It then checks the access mode for the
    PVC, and if it is "ReadWriteOnce", it retrieves the name of the associated persistent
    volume (PV).


    Finally, for each "ReadWriteOnce" PVC, the command checks which node the PV is
    attached to and compares it with the node where the pod is running. If they match,
    it outputs "OK: Pod and Storage Node Matched". If they don''t match, it outputs
    "Error: Pod and Storage Node Mismatched" along with additional information.


    In summary, this command is designed to verify the alignment between pods and
    their associated storage nodes in a Kubernetes cluster by checking which node
    the storage volume attached to the pod is located on, and whether it matches the
    node where the pod is running.'
  multi_line_details: "```bash\n# Set the NAMESPACE and CONTEXT variables\nNAMESPACE=\"\
    ${NAMESPACE}\"\nCONTEXT=\"${CONTEXT}\"\n\n# Retrieve the list of pods in the specified\
    \ namespace and context in JSON format\nPODS=$(kubectl get pods -n $NAMESPACE\
    \ --context=$CONTEXT -o json)\n\n# Iterate through each pod in the JSON output\n\
    for pod in $(jq -r '.items[] | @base64' <<< \"$PODS\"); do\n  # Define a function\
    \ _jq to parse the base64-encoded data\n  _jq() {\n    jq -r ${1} <<< \"$(base64\
    \ --decode <<< ${pod})\"\n  }\n\n  # Extract the name of the current pod\n  POD_NAME=$(_jq\
    \ '.metadata.name')\n\n  # Retrieve the node name where the current pod is running\n\
    \  POD_NODE_NAME=$(kubectl get pod $POD_NAME -n $NAMESPACE --context=$CONTEXT\
    \ -o custom-columns=:.spec.nodeName --no-headers)\n\n  # Get the names of persistent\
    \ volume claims (PVCs) used by the pod\n  PVC_NAMES=$(kubectl get pod $POD_NAME\
    \ -n $NAMESPACE --context=$CONTEXT -o jsonpath='{.spec.volumes[*].persistentVolumeClaim.claimName}')\n\
    \n  # Iterate through each PVC name\n  for pvc_name in $PVC_NAMES; do\n    # Retrieve\
    \ the details of the PVC in JSON format\n    PVC=$(kubectl get pvc $pvc_name -n\
    \ $NAMESPACE --context=$CONTEXT -o json)\n\n    # Extract the access mode of the\
    \ PVC\n    ACCESS_MODE=$(jq -r '.spec.accessModes[0]' <<< \"$PVC\")\n\n    # Check\
    \ if the access mode is ReadWriteOnce\n    if [[ \"$ACCESS_MODE\" == \"ReadWriteOnce\"\
    \ ]]; then\n      # Extract the name of the associated persistent volume (PV)\n\
    \      PV_NAME=$(jq -r '.spec.volumeName' <<< \"$PVC\")\n\n      # Find the node\
    \ where the PV is attached\n      STORAGE_NODE_NAME=$(jq -r --arg pv \"$PV_NAME\"\
    \ '.items[] | select(.status.volumesAttached != null) | select(.status.volumesInUse[]\
    \ | contains($pv)) | .metadata.name' <<< \"$(kubectl get nodes --context=$CONTEXT\
    \ -o json)\")\n\n      # Output the comparison results between pod node and storage\
    \ node\n      echo \"------------\"\n      if [[ \"$POD_NODE_NAME\" == \"$STORAGE_NODE_NAME\"\
    \ ]]; then\n        echo \"OK: Pod and Storage Node Matched\"\n      else\n  \
    \      echo \"Error: Pod and Storage Node Mismatched - If the issue persists,\
    \ the node requires attention.\"\n      fi\n      echo \"Pod: $POD_NAME\"\n  \
    \    echo \"PVC: $pvc_name\"\n      echo \"PV: $PV_NAME\"\n      echo \"Node with\
    \ Pod: $POD_NODE_NAME\"\n      echo \"Node with Storage: $STORAGE_NODE_NAME\"\n\
    \      echo\n    fi\n  done\ndone\n```"
  name: check_for_rwo_persistent_volume_node_attachment_issues_in_namespace_namespace
